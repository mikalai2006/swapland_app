<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="icon"
      type="image/x-icon"
      href="https://openlayers.org/favicon.ico"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OLMAP</title>
    <script type="module" crossorigin>
      var ho = Object.defineProperty;
      var co = (i, e, t) =>
        e in i
          ? ho(i, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: t,
            })
          : (i[e] = t);
      var ar = (i, e, t) => co(i, typeof e != "symbol" ? e + "" : e, t);
      (function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
          n(r);
        new MutationObserver((r) => {
          for (const s of r)
            if (s.type === "childList")
              for (const o of s.addedNodes)
                o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(r) {
          const s = {};
          return (
            r.integrity && (s.integrity = r.integrity),
            r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === "use-credentials"
              ? (s.credentials = "include")
              : r.crossOrigin === "anonymous"
              ? (s.credentials = "omit")
              : (s.credentials = "same-origin"),
            s
          );
        }
        function n(r) {
          if (r.ep) return;
          r.ep = !0;
          const s = t(r);
          fetch(r.href, s);
        }
      })();
      class je {
        constructor(e) {
          this.propagationStopped,
            this.defaultPrevented,
            (this.type = e),
            (this.target = null);
        }
        preventDefault() {
          this.defaultPrevented = !0;
        }
        stopPropagation() {
          this.propagationStopped = !0;
        }
      }
      const Nt = { PROPERTYCHANGE: "propertychange" };
      class Sn {
        constructor() {
          this.disposed = !1;
        }
        dispose() {
          this.disposed || ((this.disposed = !0), this.disposeInternal());
        }
        disposeInternal() {}
      }
      function Pn(i, e) {
        return i > e ? 1 : i < e ? -1 : 0;
      }
      function xi(i, e, t) {
        if (i[0] <= e) return 0;
        const n = i.length;
        if (e <= i[n - 1]) return n - 1;
        if (typeof t == "function") {
          for (let r = 1; r < n; ++r) {
            const s = i[r];
            if (s === e) return r;
            if (s < e) return t(e, i[r - 1], s) > 0 ? r - 1 : r;
          }
          return n - 1;
        }
        if (t > 0) {
          for (let r = 1; r < n; ++r) if (i[r] < e) return r - 1;
          return n - 1;
        }
        if (t < 0) {
          for (let r = 1; r < n; ++r) if (i[r] <= e) return r;
          return n - 1;
        }
        for (let r = 1; r < n; ++r) {
          if (i[r] == e) return r;
          if (i[r] < e) return i[r - 1] - e < e - i[r] ? r - 1 : r;
        }
        return n - 1;
      }
      function uo(i, e) {
        const t = Array.isArray(e) ? e : [e],
          n = t.length;
        for (let r = 0; r < n; r++) i[i.length] = t[r];
      }
      function On(i, e) {
        const t = i.length;
        if (t !== e.length) return !1;
        for (let n = 0; n < t; n++) if (i[n] !== e[n]) return !1;
        return !0;
      }
      function fo(i, e, t) {
        const n = e || Pn;
        return i.every(function (r, s) {
          if (s === 0) return !0;
          const o = n(i[s - 1], r);
          return !(o > 0 || o === 0);
        });
      }
      function wn() {
        return !0;
      }
      function Dn() {
        return !1;
      }
      function vn() {}
      function go(i) {
        let e, t, n;
        return function () {
          const r = Array.prototype.slice.call(arguments);
          return (
            (!t || this !== n || !On(r, t)) &&
              ((n = this), (t = r), (e = i.apply(this, arguments))),
            e
          );
        };
      }
      function _o(i) {
        function e() {
          let t;
          try {
            t = i();
          } catch (n) {
            return Promise.reject(n);
          }
          return t instanceof Promise ? t : Promise.resolve(t);
        }
        return e();
      }
      function Fn(i) {
        for (const e in i) delete i[e];
      }
      function rs(i) {
        let e;
        for (e in i) return !1;
        return !e;
      }
      class Nn extends Sn {
        constructor(e) {
          super(),
            (this.eventTarget_ = e),
            (this.pendingRemovals_ = null),
            (this.dispatching_ = null),
            (this.listeners_ = null);
        }
        addEventListener(e, t) {
          if (!e || !t) return;
          const n = this.listeners_ || (this.listeners_ = {}),
            r = n[e] || (n[e] = []);
          r.includes(t) || r.push(t);
        }
        dispatchEvent(e) {
          const t = typeof e == "string",
            n = t ? e : e.type,
            r = this.listeners_ && this.listeners_[n];
          if (!r) return;
          const s = t ? new je(e) : e;
          s.target || (s.target = this.eventTarget_ || this);
          const o = this.dispatching_ || (this.dispatching_ = {}),
            a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
          n in o || ((o[n] = 0), (a[n] = 0)), ++o[n];
          let l;
          for (let h = 0, c = r.length; h < c; ++h)
            if (
              ("handleEvent" in r[h]
                ? (l = r[h].handleEvent(s))
                : (l = r[h].call(this, s)),
              l === !1 || s.propagationStopped)
            ) {
              l = !1;
              break;
            }
          if (--o[n] === 0) {
            let h = a[n];
            for (delete a[n]; h--; ) this.removeEventListener(n, vn);
            delete o[n];
          }
          return l;
        }
        disposeInternal() {
          this.listeners_ && Fn(this.listeners_);
        }
        getListeners(e) {
          return (this.listeners_ && this.listeners_[e]) || void 0;
        }
        hasListener(e) {
          return this.listeners_
            ? e
              ? e in this.listeners_
              : Object.keys(this.listeners_).length > 0
            : !1;
        }
        removeEventListener(e, t) {
          if (!this.listeners_) return;
          const n = this.listeners_[e];
          if (!n) return;
          const r = n.indexOf(t);
          r !== -1 &&
            (this.pendingRemovals_ && e in this.pendingRemovals_
              ? ((n[r] = vn), ++this.pendingRemovals_[e])
              : (n.splice(r, 1), n.length === 0 && delete this.listeners_[e]));
        }
      }
      const b = {
        CHANGE: "change",
        ERROR: "error",
        BLUR: "blur",
        CLEAR: "clear",
        CONTEXTMENU: "contextmenu",
        CLICK: "click",
        DBLCLICK: "dblclick",
        DRAGENTER: "dragenter",
        DRAGOVER: "dragover",
        DROP: "drop",
        FOCUS: "focus",
        KEYDOWN: "keydown",
        KEYPRESS: "keypress",
        LOAD: "load",
        RESIZE: "resize",
        TOUCHMOVE: "touchmove",
        WHEEL: "wheel",
      };
      function N(i, e, t, n, r) {
        if (r) {
          const o = t;
          t = function () {
            i.removeEventListener(e, t), o.apply(n ?? this, arguments);
          };
        } else n && n !== i && (t = t.bind(n));
        const s = { target: i, type: e, listener: t };
        return i.addEventListener(e, t), s;
      }
      function Rn(i, e, t, n) {
        return N(i, e, t, n, !0);
      }
      function V(i) {
        i &&
          i.target &&
          (i.target.removeEventListener(i.type, i.listener), Fn(i));
      }
      class Bt extends Nn {
        constructor() {
          super(),
            (this.on = this.onInternal),
            (this.once = this.onceInternal),
            (this.un = this.unInternal),
            (this.revision_ = 0);
        }
        changed() {
          ++this.revision_, this.dispatchEvent(b.CHANGE);
        }
        getRevision() {
          return this.revision_;
        }
        onInternal(e, t) {
          if (Array.isArray(e)) {
            const n = e.length,
              r = new Array(n);
            for (let s = 0; s < n; ++s) r[s] = N(this, e[s], t);
            return r;
          }
          return N(this, e, t);
        }
        onceInternal(e, t) {
          let n;
          if (Array.isArray(e)) {
            const r = e.length;
            n = new Array(r);
            for (let s = 0; s < r; ++s) n[s] = Rn(this, e[s], t);
          } else n = Rn(this, e, t);
          return (t.ol_key = n), n;
        }
        unInternal(e, t) {
          const n = t.ol_key;
          if (n) mo(n);
          else if (Array.isArray(e))
            for (let r = 0, s = e.length; r < s; ++r)
              this.removeEventListener(e[r], t);
          else this.removeEventListener(e, t);
        }
      }
      Bt.prototype.on;
      Bt.prototype.once;
      Bt.prototype.un;
      function mo(i) {
        if (Array.isArray(i)) for (let e = 0, t = i.length; e < t; ++e) V(i[e]);
        else V(i);
      }
      function D() {
        throw new Error("Unimplemented abstract method.");
      }
      let po = 0;
      function re(i) {
        return i.ol_uid || (i.ol_uid = String(++po));
      }
      class lr extends je {
        constructor(e, t, n) {
          super(e), (this.key = t), (this.oldValue = n);
        }
      }
      class De extends Bt {
        constructor(e) {
          super(),
            this.on,
            this.once,
            this.un,
            re(this),
            (this.values_ = null),
            e !== void 0 && this.setProperties(e);
        }
        get(e) {
          let t;
          return (
            this.values_ &&
              this.values_.hasOwnProperty(e) &&
              (t = this.values_[e]),
            t
          );
        }
        getKeys() {
          return (this.values_ && Object.keys(this.values_)) || [];
        }
        getProperties() {
          return (this.values_ && Object.assign({}, this.values_)) || {};
        }
        getPropertiesInternal() {
          return this.values_;
        }
        hasProperties() {
          return !!this.values_;
        }
        notify(e, t) {
          let n;
          (n = `change:${e}`),
            this.hasListener(n) && this.dispatchEvent(new lr(n, e, t)),
            (n = Nt.PROPERTYCHANGE),
            this.hasListener(n) && this.dispatchEvent(new lr(n, e, t));
        }
        addChangeListener(e, t) {
          this.addEventListener(`change:${e}`, t);
        }
        removeChangeListener(e, t) {
          this.removeEventListener(`change:${e}`, t);
        }
        set(e, t, n) {
          const r = this.values_ || (this.values_ = {});
          if (n) r[e] = t;
          else {
            const s = r[e];
            (r[e] = t), s !== t && this.notify(e, s);
          }
        }
        setProperties(e, t) {
          for (const n in e) this.set(n, e[n], t);
        }
        applyProperties(e) {
          e.values_ &&
            Object.assign(this.values_ || (this.values_ = {}), e.values_);
        }
        unset(e, t) {
          if (this.values_ && e in this.values_) {
            const n = this.values_[e];
            delete this.values_[e],
              rs(this.values_) && (this.values_ = null),
              t || this.notify(e, n);
          }
        }
      }
      const me = { ADD: "add", REMOVE: "remove" },
        hr = { LENGTH: "length" };
      class an extends je {
        constructor(e, t, n) {
          super(e), (this.element = t), (this.index = n);
        }
      }
      class Pe extends De {
        constructor(e, t) {
          if (
            (super(),
            this.on,
            this.once,
            this.un,
            (t = t || {}),
            (this.unique_ = !!t.unique),
            (this.array_ = e || []),
            this.unique_)
          )
            for (let n = 0, r = this.array_.length; n < r; ++n)
              this.assertUnique_(this.array_[n], n);
          this.updateLength_();
        }
        clear() {
          for (; this.getLength() > 0; ) this.pop();
        }
        extend(e) {
          for (let t = 0, n = e.length; t < n; ++t) this.push(e[t]);
          return this;
        }
        forEach(e) {
          const t = this.array_;
          for (let n = 0, r = t.length; n < r; ++n) e(t[n], n, t);
        }
        getArray() {
          return this.array_;
        }
        item(e) {
          return this.array_[e];
        }
        getLength() {
          return this.get(hr.LENGTH);
        }
        insertAt(e, t) {
          if (e < 0 || e > this.getLength())
            throw new Error("Index out of bounds: " + e);
          this.unique_ && this.assertUnique_(t),
            this.array_.splice(e, 0, t),
            this.updateLength_(),
            this.dispatchEvent(new an(me.ADD, t, e));
        }
        pop() {
          return this.removeAt(this.getLength() - 1);
        }
        push(e) {
          this.unique_ && this.assertUnique_(e);
          const t = this.getLength();
          return this.insertAt(t, e), this.getLength();
        }
        remove(e) {
          const t = this.array_;
          for (let n = 0, r = t.length; n < r; ++n)
            if (t[n] === e) return this.removeAt(n);
        }
        removeAt(e) {
          if (e < 0 || e >= this.getLength()) return;
          const t = this.array_[e];
          return (
            this.array_.splice(e, 1),
            this.updateLength_(),
            this.dispatchEvent(new an(me.REMOVE, t, e)),
            t
          );
        }
        setAt(e, t) {
          const n = this.getLength();
          if (e >= n) {
            this.insertAt(e, t);
            return;
          }
          if (e < 0) throw new Error("Index out of bounds: " + e);
          this.unique_ && this.assertUnique_(t, e);
          const r = this.array_[e];
          (this.array_[e] = t),
            this.dispatchEvent(new an(me.REMOVE, r, e)),
            this.dispatchEvent(new an(me.ADD, t, e));
        }
        updateLength_() {
          this.set(hr.LENGTH, this.array_.length);
        }
        assertUnique_(e, t) {
          for (let n = 0, r = this.array_.length; n < r; ++n)
            if (this.array_[n] === e && n !== t)
              throw new Error("Duplicate item added to a unique collection");
        }
      }
      function G(i, e) {
        if (!i) throw new Error(e);
      }
      new Array(6);
      function pt() {
        return [1, 0, 0, 1, 0, 0];
      }
      function ge(i, e) {
        const t = e[0],
          n = e[1];
        return (
          (e[0] = i[0] * t + i[2] * n + i[4]),
          (e[1] = i[1] * t + i[3] * n + i[5]),
          e
        );
      }
      function zt(i, e, t, n, r, s, o, a) {
        const l = Math.sin(s),
          h = Math.cos(s);
        return (
          (i[0] = n * h),
          (i[1] = r * l),
          (i[2] = -n * l),
          (i[3] = r * h),
          (i[4] = o * n * h - a * n * l + e),
          (i[5] = o * r * l + a * r * h + t),
          i
        );
      }
      function ss(i, e) {
        const t = yo(e);
        G(t !== 0, "Transformation matrix cannot be inverted");
        const n = e[0],
          r = e[1],
          s = e[2],
          o = e[3],
          a = e[4],
          l = e[5];
        return (
          (i[0] = o / t),
          (i[1] = -r / t),
          (i[2] = -s / t),
          (i[3] = n / t),
          (i[4] = (s * l - o * a) / t),
          (i[5] = -(n * l - r * a) / t),
          i
        );
      }
      function yo(i) {
        return i[0] * i[3] - i[1] * i[2];
      }
      const cr = [1e6, 1e6, 1e6, 1e6, 2, 2];
      function Eo(i) {
        return (
          "matrix(" +
          i.map((t, n) => Math.round(t * cr[n]) / cr[n]).join(", ") +
          ")"
        );
      }
      const J = {
        UNKNOWN: 0,
        INTERSECTING: 1,
        ABOVE: 2,
        RIGHT: 4,
        BELOW: 8,
        LEFT: 16,
      };
      function ur(i) {
        const e = nt();
        for (let t = 0, n = i.length; t < n; ++t) pn(e, i[t]);
        return e;
      }
      function wo(i, e, t) {
        const n = Math.min.apply(null, i),
          r = Math.min.apply(null, e),
          s = Math.max.apply(null, i),
          o = Math.max.apply(null, e);
        return Rt(n, r, s, o, t);
      }
      function vo(i, e) {
        return e
          ? ((e[0] = i[0]), (e[1] = i[1]), (e[2] = i[2]), (e[3] = i[3]), e)
          : i.slice();
      }
      function os(i, e, t) {
        let n, r;
        return (
          e < i[0] ? (n = i[0] - e) : i[2] < e ? (n = e - i[2]) : (n = 0),
          t < i[1] ? (r = i[1] - t) : i[3] < t ? (r = t - i[3]) : (r = 0),
          n * n + r * r
        );
      }
      function Ii(i, e) {
        return as(i, e[0], e[1]);
      }
      function Ro(i, e) {
        return i[0] <= e[0] && e[2] <= i[2] && i[1] <= e[1] && e[3] <= i[3];
      }
      function as(i, e, t) {
        return i[0] <= e && e <= i[2] && i[1] <= t && t <= i[3];
      }
      function dr(i, e) {
        const t = i[0],
          n = i[1],
          r = i[2],
          s = i[3],
          o = e[0],
          a = e[1];
        let l = J.UNKNOWN;
        return (
          o < t ? (l = l | J.LEFT) : o > r && (l = l | J.RIGHT),
          a < n ? (l = l | J.BELOW) : a > s && (l = l | J.ABOVE),
          l === J.UNKNOWN && (l = J.INTERSECTING),
          l
        );
      }
      function nt() {
        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      function Rt(i, e, t, n, r) {
        return r
          ? ((r[0] = i), (r[1] = e), (r[2] = t), (r[3] = n), r)
          : [i, e, t, n];
      }
      function Ht(i) {
        return Rt(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
      }
      function Co(i, e) {
        const t = i[0],
          n = i[1];
        return Rt(t, n, t, n, e);
      }
      function To(i, e, t, n, r) {
        const s = Ht(r);
        return ls(s, i, e, t, n);
      }
      function fi(i, e) {
        return i[0] == e[0] && i[2] == e[2] && i[1] == e[1] && i[3] == e[3];
      }
      function xo(i, e) {
        return (
          e[0] < i[0] && (i[0] = e[0]),
          e[2] > i[2] && (i[2] = e[2]),
          e[1] < i[1] && (i[1] = e[1]),
          e[3] > i[3] && (i[3] = e[3]),
          i
        );
      }
      function pn(i, e) {
        e[0] < i[0] && (i[0] = e[0]),
          e[0] > i[2] && (i[2] = e[0]),
          e[1] < i[1] && (i[1] = e[1]),
          e[1] > i[3] && (i[3] = e[1]);
      }
      function ls(i, e, t, n, r) {
        for (; t < n; t += r) Io(i, e[t], e[t + 1]);
        return i;
      }
      function Io(i, e, t) {
        (i[0] = Math.min(i[0], e)),
          (i[1] = Math.min(i[1], t)),
          (i[2] = Math.max(i[2], e)),
          (i[3] = Math.max(i[3], t));
      }
      function hs(i, e) {
        let t;
        return (
          (t = e(zn(i))),
          t || ((t = e(kn(i))), t) || ((t = e(Gn(i))), t) || ((t = e(it(i))), t)
            ? t
            : !1
        );
      }
      function kt(i) {
        let e = 0;
        return $t(i) || (e = X(i) * de(i)), e;
      }
      function zn(i) {
        return [i[0], i[1]];
      }
      function kn(i) {
        return [i[2], i[1]];
      }
      function vt(i) {
        return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
      }
      function Ao(i, e) {
        let t;
        if (e === "bottom-left") t = zn(i);
        else if (e === "bottom-right") t = kn(i);
        else if (e === "top-left") t = it(i);
        else if (e === "top-right") t = Gn(i);
        else throw new Error("Invalid corner");
        return t;
      }
      function gi(i, e, t, n, r) {
        const [s, o, a, l, h, c, u, d] = Mo(i, e, t, n);
        return Rt(
          Math.min(s, a, h, u),
          Math.min(o, l, c, d),
          Math.max(s, a, h, u),
          Math.max(o, l, c, d),
          r
        );
      }
      function Mo(i, e, t, n) {
        const r = (e * n[0]) / 2,
          s = (e * n[1]) / 2,
          o = Math.cos(t),
          a = Math.sin(t),
          l = r * o,
          h = r * a,
          c = s * o,
          u = s * a,
          d = i[0],
          g = i[1];
        return [
          d - l + u,
          g - h - c,
          d - l - u,
          g - h + c,
          d + l - u,
          g + h + c,
          d + l + u,
          g + h - c,
          d - l + u,
          g - h - c,
        ];
      }
      function de(i) {
        return i[3] - i[1];
      }
      function Re(i, e, t) {
        const n = t || nt();
        return (
          qt(i, e)
            ? (i[0] > e[0] ? (n[0] = i[0]) : (n[0] = e[0]),
              i[1] > e[1] ? (n[1] = i[1]) : (n[1] = e[1]),
              i[2] < e[2] ? (n[2] = i[2]) : (n[2] = e[2]),
              i[3] < e[3] ? (n[3] = i[3]) : (n[3] = e[3]))
            : Ht(n),
          n
        );
      }
      function it(i) {
        return [i[0], i[3]];
      }
      function Gn(i) {
        return [i[2], i[3]];
      }
      function X(i) {
        return i[2] - i[0];
      }
      function qt(i, e) {
        return i[0] <= e[2] && i[2] >= e[0] && i[1] <= e[3] && i[3] >= e[1];
      }
      function $t(i) {
        return i[2] < i[0] || i[3] < i[1];
      }
      function Lo(i, e) {
        return e
          ? ((e[0] = i[0]), (e[1] = i[1]), (e[2] = i[2]), (e[3] = i[3]), e)
          : i;
      }
      function bo(i, e, t) {
        let n = !1;
        const r = dr(i, e),
          s = dr(i, t);
        if (r === J.INTERSECTING || s === J.INTERSECTING) n = !0;
        else {
          const o = i[0],
            a = i[1],
            l = i[2],
            h = i[3],
            c = e[0],
            u = e[1],
            d = t[0],
            g = t[1],
            f = (g - u) / (d - c);
          let _, p;
          s & J.ABOVE &&
            !(r & J.ABOVE) &&
            ((_ = d - (g - h) / f), (n = _ >= o && _ <= l)),
            !n &&
              s & J.RIGHT &&
              !(r & J.RIGHT) &&
              ((p = g - (d - l) * f), (n = p >= a && p <= h)),
            !n &&
              s & J.BELOW &&
              !(r & J.BELOW) &&
              ((_ = d - (g - a) / f), (n = _ >= o && _ <= l)),
            !n &&
              s & J.LEFT &&
              !(r & J.LEFT) &&
              ((p = g - (d - o) * f), (n = p >= a && p <= h));
        }
        return n;
      }
      function So(i, e, t, n) {
        if ($t(i)) return Ht(t);
        let r = [];
        (r = [i[0], i[1], i[2], i[1], i[2], i[3], i[0], i[3]]), e(r, r, 2);
        const s = [],
          o = [];
        for (let a = 0, l = r.length; a < l; a += 2)
          s.push(r[a]), o.push(r[a + 1]);
        return wo(s, o, t);
      }
      function Po(i, e) {
        const t = e.getExtent(),
          n = vt(i);
        if (e.canWrapX() && (n[0] < t[0] || n[0] >= t[2])) {
          const r = X(t),
            o = Math.floor((n[0] - t[0]) / r) * r;
          (i[0] -= o), (i[2] -= o);
        }
        return i;
      }
      function cs(i, e, t) {
        if (e.canWrapX()) {
          const n = e.getExtent();
          if (!isFinite(i[0]) || !isFinite(i[2]))
            return [[n[0], i[1], n[2], i[3]]];
          Po(i, e);
          const r = X(n);
          if (X(i) > r && !t) return [[n[0], i[1], n[2], i[3]]];
          if (i[0] < n[0])
            return [
              [i[0] + r, i[1], n[2], i[3]],
              [n[0], i[1], i[2], i[3]],
            ];
          if (i[2] > n[2])
            return [
              [i[0], i[1], n[2], i[3]],
              [n[0], i[1], i[2] - r, i[3]],
            ];
        }
        return [i];
      }
      const Ai = {
        radians: 6370997 / (2 * Math.PI),
        degrees: (2 * Math.PI * 6370997) / 360,
        ft: 0.3048,
        m: 1,
        "us-ft": 1200 / 3937,
      };
      class us {
        constructor(e) {
          (this.code_ = e.code),
            (this.units_ = e.units),
            (this.extent_ = e.extent !== void 0 ? e.extent : null),
            (this.worldExtent_ =
              e.worldExtent !== void 0 ? e.worldExtent : null),
            (this.axisOrientation_ =
              e.axisOrientation !== void 0 ? e.axisOrientation : "enu"),
            (this.global_ = e.global !== void 0 ? e.global : !1),
            (this.canWrapX_ = !!(this.global_ && this.extent_)),
            (this.getPointResolutionFunc_ = e.getPointResolution),
            (this.defaultTileGrid_ = null),
            (this.metersPerUnit_ = e.metersPerUnit);
        }
        canWrapX() {
          return this.canWrapX_;
        }
        getCode() {
          return this.code_;
        }
        getExtent() {
          return this.extent_;
        }
        getUnits() {
          return this.units_;
        }
        getMetersPerUnit() {
          return this.metersPerUnit_ || Ai[this.units_];
        }
        getWorldExtent() {
          return this.worldExtent_;
        }
        getAxisOrientation() {
          return this.axisOrientation_;
        }
        isGlobal() {
          return this.global_;
        }
        setGlobal(e) {
          (this.global_ = e), (this.canWrapX_ = !!(e && this.extent_));
        }
        getDefaultTileGrid() {
          return this.defaultTileGrid_;
        }
        setDefaultTileGrid(e) {
          this.defaultTileGrid_ = e;
        }
        setExtent(e) {
          (this.extent_ = e), (this.canWrapX_ = !!(this.global_ && e));
        }
        setWorldExtent(e) {
          this.worldExtent_ = e;
        }
        setGetPointResolution(e) {
          this.getPointResolutionFunc_ = e;
        }
        getPointResolutionFunc() {
          return this.getPointResolutionFunc_;
        }
      }
      const Jt = 6378137,
        mt = Math.PI * Jt,
        Oo = [-mt, -mt, mt, mt],
        Do = [-180, -85, 180, 85],
        ln = Jt * Math.log(Math.tan(Math.PI / 2));
      class st extends us {
        constructor(e) {
          super({
            code: e,
            units: "m",
            extent: Oo,
            global: !0,
            worldExtent: Do,
            getPointResolution: function (t, n) {
              return t / Math.cosh(n[1] / Jt);
            },
          });
        }
      }
      const fr = [
        new st("EPSG:3857"),
        new st("EPSG:102100"),
        new st("EPSG:102113"),
        new st("EPSG:900913"),
        new st("http://www.opengis.net/def/crs/EPSG/0/3857"),
        new st("http://www.opengis.net/gml/srs/epsg.xml#3857"),
      ];
      function Fo(i, e, t, n) {
        const r = i.length;
        (t = t > 1 ? t : 2),
          (n = n ?? t),
          e === void 0 && (t > 2 ? (e = i.slice()) : (e = new Array(r)));
        for (let s = 0; s < r; s += n) {
          e[s] = (mt * i[s]) / 180;
          let o = Jt * Math.log(Math.tan((Math.PI * (+i[s + 1] + 90)) / 360));
          o > ln ? (o = ln) : o < -ln && (o = -ln), (e[s + 1] = o);
        }
        return e;
      }
      function No(i, e, t, n) {
        const r = i.length;
        (t = t > 1 ? t : 2),
          (n = n ?? t),
          e === void 0 && (t > 2 ? (e = i.slice()) : (e = new Array(r)));
        for (let s = 0; s < r; s += n)
          (e[s] = (180 * i[s]) / mt),
            (e[s + 1] =
              (360 * Math.atan(Math.exp(i[s + 1] / Jt))) / Math.PI - 90);
        return e;
      }
      const zo = 6378137,
        gr = [-180, -90, 180, 90],
        ko = (Math.PI * zo) / 180;
      class qe extends us {
        constructor(e, t) {
          super({
            code: e,
            units: "degrees",
            extent: gr,
            axisOrientation: t,
            global: !0,
            metersPerUnit: ko,
            worldExtent: gr,
          });
        }
      }
      const _r = [
        new qe("CRS:84"),
        new qe("EPSG:4326", "neu"),
        new qe("urn:ogc:def:crs:OGC:1.3:CRS84"),
        new qe("urn:ogc:def:crs:OGC:2:84"),
        new qe("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
        new qe("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
        new qe("http://www.opengis.net/def/crs/EPSG/0/4326", "neu"),
      ];
      let _i = {};
      function Go(i) {
        return (
          _i[i] ||
          _i[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] ||
          null
        );
      }
      function Xo(i, e) {
        _i[i] = e;
      }
      let yt = {};
      function Cn(i, e, t) {
        const n = i.getCode(),
          r = e.getCode();
        n in yt || (yt[n] = {}), (yt[n][r] = t);
      }
      function Yo(i, e) {
        let t;
        return i in yt && e in yt[i] && (t = yt[i][e]), t;
      }
      function q(i, e, t) {
        return Math.min(Math.max(i, e), t);
      }
      function Zo(i, e, t, n, r, s) {
        const o = r - t,
          a = s - n;
        if (o !== 0 || a !== 0) {
          const l = ((i - t) * o + (e - n) * a) / (o * o + a * a);
          l > 1 ? ((t = r), (n = s)) : l > 0 && ((t += o * l), (n += a * l));
        }
        return Et(i, e, t, n);
      }
      function Et(i, e, t, n) {
        const r = t - i,
          s = n - e;
        return r * r + s * s;
      }
      function Ko(i) {
        const e = i.length;
        for (let n = 0; n < e; n++) {
          let r = n,
            s = Math.abs(i[n][n]);
          for (let a = n + 1; a < e; a++) {
            const l = Math.abs(i[a][n]);
            l > s && ((s = l), (r = a));
          }
          if (s === 0) return null;
          const o = i[r];
          (i[r] = i[n]), (i[n] = o);
          for (let a = n + 1; a < e; a++) {
            const l = -i[a][n] / i[n][n];
            for (let h = n; h < e + 1; h++)
              n == h ? (i[a][h] = 0) : (i[a][h] += l * i[n][h]);
          }
        }
        const t = new Array(e);
        for (let n = e - 1; n >= 0; n--) {
          t[n] = i[n][e] / i[n][n];
          for (let r = n - 1; r >= 0; r--) i[r][e] -= i[r][n] * t[n];
        }
        return t;
      }
      function yn(i) {
        return (i * Math.PI) / 180;
      }
      function wt(i, e) {
        const t = i % e;
        return t * e < 0 ? t + e : t;
      }
      function Vo(i, e, t) {
        return i + t * (e - i);
      }
      function ds(i, e) {
        const t = Math.pow(10, e);
        return Math.round(i * t) / t;
      }
      function hn(i, e) {
        return Math.floor(ds(i, e));
      }
      function cn(i, e) {
        return Math.ceil(ds(i, e));
      }
      function Wo(i, e) {
        return (i[0] += +e[0]), (i[1] += +e[1]), i;
      }
      function Tn(i, e) {
        let t = !0;
        for (let n = i.length - 1; n >= 0; --n)
          if (i[n] != e[n]) {
            t = !1;
            break;
          }
        return t;
      }
      function Mi(i, e) {
        const t = Math.cos(e),
          n = Math.sin(e),
          r = i[0] * t - i[1] * n,
          s = i[1] * t + i[0] * n;
        return (i[0] = r), (i[1] = s), i;
      }
      function Uo(i, e) {
        return (i[0] *= e), (i[1] *= e), i;
      }
      function jo(i, e) {
        if (e.canWrapX()) {
          const t = X(e.getExtent()),
            n = Bo(i, e, t);
          n && (i[0] -= n * t);
        }
        return i;
      }
      function Bo(i, e, t) {
        const n = e.getExtent();
        let r = 0;
        return (
          e.canWrapX() &&
            (i[0] < n[0] || i[0] > n[2]) &&
            ((t = t || X(n)), (r = Math.floor((i[0] - n[0]) / t))),
          r
        );
      }
      const Ho = 63710088e-1;
      function mr(i, e, t) {
        t = t || Ho;
        const n = yn(i[1]),
          r = yn(e[1]),
          s = (r - n) / 2,
          o = yn(e[0] - i[0]) / 2,
          a =
            Math.sin(s) * Math.sin(s) +
            Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(r);
        return 2 * t * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
      function fs(...i) {
        console.warn(...i);
      }
      let mi = !0;
      function qo(i) {
        mi = !1;
      }
      function Li(i, e) {
        if (e !== void 0) {
          for (let t = 0, n = i.length; t < n; ++t) e[t] = i[t];
          e = e;
        } else e = i.slice();
        return e;
      }
      function gs(i, e) {
        if (e !== void 0 && i !== e) {
          for (let t = 0, n = i.length; t < n; ++t) e[t] = i[t];
          i = e;
        }
        return i;
      }
      function $o(i) {
        Xo(i.getCode(), i), Cn(i, i, Li);
      }
      function Jo(i) {
        i.forEach($o);
      }
      function pe(i) {
        return typeof i == "string" ? Go(i) : i || null;
      }
      function pr(i, e, t, n) {
        i = pe(i);
        let r;
        const s = i.getPointResolutionFunc();
        if (s) r = s(e, t);
        else {
          const o = i.getUnits();
          if ((o == "degrees" && !n) || n == "degrees") r = e;
          else {
            const a = Si(i, pe("EPSG:4326"));
            if (a === gs && o !== "degrees") r = e * i.getMetersPerUnit();
            else {
              let h = [
                t[0] - e / 2,
                t[1],
                t[0] + e / 2,
                t[1],
                t[0],
                t[1] - e / 2,
                t[0],
                t[1] + e / 2,
              ];
              h = a(h, h, 2);
              const c = mr(h.slice(0, 2), h.slice(2, 4)),
                u = mr(h.slice(4, 6), h.slice(6, 8));
              r = (c + u) / 2;
            }
            const l = i.getMetersPerUnit();
            l !== void 0 && (r /= l);
          }
        }
        return r;
      }
      function yr(i) {
        Jo(i),
          i.forEach(function (e) {
            i.forEach(function (t) {
              e !== t && Cn(e, t, Li);
            });
          });
      }
      function Qo(i, e, t, n) {
        i.forEach(function (r) {
          e.forEach(function (s) {
            Cn(r, s, t), Cn(s, r, n);
          });
        });
      }
      function bi(i, e) {
        return i ? (typeof i == "string" ? pe(i) : i) : pe(e);
      }
      function qn(i, e) {
        if (i === e) return !0;
        const t = i.getUnits() === e.getUnits();
        return (i.getCode() === e.getCode() || Si(i, e) === Li) && t;
      }
      function Si(i, e) {
        const t = i.getCode(),
          n = e.getCode();
        let r = Yo(t, n);
        return r || (r = gs), r;
      }
      function Gt(i, e) {
        const t = pe(i),
          n = pe(e);
        return Si(t, n);
      }
      function Pi(i, e, t) {
        return Gt(e, t)(i, void 0, i.length);
      }
      function _s(i, e, t, n) {
        const r = Gt(e, t);
        return So(i, r, void 0);
      }
      let Me = null;
      function ea(i) {
        Me = pe(i);
      }
      function ta() {
        return Me;
      }
      function na() {
        ea("EPSG:4326");
      }
      function pi(i, e) {
        return Me ? Pi(i, e, Me) : i;
      }
      function be(i, e) {
        return Me
          ? Pi(i, Me, e)
          : (mi &&
              !Tn(i, [0, 0]) &&
              i[0] >= -180 &&
              i[0] <= 180 &&
              i[1] >= -90 &&
              i[1] <= 90 &&
              ((mi = !1),
              fs(
                "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
              )),
            i);
      }
      function ia(i, e) {
        return Me ? _s(i, e, Me) : i;
      }
      function Je(i, e) {
        return Me ? _s(i, Me, e) : i;
      }
      function ra() {
        yr(fr), yr(_r), Qo(_r, fr, Fo, No);
      }
      ra();
      function sa(i, e, t, n, r, s, o) {
        (s = s || []), (o = o || 2);
        let a = 0;
        for (let l = e; l < t; l += n) {
          const h = i[l],
            c = i[l + 1];
          (s[a++] = r[0] * h + r[2] * c + r[4]),
            (s[a++] = r[1] * h + r[3] * c + r[5]);
          for (let u = 2; u < o; u++) s[a++] = i[l + u];
        }
        return s && s.length != a && (s.length = a), s;
      }
      function oa(i, e, t, n, r, s, o) {
        o = o || [];
        const a = Math.cos(r),
          l = Math.sin(r),
          h = s[0],
          c = s[1];
        let u = 0;
        for (let d = e; d < t; d += n) {
          const g = i[d] - h,
            f = i[d + 1] - c;
          (o[u++] = h + g * a - f * l), (o[u++] = c + g * l + f * a);
          for (let _ = d + 2; _ < d + n; ++_) o[u++] = i[_];
        }
        return o && o.length != u && (o.length = u), o;
      }
      function aa(i, e, t, n, r, s, o, a) {
        a = a || [];
        const l = o[0],
          h = o[1];
        let c = 0;
        for (let u = e; u < t; u += n) {
          const d = i[u] - l,
            g = i[u + 1] - h;
          (a[c++] = l + r * d), (a[c++] = h + s * g);
          for (let f = u + 2; f < u + n; ++f) a[c++] = i[f];
        }
        return a && a.length != c && (a.length = c), a;
      }
      function la(i, e, t, n, r, s, o) {
        o = o || [];
        let a = 0;
        for (let l = e; l < t; l += n) {
          (o[a++] = i[l] + r), (o[a++] = i[l + 1] + s);
          for (let h = l + 2; h < l + n; ++h) o[a++] = i[h];
        }
        return o && o.length != a && (o.length = a), o;
      }
      const Er = pt();
      class ha extends De {
        constructor() {
          super(),
            (this.extent_ = nt()),
            (this.extentRevision_ = -1),
            (this.simplifiedGeometryMaxMinSquaredTolerance = 0),
            (this.simplifiedGeometryRevision = 0),
            (this.simplifyTransformedInternal = go((e, t, n) => {
              if (!n) return this.getSimplifiedGeometry(t);
              const r = this.clone();
              return r.applyTransform(n), r.getSimplifiedGeometry(t);
            }));
        }
        simplifyTransformed(e, t) {
          return this.simplifyTransformedInternal(this.getRevision(), e, t);
        }
        clone() {
          return D();
        }
        closestPointXY(e, t, n, r) {
          return D();
        }
        containsXY(e, t) {
          const n = this.getClosestPoint([e, t]);
          return n[0] === e && n[1] === t;
        }
        getClosestPoint(e, t) {
          return (
            (t = t || [NaN, NaN]), this.closestPointXY(e[0], e[1], t, 1 / 0), t
          );
        }
        intersectsCoordinate(e) {
          return this.containsXY(e[0], e[1]);
        }
        computeExtent(e) {
          return D();
        }
        getExtent(e) {
          if (this.extentRevision_ != this.getRevision()) {
            const t = this.computeExtent(this.extent_);
            (isNaN(t[0]) || isNaN(t[1])) && Ht(t),
              (this.extentRevision_ = this.getRevision());
          }
          return Lo(this.extent_, e);
        }
        rotate(e, t) {
          D();
        }
        scale(e, t, n) {
          D();
        }
        simplify(e) {
          return this.getSimplifiedGeometry(e * e);
        }
        getSimplifiedGeometry(e) {
          return D();
        }
        getType() {
          return D();
        }
        applyTransform(e) {
          D();
        }
        intersectsExtent(e) {
          return D();
        }
        translate(e, t) {
          D();
        }
        transform(e, t) {
          const n = pe(e),
            r =
              n.getUnits() == "tile-pixels"
                ? function (s, o, a) {
                    const l = n.getExtent(),
                      h = n.getWorldExtent(),
                      c = de(h) / de(l);
                    return (
                      zt(Er, h[0], h[3], c, -c, 0, 0, 0),
                      sa(s, 0, s.length, a, Er, o),
                      Gt(n, t)(s, o, a)
                    );
                  }
                : Gt(n, t);
          return this.applyTransform(r), this;
        }
      }
      class Oi extends ha {
        constructor() {
          super(),
            (this.layout = "XY"),
            (this.stride = 2),
            this.flatCoordinates;
        }
        computeExtent(e) {
          return To(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            e
          );
        }
        getCoordinates() {
          return D();
        }
        getFirstCoordinate() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        getFlatCoordinates() {
          return this.flatCoordinates;
        }
        getLastCoordinate() {
          return this.flatCoordinates.slice(
            this.flatCoordinates.length - this.stride
          );
        }
        getLayout() {
          return this.layout;
        }
        getSimplifiedGeometry(e) {
          if (
            (this.simplifiedGeometryRevision !== this.getRevision() &&
              ((this.simplifiedGeometryMaxMinSquaredTolerance = 0),
              (this.simplifiedGeometryRevision = this.getRevision())),
            e < 0 ||
              (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                e <= this.simplifiedGeometryMaxMinSquaredTolerance))
          )
            return this;
          const t = this.getSimplifiedGeometryInternal(e);
          return t.getFlatCoordinates().length < this.flatCoordinates.length
            ? t
            : ((this.simplifiedGeometryMaxMinSquaredTolerance = e), this);
        }
        getSimplifiedGeometryInternal(e) {
          return this;
        }
        getStride() {
          return this.stride;
        }
        setFlatCoordinates(e, t) {
          (this.stride = wr(e)), (this.layout = e), (this.flatCoordinates = t);
        }
        setCoordinates(e, t) {
          D();
        }
        setLayout(e, t, n) {
          let r;
          if (e) r = wr(e);
          else {
            for (let s = 0; s < n; ++s) {
              if (t.length === 0) {
                (this.layout = "XY"), (this.stride = 2);
                return;
              }
              t = t[0];
            }
            (r = t.length), (e = ca(r));
          }
          (this.layout = e), (this.stride = r);
        }
        applyTransform(e) {
          this.flatCoordinates &&
            (e(
              this.flatCoordinates,
              this.flatCoordinates,
              this.layout.startsWith("XYZ") ? 3 : 2,
              this.stride
            ),
            this.changed());
        }
        rotate(e, t) {
          const n = this.getFlatCoordinates();
          if (n) {
            const r = this.getStride();
            oa(n, 0, n.length, r, e, t, n), this.changed();
          }
        }
        scale(e, t, n) {
          t === void 0 && (t = e), n || (n = vt(this.getExtent()));
          const r = this.getFlatCoordinates();
          if (r) {
            const s = this.getStride();
            aa(r, 0, r.length, s, e, t, n, r), this.changed();
          }
        }
        translate(e, t) {
          const n = this.getFlatCoordinates();
          if (n) {
            const r = this.getStride();
            la(n, 0, n.length, r, e, t, n), this.changed();
          }
        }
      }
      function ca(i) {
        let e;
        return (
          i == 2 ? (e = "XY") : i == 3 ? (e = "XYZ") : i == 4 && (e = "XYZM"), e
        );
      }
      function wr(i) {
        let e;
        return (
          i == "XY"
            ? (e = 2)
            : i == "XYZ" || i == "XYM"
            ? (e = 3)
            : i == "XYZM" && (e = 4),
          e
        );
      }
      function vr(i, e, t, n, r, s, o) {
        const a = i[e],
          l = i[e + 1],
          h = i[t] - a,
          c = i[t + 1] - l;
        let u;
        if (h === 0 && c === 0) u = e;
        else {
          const d = ((r - a) * h + (s - l) * c) / (h * h + c * c);
          if (d > 1) u = t;
          else if (d > 0) {
            for (let g = 0; g < n; ++g) o[g] = Vo(i[e + g], i[t + g], d);
            o.length = n;
            return;
          } else u = e;
        }
        for (let d = 0; d < n; ++d) o[d] = i[u + d];
        o.length = n;
      }
      function ms(i, e, t, n, r) {
        let s = i[e],
          o = i[e + 1];
        for (e += n; e < t; e += n) {
          const a = i[e],
            l = i[e + 1],
            h = Et(s, o, a, l);
          h > r && (r = h), (s = a), (o = l);
        }
        return r;
      }
      function ua(i, e, t, n, r) {
        for (let s = 0, o = t.length; s < o; ++s) {
          const a = t[s];
          (r = ms(i, e, a, n, r)), (e = a);
        }
        return r;
      }
      function ps(i, e, t, n, r, s, o, a, l, h, c) {
        if (e == t) return h;
        let u, d;
        if (r === 0) {
          if (((d = Et(o, a, i[e], i[e + 1])), d < h)) {
            for (u = 0; u < n; ++u) l[u] = i[e + u];
            return (l.length = n), d;
          }
          return h;
        }
        c = c || [NaN, NaN];
        let g = e + n;
        for (; g < t; )
          if (
            (vr(i, g - n, g, n, o, a, c), (d = Et(o, a, c[0], c[1])), d < h)
          ) {
            for (h = d, u = 0; u < n; ++u) l[u] = c[u];
            (l.length = n), (g += n);
          } else g += n * Math.max(((Math.sqrt(d) - Math.sqrt(h)) / r) | 0, 1);
        if ((vr(i, t - n, e, n, o, a, c), (d = Et(o, a, c[0], c[1])), d < h)) {
          for (h = d, u = 0; u < n; ++u) l[u] = c[u];
          l.length = n;
        }
        return h;
      }
      function da(i, e, t, n, r, s, o, a, l, h, c) {
        c = c || [NaN, NaN];
        for (let u = 0, d = t.length; u < d; ++u) {
          const g = t[u];
          (h = ps(i, e, g, n, r, s, o, a, l, h, c)), (e = g);
        }
        return h;
      }
      function fa(i, e, t, n) {
        for (let r = 0, s = t.length; r < s; ++r) i[e++] = t[r];
        return e;
      }
      function ys(i, e, t, n) {
        for (let r = 0, s = t.length; r < s; ++r) {
          const o = t[r];
          for (let a = 0; a < n; ++a) i[e++] = o[a];
        }
        return e;
      }
      function ga(i, e, t, n, r) {
        r = r || [];
        let s = 0;
        for (let o = 0, a = t.length; o < a; ++o) {
          const l = ys(i, e, t[o], n);
          (r[s++] = l), (e = l);
        }
        return (r.length = s), r;
      }
      function _a(i, e, t, n, r, s, o) {
        const a = (t - e) / n;
        if (a < 3) {
          for (; e < t; e += n) (s[o++] = i[e]), (s[o++] = i[e + 1]);
          return o;
        }
        const l = new Array(a);
        (l[0] = 1), (l[a - 1] = 1);
        const h = [e, t - n];
        let c = 0;
        for (; h.length > 0; ) {
          const u = h.pop(),
            d = h.pop();
          let g = 0;
          const f = i[d],
            _ = i[d + 1],
            p = i[u],
            E = i[u + 1];
          for (let y = d + n; y < u; y += n) {
            const R = i[y],
              v = i[y + 1],
              w = Zo(R, v, f, _, p, E);
            w > g && ((c = y), (g = w));
          }
          g > r &&
            ((l[(c - e) / n] = 1),
            d + n < c && h.push(d, c),
            c + n < u && h.push(c, u));
        }
        for (let u = 0; u < a; ++u)
          l[u] && ((s[o++] = i[e + u * n]), (s[o++] = i[e + u * n + 1]));
        return o;
      }
      function ot(i, e) {
        return e * Math.round(i / e);
      }
      function ma(i, e, t, n, r, s, o) {
        if (e == t) return o;
        let a = ot(i[e], r),
          l = ot(i[e + 1], r);
        (e += n), (s[o++] = a), (s[o++] = l);
        let h, c;
        do
          if (((h = ot(i[e], r)), (c = ot(i[e + 1], r)), (e += n), e == t))
            return (s[o++] = h), (s[o++] = c), o;
        while (h == a && c == l);
        for (; e < t; ) {
          const u = ot(i[e], r),
            d = ot(i[e + 1], r);
          if (((e += n), u == h && d == c)) continue;
          const g = h - a,
            f = c - l,
            _ = u - a,
            p = d - l;
          if (
            g * p == f * _ &&
            ((g < 0 && _ < g) || g == _ || (g > 0 && _ > g)) &&
            ((f < 0 && p < f) || f == p || (f > 0 && p > f))
          ) {
            (h = u), (c = d);
            continue;
          }
          (s[o++] = h), (s[o++] = c), (a = h), (l = c), (h = u), (c = d);
        }
        return (s[o++] = h), (s[o++] = c), o;
      }
      function pa(i, e, t, n, r, s, o, a) {
        for (let l = 0, h = t.length; l < h; ++l) {
          const c = t[l];
          (o = ma(i, e, c, n, r, s, o)), a.push(o), (e = c);
        }
        return o;
      }
      function Es(i, e, t, n, r) {
        r = r !== void 0 ? r : [];
        let s = 0;
        for (let o = e; o < t; o += n) r[s++] = i.slice(o, o + n);
        return (r.length = s), r;
      }
      function ya(i, e, t, n, r) {
        r = r !== void 0 ? r : [];
        let s = 0;
        for (let o = 0, a = t.length; o < a; ++o) {
          const l = t[o];
          (r[s++] = Es(i, e, l, n, r[s])), (e = l);
        }
        return (r.length = s), r;
      }
      function ws(i, e, t, n) {
        let r = 0;
        const s = i[t - n],
          o = i[t - n + 1];
        let a = 0,
          l = 0;
        for (; e < t; e += n) {
          const h = i[e] - s,
            c = i[e + 1] - o;
          (r += l * h - a * c), (a = h), (l = c);
        }
        return r / 2;
      }
      function Ea(i, e, t, n) {
        let r = 0;
        for (let s = 0, o = t.length; s < o; ++s) {
          const a = t[s];
          (r += ws(i, e, a, n)), (e = a);
        }
        return r;
      }
      class Xt extends Oi {
        constructor(e, t) {
          super(),
            (this.maxDelta_ = -1),
            (this.maxDeltaRevision_ = -1),
            t !== void 0 && !Array.isArray(e[0])
              ? this.setFlatCoordinates(t, e)
              : this.setCoordinates(e, t);
        }
        clone() {
          return new Xt(this.flatCoordinates.slice(), this.layout);
        }
        closestPointXY(e, t, n, r) {
          return r < os(this.getExtent(), e, t)
            ? r
            : (this.maxDeltaRevision_ != this.getRevision() &&
                ((this.maxDelta_ = Math.sqrt(
                  ms(
                    this.flatCoordinates,
                    0,
                    this.flatCoordinates.length,
                    this.stride,
                    0
                  )
                )),
                (this.maxDeltaRevision_ = this.getRevision())),
              ps(
                this.flatCoordinates,
                0,
                this.flatCoordinates.length,
                this.stride,
                this.maxDelta_,
                !0,
                e,
                t,
                n,
                r
              ));
        }
        getArea() {
          return ws(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride
          );
        }
        getCoordinates() {
          return Es(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride
          );
        }
        getSimplifiedGeometryInternal(e) {
          const t = [];
          return (
            (t.length = _a(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              e,
              t,
              0
            )),
            new Xt(t, "XY")
          );
        }
        getType() {
          return "LinearRing";
        }
        intersectsExtent(e) {
          return !1;
        }
        setCoordinates(e, t) {
          this.setLayout(t, e, 1),
            this.flatCoordinates || (this.flatCoordinates = []),
            (this.flatCoordinates.length = ys(
              this.flatCoordinates,
              0,
              e,
              this.stride
            )),
            this.changed();
        }
      }
      class Di extends Oi {
        constructor(e, t) {
          super(), this.setCoordinates(e, t);
        }
        clone() {
          const e = new Di(this.flatCoordinates.slice(), this.layout);
          return e.applyProperties(this), e;
        }
        closestPointXY(e, t, n, r) {
          const s = this.flatCoordinates,
            o = Et(e, t, s[0], s[1]);
          if (o < r) {
            const a = this.stride;
            for (let l = 0; l < a; ++l) n[l] = s[l];
            return (n.length = a), o;
          }
          return r;
        }
        getCoordinates() {
          return this.flatCoordinates.slice();
        }
        computeExtent(e) {
          return Co(this.flatCoordinates, e);
        }
        getType() {
          return "Point";
        }
        intersectsExtent(e) {
          return as(e, this.flatCoordinates[0], this.flatCoordinates[1]);
        }
        setCoordinates(e, t) {
          this.setLayout(t, e, 0),
            this.flatCoordinates || (this.flatCoordinates = []),
            (this.flatCoordinates.length = fa(
              this.flatCoordinates,
              0,
              e,
              this.stride
            )),
            this.changed();
        }
      }
      function wa(i, e, t, n, r) {
        return !hs(r, function (o) {
          return !Qe(i, e, t, n, o[0], o[1]);
        });
      }
      function Qe(i, e, t, n, r, s) {
        let o = 0,
          a = i[t - n],
          l = i[t - n + 1];
        for (; e < t; e += n) {
          const h = i[e],
            c = i[e + 1];
          l <= s
            ? c > s && (h - a) * (s - l) - (r - a) * (c - l) > 0 && o++
            : c <= s && (h - a) * (s - l) - (r - a) * (c - l) < 0 && o--,
            (a = h),
            (l = c);
        }
        return o !== 0;
      }
      function vs(i, e, t, n, r, s) {
        if (t.length === 0 || !Qe(i, e, t[0], n, r, s)) return !1;
        for (let o = 1, a = t.length; o < a; ++o)
          if (Qe(i, t[o - 1], t[o], n, r, s)) return !1;
        return !0;
      }
      function va(i, e, t, n, r, s, o) {
        let a, l, h, c, u, d, g;
        const f = r[s + 1],
          _ = [];
        for (let y = 0, R = t.length; y < R; ++y) {
          const v = t[y];
          for (c = i[v - n], d = i[v - n + 1], a = e; a < v; a += n)
            (u = i[a]),
              (g = i[a + 1]),
              ((f <= d && g <= f) || (d <= f && f <= g)) &&
                ((h = ((f - d) / (g - d)) * (u - c) + c), _.push(h)),
              (c = u),
              (d = g);
        }
        let p = NaN,
          E = -1 / 0;
        for (_.sort(Pn), c = _[0], a = 1, l = _.length; a < l; ++a) {
          u = _[a];
          const y = Math.abs(u - c);
          y > E &&
            ((h = (c + u) / 2), vs(i, e, t, n, h, f) && ((p = h), (E = y))),
            (c = u);
        }
        return isNaN(p) && (p = r[s]), [p, f, E];
      }
      function Ra(i, e, t, n, r) {
        let s;
        for (e += n; e < t; e += n)
          if (((s = r(i.slice(e - n, e), i.slice(e, e + n))), s)) return s;
        return !1;
      }
      function Rs(i, e, t, n, r) {
        const s = ls(nt(), i, e, t, n);
        return qt(r, s)
          ? Ro(r, s) ||
            (s[0] >= r[0] && s[2] <= r[2]) ||
            (s[1] >= r[1] && s[3] <= r[3])
            ? !0
            : Ra(i, e, t, n, function (o, a) {
                return bo(r, o, a);
              })
          : !1;
      }
      function Cs(i, e, t, n, r) {
        return !!(
          Rs(i, e, t, n, r) ||
          Qe(i, e, t, n, r[0], r[1]) ||
          Qe(i, e, t, n, r[0], r[3]) ||
          Qe(i, e, t, n, r[2], r[1]) ||
          Qe(i, e, t, n, r[2], r[3])
        );
      }
      function Ca(i, e, t, n, r) {
        if (!Cs(i, e, t[0], n, r)) return !1;
        if (t.length === 1) return !0;
        for (let s = 1, o = t.length; s < o; ++s)
          if (wa(i, t[s - 1], t[s], n, r) && !Rs(i, t[s - 1], t[s], n, r))
            return !1;
        return !0;
      }
      function Ta(i, e, t, n) {
        for (; e < t - n; ) {
          for (let r = 0; r < n; ++r) {
            const s = i[e + r];
            (i[e + r] = i[t - n + r]), (i[t - n + r] = s);
          }
          (e += n), (t -= n);
        }
      }
      function Ts(i, e, t, n) {
        let r = 0,
          s = i[t - n],
          o = i[t - n + 1];
        for (; e < t; e += n) {
          const a = i[e],
            l = i[e + 1];
          (r += (a - s) * (l + o)), (s = a), (o = l);
        }
        return r === 0 ? void 0 : r > 0;
      }
      function xa(i, e, t, n, r) {
        r = r !== void 0 ? r : !1;
        for (let s = 0, o = t.length; s < o; ++s) {
          const a = t[s],
            l = Ts(i, e, a, n);
          if (s === 0) {
            if ((r && l) || (!r && !l)) return !1;
          } else if ((r && !l) || (!r && l)) return !1;
          e = a;
        }
        return !0;
      }
      function Rr(i, e, t, n, r) {
        r = r !== void 0 ? r : !1;
        for (let s = 0, o = t.length; s < o; ++s) {
          const a = t[s],
            l = Ts(i, e, a, n);
          (s === 0 ? (r && l) || (!r && !l) : (r && !l) || (!r && l)) &&
            Ta(i, e, a, n),
            (e = a);
        }
        return e;
      }
      class Yt extends Oi {
        constructor(e, t, n) {
          super(),
            (this.ends_ = []),
            (this.flatInteriorPointRevision_ = -1),
            (this.flatInteriorPoint_ = null),
            (this.maxDelta_ = -1),
            (this.maxDeltaRevision_ = -1),
            (this.orientedRevision_ = -1),
            (this.orientedFlatCoordinates_ = null),
            t !== void 0 && n
              ? (this.setFlatCoordinates(t, e), (this.ends_ = n))
              : this.setCoordinates(e, t);
        }
        appendLinearRing(e) {
          this.flatCoordinates
            ? uo(this.flatCoordinates, e.getFlatCoordinates())
            : (this.flatCoordinates = e.getFlatCoordinates().slice()),
            this.ends_.push(this.flatCoordinates.length),
            this.changed();
        }
        clone() {
          const e = new Yt(
            this.flatCoordinates.slice(),
            this.layout,
            this.ends_.slice()
          );
          return e.applyProperties(this), e;
        }
        closestPointXY(e, t, n, r) {
          return r < os(this.getExtent(), e, t)
            ? r
            : (this.maxDeltaRevision_ != this.getRevision() &&
                ((this.maxDelta_ = Math.sqrt(
                  ua(this.flatCoordinates, 0, this.ends_, this.stride, 0)
                )),
                (this.maxDeltaRevision_ = this.getRevision())),
              da(
                this.flatCoordinates,
                0,
                this.ends_,
                this.stride,
                this.maxDelta_,
                !0,
                e,
                t,
                n,
                r
              ));
        }
        containsXY(e, t) {
          return vs(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            e,
            t
          );
        }
        getArea() {
          return Ea(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride
          );
        }
        getCoordinates(e) {
          let t;
          return (
            e !== void 0
              ? ((t = this.getOrientedFlatCoordinates().slice()),
                Rr(t, 0, this.ends_, this.stride, e))
              : (t = this.flatCoordinates),
            ya(t, 0, this.ends_, this.stride)
          );
        }
        getEnds() {
          return this.ends_;
        }
        getFlatInteriorPoint() {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const e = vt(this.getExtent());
            (this.flatInteriorPoint_ = va(
              this.getOrientedFlatCoordinates(),
              0,
              this.ends_,
              this.stride,
              e,
              0
            )),
              (this.flatInteriorPointRevision_ = this.getRevision());
          }
          return this.flatInteriorPoint_;
        }
        getInteriorPoint() {
          return new Di(this.getFlatInteriorPoint(), "XYM");
        }
        getLinearRingCount() {
          return this.ends_.length;
        }
        getLinearRing(e) {
          return e < 0 || this.ends_.length <= e
            ? null
            : new Xt(
                this.flatCoordinates.slice(
                  e === 0 ? 0 : this.ends_[e - 1],
                  this.ends_[e]
                ),
                this.layout
              );
        }
        getLinearRings() {
          const e = this.layout,
            t = this.flatCoordinates,
            n = this.ends_,
            r = [];
          let s = 0;
          for (let o = 0, a = n.length; o < a; ++o) {
            const l = n[o],
              h = new Xt(t.slice(s, l), e);
            r.push(h), (s = l);
          }
          return r;
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const e = this.flatCoordinates;
            xa(e, 0, this.ends_, this.stride)
              ? (this.orientedFlatCoordinates_ = e)
              : ((this.orientedFlatCoordinates_ = e.slice()),
                (this.orientedFlatCoordinates_.length = Rr(
                  this.orientedFlatCoordinates_,
                  0,
                  this.ends_,
                  this.stride
                ))),
              (this.orientedRevision_ = this.getRevision());
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(e) {
          const t = [],
            n = [];
          return (
            (t.length = pa(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              Math.sqrt(e),
              t,
              0,
              n
            )),
            new Yt(t, "XY", n)
          );
        }
        getType() {
          return "Polygon";
        }
        intersectsExtent(e) {
          return Ca(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            e
          );
        }
        setCoordinates(e, t) {
          this.setLayout(t, e, 2),
            this.flatCoordinates || (this.flatCoordinates = []);
          const n = ga(this.flatCoordinates, 0, e, this.stride, this.ends_);
          (this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1]),
            this.changed();
        }
      }
      function Cr(i) {
        if ($t(i)) throw new Error("Cannot create polygon from empty extent");
        const e = i[0],
          t = i[1],
          n = i[2],
          r = i[3],
          s = [e, t, e, r, n, r, n, t, e, t];
        return new Yt(s, "XY", [s.length]);
      }
      const Ie = {
          PRERENDER: "prerender",
          POSTRENDER: "postrender",
          PRECOMPOSE: "precompose",
          POSTCOMPOSE: "postcompose",
          RENDERCOMPLETE: "rendercomplete",
        },
        O = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 },
        Zt = {
          name: "rgb",
          min: [0, 0, 0],
          max: [255, 255, 255],
          channel: ["red", "green", "blue"],
          alias: ["RGB"],
        };
      var Q = {
        name: "xyz",
        min: [0, 0, 0],
        channel: ["X", "Y", "Z"],
        alias: ["XYZ", "ciexyz", "cie1931"],
      };
      Q.whitepoint = {
        2: {
          A: [109.85, 100, 35.585],
          C: [98.074, 100, 118.232],
          D50: [96.422, 100, 82.521],
          D55: [95.682, 100, 92.149],
          D65: [95.045592705167, 100, 108.9057750759878],
          D75: [94.972, 100, 122.638],
          F2: [99.187, 100, 67.395],
          F7: [95.044, 100, 108.755],
          F11: [100.966, 100, 64.37],
          E: [100, 100, 100],
        },
        10: {
          A: [111.144, 100, 35.2],
          C: [97.285, 100, 116.145],
          D50: [96.72, 100, 81.427],
          D55: [95.799, 100, 90.926],
          D65: [94.811, 100, 107.304],
          D75: [94.416, 100, 120.641],
          F2: [103.28, 100, 69.026],
          F7: [95.792, 100, 107.687],
          F11: [103.866, 100, 65.627],
          E: [100, 100, 100],
        },
      };
      Q.max = Q.whitepoint[2].D65;
      Q.rgb = function (i, e) {
        e = e || Q.whitepoint[2].E;
        var t = i[0] / e[0],
          n = i[1] / e[1],
          r = i[2] / e[2],
          s,
          o,
          a;
        return (
          (s =
            t * 3.240969941904521 +
            n * -1.537383177570093 +
            r * -0.498610760293),
          (o =
            t * -0.96924363628087 +
            n * 1.87596750150772 +
            r * 0.041555057407175),
          (a =
            t * 0.055630079696993 +
            n * -0.20397695888897 +
            r * 1.056971514242878),
          (s =
            s > 0.0031308
              ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055
              : (s = s * 12.92)),
          (o =
            o > 0.0031308
              ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055
              : (o = o * 12.92)),
          (a =
            a > 0.0031308
              ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055
              : (a = a * 12.92)),
          (s = Math.min(Math.max(0, s), 1)),
          (o = Math.min(Math.max(0, o), 1)),
          (a = Math.min(Math.max(0, a), 1)),
          [s * 255, o * 255, a * 255]
        );
      };
      Zt.xyz = function (i, e) {
        var t = i[0] / 255,
          n = i[1] / 255,
          r = i[2] / 255;
        (t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92),
          (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92),
          (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92);
        var s =
            t * 0.41239079926595 + n * 0.35758433938387 + r * 0.18048078840183,
          o =
            t * 0.21263900587151 + n * 0.71516867876775 + r * 0.072192315360733,
          a =
            t * 0.019330818715591 + n * 0.11919477979462 + r * 0.95053215224966;
        return (e = e || Q.whitepoint[2].E), [s * e[0], o * e[1], a * e[2]];
      };
      const Fi = {
        name: "luv",
        min: [0, -134, -140],
        max: [100, 224, 122],
        channel: ["lightness", "u", "v"],
        alias: ["LUV", "cieluv", "cie1976"],
        xyz: function (i, e, t) {
          var n, r, s, o, a, l, h, c, u, d, g, f, _;
          if (((s = i[0]), (o = i[1]), (a = i[2]), s === 0)) return [0, 0, 0];
          var p = 0.0011070564598794539;
          return (
            (e = e || "D65"),
            (t = t || 2),
            (u = Q.whitepoint[t][e][0]),
            (d = Q.whitepoint[t][e][1]),
            (g = Q.whitepoint[t][e][2]),
            (f = (4 * u) / (u + 15 * d + 3 * g)),
            (_ = (9 * d) / (u + 15 * d + 3 * g)),
            (n = o / (13 * s) + f || 0),
            (r = a / (13 * s) + _ || 0),
            (h = s > 8 ? d * Math.pow((s + 16) / 116, 3) : d * s * p),
            (l = (h * 9 * n) / (4 * r) || 0),
            (c = (h * (12 - 3 * n - 20 * r)) / (4 * r) || 0),
            [l, h, c]
          );
        },
      };
      Q.luv = function (i, e, t) {
        var n,
          r,
          s,
          o,
          a,
          l,
          h,
          c,
          u,
          d,
          g,
          f,
          _,
          p = 0.008856451679035631,
          E = 903.2962962962961;
        (e = e || "D65"),
          (t = t || 2),
          (u = Q.whitepoint[t][e][0]),
          (d = Q.whitepoint[t][e][1]),
          (g = Q.whitepoint[t][e][2]),
          (f = (4 * u) / (u + 15 * d + 3 * g)),
          (_ = (9 * d) / (u + 15 * d + 3 * g)),
          (l = i[0]),
          (h = i[1]),
          (c = i[2]),
          (n = (4 * l) / (l + 15 * h + 3 * c) || 0),
          (r = (9 * h) / (l + 15 * h + 3 * c) || 0);
        var y = h / d;
        return (
          (s = y <= p ? E * y : 116 * Math.pow(y, 1 / 3) - 16),
          (o = 13 * s * (n - f)),
          (a = 13 * s * (r - _)),
          [s, o, a]
        );
      };
      var xs = {
        name: "lchuv",
        channel: ["lightness", "chroma", "hue"],
        alias: ["LCHuv", "cielchuv"],
        min: [0, 0, 0],
        max: [100, 100, 360],
        luv: function (i) {
          var e = i[0],
            t = i[1],
            n = i[2],
            r,
            s,
            o;
          return (
            (o = (n / 360) * 2 * Math.PI),
            (r = t * Math.cos(o)),
            (s = t * Math.sin(o)),
            [e, r, s]
          );
        },
        xyz: function (i) {
          return Fi.xyz(xs.luv(i));
        },
      };
      Fi.lchuv = function (i) {
        var e = i[0],
          t = i[1],
          n = i[2],
          r = Math.sqrt(t * t + n * n),
          s = Math.atan2(n, t),
          o = (s * 360) / 2 / Math.PI;
        return o < 0 && (o += 360), [e, r, o];
      };
      Q.lchuv = function (i) {
        return Fi.lchuv(Q.luv(i));
      };
      function Ia(i) {
        return i &&
          i.__esModule &&
          Object.prototype.hasOwnProperty.call(i, "default")
          ? i.default
          : i;
      }
      var Aa = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
      const Tr = Ia(Aa);
      var xr = {
        red: 0,
        orange: 60,
        yellow: 120,
        green: 180,
        blue: 240,
        purple: 300,
      };
      function Ma(i) {
        var c, u;
        var e,
          t = [],
          n = 1,
          r;
        if (typeof i == "number")
          return {
            space: "rgb",
            values: [i >>> 16, (i & 65280) >>> 8, i & 255],
            alpha: 1,
          };
        if (typeof i == "number")
          return {
            space: "rgb",
            values: [i >>> 16, (i & 65280) >>> 8, i & 255],
            alpha: 1,
          };
        if (((i = String(i).toLowerCase()), Tr[i]))
          (t = Tr[i].slice()), (r = "rgb");
        else if (i === "transparent") (n = 0), (r = "rgb"), (t = [0, 0, 0]);
        else if (i[0] === "#") {
          var s = i.slice(1),
            o = s.length,
            a = o <= 4;
          (n = 1),
            a
              ? ((t = [
                  parseInt(s[0] + s[0], 16),
                  parseInt(s[1] + s[1], 16),
                  parseInt(s[2] + s[2], 16),
                ]),
                o === 4 && (n = parseInt(s[3] + s[3], 16) / 255))
              : ((t = [
                  parseInt(s[0] + s[1], 16),
                  parseInt(s[2] + s[3], 16),
                  parseInt(s[4] + s[5], 16),
                ]),
                o === 8 && (n = parseInt(s[6] + s[7], 16) / 255)),
            t[0] || (t[0] = 0),
            t[1] || (t[1] = 0),
            t[2] || (t[2] = 0),
            (r = "rgb");
        } else if (
          (e =
            /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(
              i
            ))
        ) {
          var l = e[1];
          r = l.replace(/a$/, "");
          var h = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
          (t = e[2].trim().split(/\s*[,\/]\s*|\s+/)),
            r === "color" && (r = t.shift()),
            (t = t.map(function (d, g) {
              if (d[d.length - 1] === "%")
                return (
                  (d = parseFloat(d) / 100),
                  g === 3
                    ? d
                    : r === "rgb"
                    ? d * 255
                    : r[0] === "h" || (r[0] === "l" && !g)
                    ? d * 100
                    : r === "lab"
                    ? d * 125
                    : r === "lch"
                    ? g < 2
                      ? d * 150
                      : d * 360
                    : r[0] === "o" && !g
                    ? d
                    : r === "oklab"
                    ? d * 0.4
                    : r === "oklch"
                    ? g < 2
                      ? d * 0.4
                      : d * 360
                    : d
                );
              if (r[g] === "h" || (g === 2 && r[r.length - 1] === "h")) {
                if (xr[d] !== void 0) return xr[d];
                if (d.endsWith("deg")) return parseFloat(d);
                if (d.endsWith("turn")) return parseFloat(d) * 360;
                if (d.endsWith("grad")) return (parseFloat(d) * 360) / 400;
                if (d.endsWith("rad")) return (parseFloat(d) * 180) / Math.PI;
              }
              return d === "none" ? 0 : parseFloat(d);
            })),
            (n = t.length > h ? t.pop() : 1);
        } else
          /[0-9](?:\s|\/|,)/.test(i) &&
            ((t = i.match(/([0-9]+)/g).map(function (d) {
              return parseFloat(d);
            })),
            (r =
              ((u = (c = i.match(/([a-z])/gi)) == null ? void 0 : c.join("")) ==
              null
                ? void 0
                : u.toLowerCase()) || "rgb"));
        return { space: r, values: t, alpha: n };
      }
      const $n = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function (i) {
          var e = i[0] / 360,
            t = i[1] / 100,
            n = i[2] / 100,
            r,
            s,
            o,
            a,
            l,
            h = 0;
          if (t === 0) return (l = n * 255), [l, l, l];
          for (
            s = n < 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - s,
              a = [0, 0, 0];
            h < 3;

          )
            (o = e + (1 / 3) * -(h - 1)),
              o < 0 ? o++ : o > 1 && o--,
              (l =
                6 * o < 1
                  ? r + (s - r) * 6 * o
                  : 2 * o < 1
                  ? s
                  : 3 * o < 2
                  ? r + (s - r) * (2 / 3 - o) * 6
                  : r),
              (a[h++] = l * 255);
          return a;
        },
      };
      Zt.hsl = function (i) {
        var e = i[0] / 255,
          t = i[1] / 255,
          n = i[2] / 255,
          r = Math.min(e, t, n),
          s = Math.max(e, t, n),
          o = s - r,
          a,
          l,
          h;
        return (
          s === r
            ? (a = 0)
            : e === s
            ? (a = (t - n) / o)
            : t === s
            ? (a = 2 + (n - e) / o)
            : n === s && (a = 4 + (e - t) / o),
          (a = Math.min(a * 60, 360)),
          a < 0 && (a += 360),
          (h = (r + s) / 2),
          s === r
            ? (l = 0)
            : h <= 0.5
            ? (l = o / (s + r))
            : (l = o / (2 - s - r)),
          [a, l * 100, h * 100]
        );
      };
      function La(i) {
        Array.isArray(i) && i.raw && (i = String.raw(...arguments)),
          i instanceof Number && (i = +i);
        var e,
          t = Ma(i);
        if (!t.space) return [];
        const n = t.space[0] === "h" ? $n.min : Zt.min,
          r = t.space[0] === "h" ? $n.max : Zt.max;
        return (
          (e = Array(3)),
          (e[0] = Math.min(Math.max(t.values[0], n[0]), r[0])),
          (e[1] = Math.min(Math.max(t.values[1], n[1]), r[1])),
          (e[2] = Math.min(Math.max(t.values[2], n[2]), r[2])),
          t.space[0] === "h" && (e = $n.rgb(e)),
          e.push(Math.min(Math.max(t.alpha, 0), 1)),
          e
        );
      }
      const Ni = [NaN, NaN, NaN, 0];
      function ba(i) {
        return typeof i == "string" ? i : ki(i);
      }
      const Sa = 1024,
        It = {};
      let Jn = 0;
      function Pa(i) {
        if (i.length === 4) return i;
        const e = i.slice();
        return (e[3] = 1), e;
      }
      function Ir(i) {
        const e = Q.lchuv(Zt.xyz(i));
        return (e[3] = i[3]), e;
      }
      function Oa(i) {
        const e = Q.rgb(xs.xyz(i));
        return (e[3] = i[3]), e;
      }
      function zi(i) {
        if (i === "none") return Ni;
        if (It.hasOwnProperty(i)) return It[i];
        if (Jn >= Sa) {
          let t = 0;
          for (const n in It) t++ & 3 || (delete It[n], --Jn);
        }
        const e = La(i);
        if (e.length !== 4)
          throw new Error('failed to parse "' + i + '" as color');
        for (const t of e)
          if (isNaN(t)) throw new Error('failed to parse "' + i + '" as color');
        return Is(e), (It[i] = e), ++Jn, e;
      }
      function Kt(i) {
        return Array.isArray(i) ? i : zi(i);
      }
      function Is(i) {
        return (
          (i[0] = q((i[0] + 0.5) | 0, 0, 255)),
          (i[1] = q((i[1] + 0.5) | 0, 0, 255)),
          (i[2] = q((i[2] + 0.5) | 0, 0, 255)),
          (i[3] = q(i[3], 0, 1)),
          i
        );
      }
      function ki(i) {
        let e = i[0];
        e != (e | 0) && (e = (e + 0.5) | 0);
        let t = i[1];
        t != (t | 0) && (t = (t + 0.5) | 0);
        let n = i[2];
        n != (n | 0) && (n = (n + 0.5) | 0);
        const r = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
        return "rgba(" + e + "," + t + "," + n + "," + r + ")";
      }
      const Ue =
          typeof navigator < "u" && typeof navigator.userAgent < "u"
            ? navigator.userAgent.toLowerCase()
            : "",
        Da = Ue.includes("firefox"),
        Fa = Ue.includes("safari") && !Ue.includes("chrom");
      Fa &&
        (Ue.includes("version/15.4") ||
          /cpu (os|iphone os) 15_4 like mac os x/.test(Ue));
      const Na = Ue.includes("webkit") && !Ue.includes("edge"),
        As = Ue.includes("macintosh"),
        Ms = typeof devicePixelRatio < "u" ? devicePixelRatio : 1,
        za =
          typeof WorkerGlobalScope < "u" &&
          typeof OffscreenCanvas < "u" &&
          self instanceof WorkerGlobalScope,
        Ls = typeof Image < "u" && Image.prototype.decode,
        bs = (function () {
          let i = !1;
          try {
            const e = Object.defineProperty({}, "passive", {
              get: function () {
                i = !0;
              },
            });
            window.addEventListener("_", null, e),
              window.removeEventListener("_", null, e);
          } catch {}
          return i;
        })();
      function ie(i, e, t, n) {
        let r;
        return (
          t && t.length
            ? (r = t.shift())
            : za
            ? (r = new OffscreenCanvas(i || 300, e || 300))
            : (r = document.createElement("canvas")),
          i && (r.width = i),
          e && (r.height = e),
          r.getContext("2d", n)
        );
      }
      let Qn;
      function xn() {
        return Qn || (Qn = ie(1, 1)), Qn;
      }
      function Vt(i) {
        const e = i.canvas;
        (e.width = 1), (e.height = 1), i.clearRect(0, 0, 1, 1);
      }
      function Ar(i, e) {
        const t = e.parentNode;
        t && t.replaceChild(i, e);
      }
      function ka(i) {
        for (; i.lastChild; ) i.lastChild.remove();
      }
      function Ga(i, e) {
        const t = i.childNodes;
        for (let n = 0; ; ++n) {
          const r = t[n],
            s = e[n];
          if (!r && !s) break;
          if (r !== s) {
            if (!r) {
              i.appendChild(s);
              continue;
            }
            if (!s) {
              i.removeChild(r), --n;
              continue;
            }
            i.insertBefore(s, r);
          }
        }
      }
      function Xa(i, e, t) {
        const n = i;
        let r = !0,
          s = !1,
          o = !1;
        const a = [
          Rn(n, b.LOAD, function () {
            (o = !0), s || e();
          }),
        ];
        return (
          n.src && Ls
            ? ((s = !0),
              n
                .decode()
                .then(function () {
                  r && e();
                })
                .catch(function (l) {
                  r && (o ? e() : t());
                }))
            : a.push(Rn(n, b.ERROR, t)),
          function () {
            (r = !1), a.forEach(V);
          }
        );
      }
      function Ya(i, e) {
        return new Promise((t, n) => {
          function r() {
            o(), t(i);
          }
          function s() {
            o(), n(new Error("Image load error"));
          }
          function o() {
            i.removeEventListener("load", r), i.removeEventListener("error", s);
          }
          i.addEventListener("load", r), i.addEventListener("error", s);
        });
      }
      function Za(i, e) {
        return (
          e && (i.src = e),
          i.src && Ls
            ? new Promise((t, n) =>
                i
                  .decode()
                  .then(() => t(i))
                  .catch((r) => (i.complete && i.width ? t(i) : n(r)))
              )
            : Ya(i)
        );
      }
      class Ka {
        constructor() {
          (this.cache_ = {}),
            (this.patternCache_ = {}),
            (this.cacheSize_ = 0),
            (this.maxCacheSize_ = 32);
        }
        clear() {
          (this.cache_ = {}), (this.patternCache_ = {}), (this.cacheSize_ = 0);
        }
        canExpireCache() {
          return this.cacheSize_ > this.maxCacheSize_;
        }
        expire() {
          if (this.canExpireCache()) {
            let e = 0;
            for (const t in this.cache_) {
              const n = this.cache_[t];
              !(e++ & 3) &&
                !n.hasListener() &&
                (delete this.cache_[t],
                delete this.patternCache_[t],
                --this.cacheSize_);
            }
          }
        }
        get(e, t, n) {
          const r = ei(e, t, n);
          return r in this.cache_ ? this.cache_[r] : null;
        }
        getPattern(e, t, n) {
          const r = ei(e, t, n);
          return r in this.patternCache_ ? this.patternCache_[r] : null;
        }
        set(e, t, n, r, s) {
          const o = ei(e, t, n),
            a = o in this.cache_;
          (this.cache_[o] = r),
            s &&
              (r.getImageState() === O.IDLE && r.load(),
              r.getImageState() === O.LOADING
                ? r.ready().then(() => {
                    this.patternCache_[o] = xn().createPattern(
                      r.getImage(1),
                      "repeat"
                    );
                  })
                : (this.patternCache_[o] = xn().createPattern(
                    r.getImage(1),
                    "repeat"
                  ))),
            a || ++this.cacheSize_;
        }
        setSize(e) {
          (this.maxCacheSize_ = e), this.expire();
        }
      }
      function ei(i, e, t) {
        const n = t ? Kt(t) : "null";
        return e + ":" + i + ":" + n;
      }
      const Ae = new Ka();
      let At = null;
      class Va extends Nn {
        constructor(e, t, n, r, s) {
          super(),
            (this.hitDetectionImage_ = null),
            (this.image_ = e),
            (this.crossOrigin_ = n),
            (this.canvas_ = {}),
            (this.color_ = s),
            (this.imageState_ = r === void 0 ? O.IDLE : r),
            (this.size_ =
              e && e.width && e.height ? [e.width, e.height] : null),
            (this.src_ = t),
            this.tainted_,
            (this.ready_ = null);
        }
        initializeImage_() {
          (this.image_ = new Image()),
            this.crossOrigin_ !== null &&
              (this.image_.crossOrigin = this.crossOrigin_);
        }
        isTainted_() {
          if (this.tainted_ === void 0 && this.imageState_ === O.LOADED) {
            At || (At = ie(1, 1, void 0, { willReadFrequently: !0 })),
              At.drawImage(this.image_, 0, 0);
            try {
              At.getImageData(0, 0, 1, 1), (this.tainted_ = !1);
            } catch {
              (At = null), (this.tainted_ = !0);
            }
          }
          return this.tainted_ === !0;
        }
        dispatchChangeEvent_() {
          this.dispatchEvent(b.CHANGE);
        }
        handleImageError_() {
          (this.imageState_ = O.ERROR), this.dispatchChangeEvent_();
        }
        handleImageLoad_() {
          (this.imageState_ = O.LOADED),
            (this.size_ = [this.image_.width, this.image_.height]),
            this.dispatchChangeEvent_();
        }
        getImage(e) {
          return (
            this.image_ || this.initializeImage_(),
            this.replaceColor_(e),
            this.canvas_[e] ? this.canvas_[e] : this.image_
          );
        }
        getPixelRatio(e) {
          return this.replaceColor_(e), this.canvas_[e] ? e : 1;
        }
        getImageState() {
          return this.imageState_;
        }
        getHitDetectionImage() {
          if (
            (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
          )
            if (this.isTainted_()) {
              const e = this.size_[0],
                t = this.size_[1],
                n = ie(e, t);
              n.fillRect(0, 0, e, t), (this.hitDetectionImage_ = n.canvas);
            } else this.hitDetectionImage_ = this.image_;
          return this.hitDetectionImage_;
        }
        getSize() {
          return this.size_;
        }
        getSrc() {
          return this.src_;
        }
        load() {
          if (this.imageState_ === O.IDLE) {
            this.image_ || this.initializeImage_(),
              (this.imageState_ = O.LOADING);
            try {
              this.src_ !== void 0 && (this.image_.src = this.src_);
            } catch {
              this.handleImageError_();
            }
            this.image_ instanceof HTMLImageElement &&
              Za(this.image_, this.src_)
                .then((e) => {
                  (this.image_ = e), this.handleImageLoad_();
                })
                .catch(this.handleImageError_.bind(this));
          }
        }
        replaceColor_(e) {
          if (!this.color_ || this.canvas_[e] || this.imageState_ !== O.LOADED)
            return;
          const t = this.image_,
            n = ie(Math.ceil(t.width * e), Math.ceil(t.height * e)),
            r = n.canvas;
          n.scale(e, e),
            n.drawImage(t, 0, 0),
            (n.globalCompositeOperation = "multiply"),
            (n.fillStyle = ba(this.color_)),
            n.fillRect(0, 0, r.width / e, r.height / e),
            (n.globalCompositeOperation = "destination-in"),
            n.drawImage(t, 0, 0),
            (this.canvas_[e] = r);
        }
        ready() {
          return (
            this.ready_ ||
              (this.ready_ = new Promise((e) => {
                if (
                  this.imageState_ === O.LOADED ||
                  this.imageState_ === O.ERROR
                )
                  e();
                else {
                  const t = () => {
                    (this.imageState_ === O.LOADED ||
                      this.imageState_ === O.ERROR) &&
                      (this.removeEventListener(b.CHANGE, t), e());
                  };
                  this.addEventListener(b.CHANGE, t);
                }
              })),
            this.ready_
          );
        }
      }
      function Gi(i, e, t, n, r, s) {
        let o = e === void 0 ? void 0 : Ae.get(e, t, r);
        return (
          o ||
            ((o = new Va(i, i && "src" in i ? i.src || void 0 : e, t, n, r)),
            Ae.set(e, t, r, o, s)),
          s && o && !Ae.getPattern(e, t, r) && Ae.set(e, t, r, o, s),
          o
        );
      }
      class Qt {
        constructor(e) {
          (e = e || {}),
            (this.patternImage_ = null),
            (this.color_ = null),
            e.color !== void 0 && this.setColor(e.color);
        }
        clone() {
          const e = this.getColor();
          return new Qt({ color: Array.isArray(e) ? e.slice() : e || void 0 });
        }
        getColor() {
          return this.color_;
        }
        setColor(e) {
          if (e !== null && typeof e == "object" && "src" in e) {
            const t = Gi(
              null,
              e.src,
              "anonymous",
              void 0,
              e.offset ? null : e.color ? e.color : null,
              !(e.offset && e.size)
            );
            t.ready().then(() => {
              this.patternImage_ = null;
            }),
              t.getImageState() === O.IDLE && t.load(),
              t.getImageState() === O.LOADING && (this.patternImage_ = t);
          }
          this.color_ = e;
        }
        loading() {
          return !!this.patternImage_;
        }
        ready() {
          return this.patternImage_
            ? this.patternImage_.ready()
            : Promise.resolve();
        }
      }
      class Xn {
        constructor(e) {
          (e = e || {}),
            (this.color_ = e.color !== void 0 ? e.color : null),
            (this.lineCap_ = e.lineCap),
            (this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null),
            (this.lineDashOffset_ = e.lineDashOffset),
            (this.lineJoin_ = e.lineJoin),
            (this.miterLimit_ = e.miterLimit),
            (this.width_ = e.width);
        }
        clone() {
          const e = this.getColor();
          return new Xn({
            color: Array.isArray(e) ? e.slice() : e || void 0,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth(),
          });
        }
        getColor() {
          return this.color_;
        }
        getLineCap() {
          return this.lineCap_;
        }
        getLineDash() {
          return this.lineDash_;
        }
        getLineDashOffset() {
          return this.lineDashOffset_;
        }
        getLineJoin() {
          return this.lineJoin_;
        }
        getMiterLimit() {
          return this.miterLimit_;
        }
        getWidth() {
          return this.width_;
        }
        setColor(e) {
          this.color_ = e;
        }
        setLineCap(e) {
          this.lineCap_ = e;
        }
        setLineDash(e) {
          this.lineDash_ = e;
        }
        setLineDashOffset(e) {
          this.lineDashOffset_ = e;
        }
        setLineJoin(e) {
          this.lineJoin_ = e;
        }
        setMiterLimit(e) {
          this.miterLimit_ = e;
        }
        setWidth(e) {
          this.width_ = e;
        }
      }
      function Mr(i) {
        return i[0] > 0 && i[1] > 0;
      }
      function Wa(i, e, t) {
        return (
          t === void 0 && (t = [0, 0]),
          (t[0] = (i[0] * e + 0.5) | 0),
          (t[1] = (i[1] * e + 0.5) | 0),
          t
        );
      }
      function ce(i, e) {
        return Array.isArray(i)
          ? i
          : (e === void 0 ? (e = [i, i]) : ((e[0] = i), (e[1] = i)), e);
      }
      class Yn {
        constructor(e) {
          (this.opacity_ = e.opacity),
            (this.rotateWithView_ = e.rotateWithView),
            (this.rotation_ = e.rotation),
            (this.scale_ = e.scale),
            (this.scaleArray_ = ce(e.scale)),
            (this.displacement_ = e.displacement),
            (this.declutterMode_ = e.declutterMode);
        }
        clone() {
          const e = this.getScale();
          return new Yn({
            opacity: this.getOpacity(),
            scale: Array.isArray(e) ? e.slice() : e,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode(),
          });
        }
        getOpacity() {
          return this.opacity_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getDisplacement() {
          return this.displacement_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        getAnchor() {
          return D();
        }
        getImage(e) {
          return D();
        }
        getHitDetectionImage() {
          return D();
        }
        getPixelRatio(e) {
          return 1;
        }
        getImageState() {
          return D();
        }
        getImageSize() {
          return D();
        }
        getOrigin() {
          return D();
        }
        getSize() {
          return D();
        }
        setDisplacement(e) {
          this.displacement_ = e;
        }
        setOpacity(e) {
          this.opacity_ = e;
        }
        setRotateWithView(e) {
          this.rotateWithView_ = e;
        }
        setRotation(e) {
          this.rotation_ = e;
        }
        setScale(e) {
          (this.scale_ = e), (this.scaleArray_ = ce(e));
        }
        listenImageChange(e) {
          D();
        }
        load() {
          D();
        }
        unlistenImageChange(e) {
          D();
        }
        ready() {
          return Promise.resolve();
        }
      }
      function Lr(i) {
        return i
          ? Array.isArray(i)
            ? ki(i)
            : typeof i == "object" && "src" in i
            ? Ua(i)
            : i
          : null;
      }
      function Ua(i) {
        if (!i.offset || !i.size)
          return Ae.getPattern(i.src, "anonymous", i.color);
        const e = i.src + ":" + i.offset,
          t = Ae.getPattern(e, void 0, i.color);
        if (t) return t;
        const n = Ae.get(i.src, "anonymous", null);
        if (n.getImageState() !== O.LOADED) return null;
        const r = ie(i.size[0], i.size[1]);
        return (
          r.drawImage(
            n.getImage(1),
            i.offset[0],
            i.offset[1],
            i.size[0],
            i.size[1],
            0,
            0,
            i.size[0],
            i.size[1]
          ),
          Gi(r.canvas, e, void 0, O.LOADED, i.color, !0),
          Ae.getPattern(e, void 0, i.color)
        );
      }
      const un = "ol-hidden",
        Zn = "ol-unselectable",
        Xi = "ol-control",
        br = "ol-collapsed",
        Sr = "#000",
        Pr = "round",
        Or = "round",
        ja = 10,
        Ba = "#000",
        Ha = 1,
        qa = new De();
      class Kn extends Yn {
        constructor(e) {
          super({
            opacity: 1,
            rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
            rotation: e.rotation !== void 0 ? e.rotation : 0,
            scale: e.scale !== void 0 ? e.scale : 1,
            displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
            declutterMode: e.declutterMode,
          }),
            this.canvases_,
            (this.hitDetectionCanvas_ = null),
            (this.fill_ = e.fill !== void 0 ? e.fill : null),
            (this.origin_ = [0, 0]),
            (this.points_ = e.points),
            (this.radius = e.radius),
            (this.radius2_ = e.radius2),
            (this.angle_ = e.angle !== void 0 ? e.angle : 0),
            (this.stroke_ = e.stroke !== void 0 ? e.stroke : null),
            this.size_,
            this.renderOptions_,
            (this.imageState_ =
              this.fill_ && this.fill_.loading() ? O.LOADING : O.LOADED),
            this.imageState_ === O.LOADING &&
              this.ready().then(() => (this.imageState_ = O.LOADED)),
            this.render();
        }
        clone() {
          const e = this.getScale(),
            t = new Kn({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              scale: Array.isArray(e) ? e.slice() : e,
              displacement: this.getDisplacement().slice(),
              declutterMode: this.getDeclutterMode(),
            });
          return t.setOpacity(this.getOpacity()), t;
        }
        getAnchor() {
          const e = this.size_,
            t = this.getDisplacement(),
            n = this.getScaleArray();
          return [e[0] / 2 - t[0] / n[0], e[1] / 2 + t[1] / n[1]];
        }
        getAngle() {
          return this.angle_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(e) {
          (this.fill_ = e), this.render();
        }
        getHitDetectionImage() {
          return (
            this.hitDetectionCanvas_ ||
              (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
                this.renderOptions_
              )),
            this.hitDetectionCanvas_
          );
        }
        getImage(e) {
          let t = this.canvases_[e];
          if (!t) {
            const n = this.renderOptions_,
              r = ie(n.size * e, n.size * e);
            this.draw_(n, r, e), (t = r.canvas), (this.canvases_[e] = t);
          }
          return t;
        }
        getPixelRatio(e) {
          return e;
        }
        getImageSize() {
          return this.size_;
        }
        getImageState() {
          return this.imageState_;
        }
        getOrigin() {
          return this.origin_;
        }
        getPoints() {
          return this.points_;
        }
        getRadius() {
          return this.radius;
        }
        getRadius2() {
          return this.radius2_;
        }
        getSize() {
          return this.size_;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(e) {
          (this.stroke_ = e), this.render();
        }
        listenImageChange(e) {}
        load() {}
        unlistenImageChange(e) {}
        calculateLineJoinSize_(e, t, n) {
          if (
            t === 0 ||
            this.points_ === 1 / 0 ||
            (e !== "bevel" && e !== "miter")
          )
            return t;
          let r = this.radius,
            s = this.radius2_ === void 0 ? r : this.radius2_;
          if (r < s) {
            const A = r;
            (r = s), (s = A);
          }
          const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2,
            a = (2 * Math.PI) / o,
            l = s * Math.sin(a),
            h = Math.sqrt(s * s - l * l),
            c = r - h,
            u = Math.sqrt(l * l + c * c),
            d = u / l;
          if (e === "miter" && d <= n) return d * t;
          const g = t / 2 / d,
            f = (t / 2) * (c / u),
            p = Math.sqrt((r + g) * (r + g) + f * f) - r;
          if (this.radius2_ === void 0 || e === "bevel") return p * 2;
          const E = r * Math.sin(a),
            y = Math.sqrt(r * r - E * E),
            R = s - y,
            w = Math.sqrt(E * E + R * R) / E;
          if (w <= n) {
            const A = (w * t) / 2 - s - r;
            return 2 * Math.max(p, A);
          }
          return p * 2;
        }
        createRenderOptions() {
          let e = Pr,
            t = Or,
            n = 0,
            r = null,
            s = 0,
            o,
            a = 0;
          this.stroke_ &&
            ((o = Lr(this.stroke_.getColor() ?? Ba)),
            (a = this.stroke_.getWidth() ?? Ha),
            (r = this.stroke_.getLineDash()),
            (s = this.stroke_.getLineDashOffset() ?? 0),
            (t = this.stroke_.getLineJoin() ?? Or),
            (e = this.stroke_.getLineCap() ?? Pr),
            (n = this.stroke_.getMiterLimit() ?? ja));
          const l = this.calculateLineJoinSize_(t, a, n),
            h = Math.max(this.radius, this.radius2_ || 0),
            c = Math.ceil(2 * h + l);
          return {
            strokeStyle: o,
            strokeWidth: a,
            size: c,
            lineCap: e,
            lineDash: r,
            lineDashOffset: s,
            lineJoin: t,
            miterLimit: n,
          };
        }
        render() {
          this.renderOptions_ = this.createRenderOptions();
          const e = this.renderOptions_.size;
          (this.canvases_ = {}),
            (this.hitDetectionCanvas_ = null),
            (this.size_ = [e, e]);
        }
        draw_(e, t, n) {
          if (
            (t.scale(n, n),
            t.translate(e.size / 2, e.size / 2),
            this.createPath_(t),
            this.fill_)
          ) {
            let r = this.fill_.getColor();
            r === null && (r = Sr), (t.fillStyle = Lr(r)), t.fill();
          }
          e.strokeStyle &&
            ((t.strokeStyle = e.strokeStyle),
            (t.lineWidth = e.strokeWidth),
            e.lineDash &&
              (t.setLineDash(e.lineDash),
              (t.lineDashOffset = e.lineDashOffset)),
            (t.lineCap = e.lineCap),
            (t.lineJoin = e.lineJoin),
            (t.miterLimit = e.miterLimit),
            t.stroke());
        }
        createHitDetectionCanvas_(e) {
          let t;
          if (this.fill_) {
            let n = this.fill_.getColor(),
              r = 0;
            typeof n == "string" && (n = Kt(n)),
              n === null
                ? (r = 1)
                : Array.isArray(n) && (r = n.length === 4 ? n[3] : 1),
              r === 0 &&
                ((t = ie(e.size, e.size)), this.drawHitDetectionCanvas_(e, t));
          }
          return t ? t.canvas : this.getImage(1);
        }
        createPath_(e) {
          let t = this.points_;
          const n = this.radius;
          if (t === 1 / 0) e.arc(0, 0, n, 0, 2 * Math.PI);
          else {
            const r = this.radius2_ === void 0 ? n : this.radius2_;
            this.radius2_ !== void 0 && (t *= 2);
            const s = this.angle_ - Math.PI / 2,
              o = (2 * Math.PI) / t;
            for (let a = 0; a < t; a++) {
              const l = s + a * o,
                h = a % 2 === 0 ? n : r;
              e.lineTo(h * Math.cos(l), h * Math.sin(l));
            }
            e.closePath();
          }
        }
        drawHitDetectionCanvas_(e, t) {
          t.translate(e.size / 2, e.size / 2),
            this.createPath_(t),
            (t.fillStyle = Sr),
            t.fill(),
            e.strokeStyle &&
              ((t.strokeStyle = e.strokeStyle),
              (t.lineWidth = e.strokeWidth),
              e.lineDash &&
                (t.setLineDash(e.lineDash),
                (t.lineDashOffset = e.lineDashOffset)),
              (t.lineJoin = e.lineJoin),
              (t.miterLimit = e.miterLimit),
              t.stroke());
        }
        ready() {
          return this.fill_ ? this.fill_.ready() : Promise.resolve();
        }
      }
      class Vn extends Kn {
        constructor(e) {
          (e = e || { radius: 5 }),
            super({
              points: 1 / 0,
              fill: e.fill,
              radius: e.radius,
              stroke: e.stroke,
              scale: e.scale !== void 0 ? e.scale : 1,
              rotation: e.rotation !== void 0 ? e.rotation : 0,
              rotateWithView:
                e.rotateWithView !== void 0 ? e.rotateWithView : !1,
              displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
              declutterMode: e.declutterMode,
            });
        }
        clone() {
          const e = this.getScale(),
            t = new Vn({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              radius: this.getRadius(),
              scale: Array.isArray(e) ? e.slice() : e,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
              declutterMode: this.getDeclutterMode(),
            });
          return t.setOpacity(this.getOpacity()), t;
        }
        setRadius(e) {
          (this.radius = e), this.render();
        }
      }
      class Wn {
        constructor(e) {
          (e = e || {}),
            (this.geometry_ = null),
            (this.geometryFunction_ = Dr),
            e.geometry !== void 0 && this.setGeometry(e.geometry),
            (this.fill_ = e.fill !== void 0 ? e.fill : null),
            (this.image_ = e.image !== void 0 ? e.image : null),
            (this.renderer_ = e.renderer !== void 0 ? e.renderer : null),
            (this.hitDetectionRenderer_ =
              e.hitDetectionRenderer !== void 0
                ? e.hitDetectionRenderer
                : null),
            (this.stroke_ = e.stroke !== void 0 ? e.stroke : null),
            (this.text_ = e.text !== void 0 ? e.text : null),
            (this.zIndex_ = e.zIndex);
        }
        clone() {
          let e = this.getGeometry();
          return (
            e && typeof e == "object" && (e = e.clone()),
            new Wn({
              geometry: e ?? void 0,
              fill: this.getFill() ? this.getFill().clone() : void 0,
              image: this.getImage() ? this.getImage().clone() : void 0,
              renderer: this.getRenderer() ?? void 0,
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              text: this.getText() ? this.getText().clone() : void 0,
              zIndex: this.getZIndex(),
            })
          );
        }
        getRenderer() {
          return this.renderer_;
        }
        setRenderer(e) {
          this.renderer_ = e;
        }
        setHitDetectionRenderer(e) {
          this.hitDetectionRenderer_ = e;
        }
        getHitDetectionRenderer() {
          return this.hitDetectionRenderer_;
        }
        getGeometry() {
          return this.geometry_;
        }
        getGeometryFunction() {
          return this.geometryFunction_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(e) {
          this.fill_ = e;
        }
        getImage() {
          return this.image_;
        }
        setImage(e) {
          this.image_ = e;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(e) {
          this.stroke_ = e;
        }
        getText() {
          return this.text_;
        }
        setText(e) {
          this.text_ = e;
        }
        getZIndex() {
          return this.zIndex_;
        }
        setGeometry(e) {
          typeof e == "function"
            ? (this.geometryFunction_ = e)
            : typeof e == "string"
            ? (this.geometryFunction_ = function (t) {
                return t.get(e);
              })
            : e
            ? e !== void 0 &&
              (this.geometryFunction_ = function () {
                return e;
              })
            : (this.geometryFunction_ = Dr),
            (this.geometry_ = e);
        }
        setZIndex(e) {
          this.zIndex_ = e;
        }
      }
      function $a(i) {
        let e;
        if (typeof i == "function") e = i;
        else {
          let t;
          Array.isArray(i)
            ? (t = i)
            : (G(
                typeof i.getZIndex == "function",
                "Expected an `Style` or an array of `Style`"
              ),
              (t = [i])),
            (e = function () {
              return t;
            });
        }
        return e;
      }
      let ti = null;
      function Ss(i, e) {
        if (!ti) {
          const t = new Qt({ color: "rgba(255,255,255,0.4)" }),
            n = new Xn({ color: "#3399CC", width: 1.25 });
          ti = [
            new Wn({
              image: new Vn({ fill: t, stroke: n, radius: 5 }),
              fill: t,
              stroke: n,
            }),
          ];
        }
        return ti;
      }
      function Dr(i) {
        return i.getGeometry();
      }
      const En = Wn,
        Ja = "#333";
      class Yi {
        constructor(e) {
          (e = e || {}),
            (this.font_ = e.font),
            (this.rotation_ = e.rotation),
            (this.rotateWithView_ = e.rotateWithView),
            (this.scale_ = e.scale),
            (this.scaleArray_ = ce(e.scale !== void 0 ? e.scale : 1)),
            (this.text_ = e.text),
            (this.textAlign_ = e.textAlign),
            (this.justify_ = e.justify),
            (this.repeat_ = e.repeat),
            (this.textBaseline_ = e.textBaseline),
            (this.fill_ = e.fill !== void 0 ? e.fill : new Qt({ color: Ja })),
            (this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4),
            (this.placement_ = e.placement !== void 0 ? e.placement : "point"),
            (this.overflow_ = !!e.overflow),
            (this.stroke_ = e.stroke !== void 0 ? e.stroke : null),
            (this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0),
            (this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0),
            (this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null),
            (this.backgroundStroke_ = e.backgroundStroke
              ? e.backgroundStroke
              : null),
            (this.padding_ = e.padding === void 0 ? null : e.padding),
            (this.declutterMode_ = e.declutterMode);
        }
        clone() {
          const e = this.getScale();
          return new Yi({
            font: this.getFont(),
            placement: this.getPlacement(),
            repeat: this.getRepeat(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(e) ? e.slice() : e,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            justify: this.getJustify(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : void 0,
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill()
              ? this.getBackgroundFill().clone()
              : void 0,
            backgroundStroke: this.getBackgroundStroke()
              ? this.getBackgroundStroke().clone()
              : void 0,
            padding: this.getPadding() || void 0,
            declutterMode: this.getDeclutterMode(),
          });
        }
        getOverflow() {
          return this.overflow_;
        }
        getFont() {
          return this.font_;
        }
        getMaxAngle() {
          return this.maxAngle_;
        }
        getPlacement() {
          return this.placement_;
        }
        getRepeat() {
          return this.repeat_;
        }
        getOffsetX() {
          return this.offsetX_;
        }
        getOffsetY() {
          return this.offsetY_;
        }
        getFill() {
          return this.fill_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getStroke() {
          return this.stroke_;
        }
        getText() {
          return this.text_;
        }
        getTextAlign() {
          return this.textAlign_;
        }
        getJustify() {
          return this.justify_;
        }
        getTextBaseline() {
          return this.textBaseline_;
        }
        getBackgroundFill() {
          return this.backgroundFill_;
        }
        getBackgroundStroke() {
          return this.backgroundStroke_;
        }
        getPadding() {
          return this.padding_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        setOverflow(e) {
          this.overflow_ = e;
        }
        setFont(e) {
          this.font_ = e;
        }
        setMaxAngle(e) {
          this.maxAngle_ = e;
        }
        setOffsetX(e) {
          this.offsetX_ = e;
        }
        setOffsetY(e) {
          this.offsetY_ = e;
        }
        setPlacement(e) {
          this.placement_ = e;
        }
        setRepeat(e) {
          this.repeat_ = e;
        }
        setRotateWithView(e) {
          this.rotateWithView_ = e;
        }
        setFill(e) {
          this.fill_ = e;
        }
        setRotation(e) {
          this.rotation_ = e;
        }
        setScale(e) {
          (this.scale_ = e), (this.scaleArray_ = ce(e !== void 0 ? e : 1));
        }
        setStroke(e) {
          this.stroke_ = e;
        }
        setText(e) {
          this.text_ = e;
        }
        setTextAlign(e) {
          this.textAlign_ = e;
        }
        setJustify(e) {
          this.justify_ = e;
        }
        setTextBaseline(e) {
          this.textBaseline_ = e;
        }
        setBackgroundFill(e) {
          this.backgroundFill_ = e;
        }
        setBackgroundStroke(e) {
          this.backgroundStroke_ = e;
        }
        setPadding(e) {
          this.padding_ = e;
        }
      }
      const z = {
        OPACITY: "opacity",
        VISIBLE: "visible",
        EXTENT: "extent",
        Z_INDEX: "zIndex",
        MAX_RESOLUTION: "maxResolution",
        MIN_RESOLUTION: "minResolution",
        MAX_ZOOM: "maxZoom",
        MIN_ZOOM: "minZoom",
        SOURCE: "source",
        MAP: "map",
      };
      class Ps extends De {
        constructor(e) {
          super(),
            this.on,
            this.once,
            this.un,
            (this.background_ = e.background);
          const t = Object.assign({}, e);
          typeof e.properties == "object" &&
            (delete t.properties, Object.assign(t, e.properties)),
            (t[z.OPACITY] = e.opacity !== void 0 ? e.opacity : 1),
            G(
              typeof t[z.OPACITY] == "number",
              "Layer opacity must be a number"
            ),
            (t[z.VISIBLE] = e.visible !== void 0 ? e.visible : !0),
            (t[z.Z_INDEX] = e.zIndex),
            (t[z.MAX_RESOLUTION] =
              e.maxResolution !== void 0 ? e.maxResolution : 1 / 0),
            (t[z.MIN_RESOLUTION] =
              e.minResolution !== void 0 ? e.minResolution : 0),
            (t[z.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0),
            (t[z.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0),
            (this.className_ =
              t.className !== void 0 ? t.className : "ol-layer"),
            delete t.className,
            this.setProperties(t),
            (this.state_ = null);
        }
        getBackground() {
          return this.background_;
        }
        getClassName() {
          return this.className_;
        }
        getLayerState(e) {
          const t = this.state_ || {
              layer: this,
              managed: e === void 0 ? !0 : e,
            },
            n = this.getZIndex();
          return (
            (t.opacity = q(Math.round(this.getOpacity() * 100) / 100, 0, 1)),
            (t.visible = this.getVisible()),
            (t.extent = this.getExtent()),
            (t.zIndex = n === void 0 && !t.managed ? 1 / 0 : n),
            (t.maxResolution = this.getMaxResolution()),
            (t.minResolution = Math.max(this.getMinResolution(), 0)),
            (t.minZoom = this.getMinZoom()),
            (t.maxZoom = this.getMaxZoom()),
            (this.state_ = t),
            t
          );
        }
        getLayersArray(e) {
          return D();
        }
        getLayerStatesArray(e) {
          return D();
        }
        getExtent() {
          return this.get(z.EXTENT);
        }
        getMaxResolution() {
          return this.get(z.MAX_RESOLUTION);
        }
        getMinResolution() {
          return this.get(z.MIN_RESOLUTION);
        }
        getMinZoom() {
          return this.get(z.MIN_ZOOM);
        }
        getMaxZoom() {
          return this.get(z.MAX_ZOOM);
        }
        getOpacity() {
          return this.get(z.OPACITY);
        }
        getSourceState() {
          return D();
        }
        getVisible() {
          return this.get(z.VISIBLE);
        }
        getZIndex() {
          return this.get(z.Z_INDEX);
        }
        setBackground(e) {
          (this.background_ = e), this.changed();
        }
        setExtent(e) {
          this.set(z.EXTENT, e);
        }
        setMaxResolution(e) {
          this.set(z.MAX_RESOLUTION, e);
        }
        setMinResolution(e) {
          this.set(z.MIN_RESOLUTION, e);
        }
        setMaxZoom(e) {
          this.set(z.MAX_ZOOM, e);
        }
        setMinZoom(e) {
          this.set(z.MIN_ZOOM, e);
        }
        setOpacity(e) {
          G(typeof e == "number", "Layer opacity must be a number"),
            this.set(z.OPACITY, e);
        }
        setVisible(e) {
          this.set(z.VISIBLE, e);
        }
        setZIndex(e) {
          this.set(z.Z_INDEX, e);
        }
        disposeInternal() {
          this.state_ && ((this.state_.layer = null), (this.state_ = null)),
            super.disposeInternal();
        }
      }
      const _e = { ANIMATING: 0, INTERACTING: 1 },
        we = {
          CENTER: "center",
          RESOLUTION: "resolution",
          ROTATION: "rotation",
        },
        Qa = 42,
        Zi = 256;
      function Fr(i, e, t) {
        return function (n, r, s, o, a) {
          if (!n) return;
          if (!r && !e) return n;
          const l = e ? 0 : s[0] * r,
            h = e ? 0 : s[1] * r,
            c = a ? a[0] : 0,
            u = a ? a[1] : 0;
          let d = i[0] + l / 2 + c,
            g = i[2] - l / 2 + c,
            f = i[1] + h / 2 + u,
            _ = i[3] - h / 2 + u;
          d > g && ((d = (g + d) / 2), (g = d)),
            f > _ && ((f = (_ + f) / 2), (_ = f));
          let p = q(n[0], d, g),
            E = q(n[1], f, _);
          if (o && t && r) {
            const y = 30 * r;
            (p +=
              -y * Math.log(1 + Math.max(0, d - n[0]) / y) +
              y * Math.log(1 + Math.max(0, n[0] - g) / y)),
              (E +=
                -y * Math.log(1 + Math.max(0, f - n[1]) / y) +
                y * Math.log(1 + Math.max(0, n[1] - _) / y));
          }
          return [p, E];
        };
      }
      function el(i) {
        return i;
      }
      function Ki(i, e, t, n) {
        const r = X(e) / t[0],
          s = de(e) / t[1];
        return n ? Math.min(i, Math.max(r, s)) : Math.min(i, Math.min(r, s));
      }
      function Vi(i, e, t) {
        let n = Math.min(i, e);
        const r = 50;
        return (
          (n *= Math.log(1 + r * Math.max(0, i / e - 1)) / r + 1),
          t &&
            ((n = Math.max(n, t)),
            (n /= Math.log(1 + r * Math.max(0, t / i - 1)) / r + 1)),
          q(n, t / 2, e * 2)
        );
      }
      function tl(i, e, t, n) {
        return (
          (e = e !== void 0 ? e : !0),
          function (r, s, o, a) {
            if (r !== void 0) {
              const l = i[0],
                h = i[i.length - 1],
                c = t ? Ki(l, t, o, n) : l;
              if (a) return e ? Vi(r, c, h) : q(r, h, c);
              const u = Math.min(c, r),
                d = Math.floor(xi(i, u, s));
              return i[d] > c && d < i.length - 1 ? i[d + 1] : i[d];
            }
          }
        );
      }
      function nl(i, e, t, n, r, s) {
        return (
          (n = n !== void 0 ? n : !0),
          (t = t !== void 0 ? t : 0),
          function (o, a, l, h) {
            if (o !== void 0) {
              const c = r ? Ki(e, r, l, s) : e;
              if (h) return n ? Vi(o, c, t) : q(o, t, c);
              const u = 1e-9,
                d = Math.ceil(Math.log(e / c) / Math.log(i) - u),
                g = -a * (0.5 - u) + 0.5,
                f = Math.min(c, o),
                _ = Math.floor(Math.log(e / f) / Math.log(i) + g),
                p = Math.max(d, _),
                E = e / Math.pow(i, p);
              return q(E, t, c);
            }
          }
        );
      }
      function Nr(i, e, t, n, r) {
        return (
          (t = t !== void 0 ? t : !0),
          function (s, o, a, l) {
            if (s !== void 0) {
              const h = n ? Ki(i, n, a, r) : i;
              return !t || !l ? q(s, e, h) : Vi(s, h, e);
            }
          }
        );
      }
      function Wi(i) {
        if (i !== void 0) return 0;
      }
      function zr(i) {
        if (i !== void 0) return i;
      }
      function il(i) {
        const e = (2 * Math.PI) / i;
        return function (t, n) {
          if (n) return t;
          if (t !== void 0) return (t = Math.floor(t / e + 0.5) * e), t;
        };
      }
      function rl(i) {
        const e = yn(5);
        return function (t, n) {
          return n || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
        };
      }
      function Os(i) {
        return Math.pow(i, 3);
      }
      function Ct(i) {
        return 1 - Os(1 - i);
      }
      function sl(i) {
        return 3 * i * i - 2 * i * i * i;
      }
      function ol(i) {
        return i;
      }
      const ni = 0;
      class xe extends De {
        constructor(e) {
          super(),
            this.on,
            this.once,
            this.un,
            (e = Object.assign({}, e)),
            (this.hints_ = [0, 0]),
            (this.animations_ = []),
            this.updateAnimationKey_,
            (this.projection_ = bi(e.projection, "EPSG:3857")),
            (this.viewportSize_ = [100, 100]),
            (this.targetCenter_ = null),
            this.targetResolution_,
            this.targetRotation_,
            (this.nextCenter_ = null),
            this.nextResolution_,
            this.nextRotation_,
            (this.cancelAnchor_ = void 0),
            e.projection && qo(),
            e.center && (e.center = be(e.center, this.projection_)),
            e.extent && (e.extent = Je(e.extent, this.projection_)),
            this.applyOptions_(e);
        }
        applyOptions_(e) {
          const t = Object.assign({}, e);
          for (const a in we) delete t[a];
          this.setProperties(t, !0);
          const n = ll(e);
          (this.maxResolution_ = n.maxResolution),
            (this.minResolution_ = n.minResolution),
            (this.zoomFactor_ = n.zoomFactor),
            (this.resolutions_ = e.resolutions),
            (this.padding_ = e.padding),
            (this.minZoom_ = n.minZoom);
          const r = al(e),
            s = n.constraint,
            o = hl(e);
          (this.constraints_ = { center: r, resolution: s, rotation: o }),
            this.setRotation(e.rotation !== void 0 ? e.rotation : 0),
            this.setCenterInternal(e.center !== void 0 ? e.center : null),
            e.resolution !== void 0
              ? this.setResolution(e.resolution)
              : e.zoom !== void 0 && this.setZoom(e.zoom);
        }
        get padding() {
          return this.padding_;
        }
        set padding(e) {
          let t = this.padding_;
          this.padding_ = e;
          const n = this.getCenterInternal();
          if (n) {
            const r = e || [0, 0, 0, 0];
            t = t || [0, 0, 0, 0];
            const s = this.getResolution(),
              o = (s / 2) * (r[3] - t[3] + t[1] - r[1]),
              a = (s / 2) * (r[0] - t[0] + t[2] - r[2]);
            this.setCenterInternal([n[0] + o, n[1] - a]);
          }
        }
        getUpdatedOptions_(e) {
          const t = this.getProperties();
          return (
            t.resolution !== void 0
              ? (t.resolution = this.getResolution())
              : (t.zoom = this.getZoom()),
            (t.center = this.getCenterInternal()),
            (t.rotation = this.getRotation()),
            Object.assign({}, t, e)
          );
        }
        animate(e) {
          this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
          const t = new Array(arguments.length);
          for (let n = 0; n < t.length; ++n) {
            let r = arguments[n];
            r.center &&
              ((r = Object.assign({}, r)),
              (r.center = be(r.center, this.getProjection()))),
              r.anchor &&
                ((r = Object.assign({}, r)),
                (r.anchor = be(r.anchor, this.getProjection()))),
              (t[n] = r);
          }
          this.animateInternal.apply(this, t);
        }
        animateInternal(e) {
          let t = arguments.length,
            n;
          t > 1 &&
            typeof arguments[t - 1] == "function" &&
            ((n = arguments[t - 1]), --t);
          let r = 0;
          for (; r < t && !this.isDef(); ++r) {
            const c = arguments[r];
            c.center && this.setCenterInternal(c.center),
              c.zoom !== void 0
                ? this.setZoom(c.zoom)
                : c.resolution && this.setResolution(c.resolution),
              c.rotation !== void 0 && this.setRotation(c.rotation);
          }
          if (r === t) {
            n && dn(n, !0);
            return;
          }
          let s = Date.now(),
            o = this.targetCenter_.slice(),
            a = this.targetResolution_,
            l = this.targetRotation_;
          const h = [];
          for (; r < t; ++r) {
            const c = arguments[r],
              u = {
                start: s,
                complete: !1,
                anchor: c.anchor,
                duration: c.duration !== void 0 ? c.duration : 1e3,
                easing: c.easing || sl,
                callback: n,
              };
            if (
              (c.center &&
                ((u.sourceCenter = o),
                (u.targetCenter = c.center.slice()),
                (o = u.targetCenter)),
              c.zoom !== void 0
                ? ((u.sourceResolution = a),
                  (u.targetResolution = this.getResolutionForZoom(c.zoom)),
                  (a = u.targetResolution))
                : c.resolution &&
                  ((u.sourceResolution = a),
                  (u.targetResolution = c.resolution),
                  (a = u.targetResolution)),
              c.rotation !== void 0)
            ) {
              u.sourceRotation = l;
              const d = wt(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
              (u.targetRotation = l + d), (l = u.targetRotation);
            }
            cl(u) ? (u.complete = !0) : (s += u.duration), h.push(u);
          }
          this.animations_.push(h),
            this.setHint(_e.ANIMATING, 1),
            this.updateAnimations_();
        }
        getAnimating() {
          return this.hints_[_e.ANIMATING] > 0;
        }
        getInteracting() {
          return this.hints_[_e.INTERACTING] > 0;
        }
        cancelAnimations() {
          this.setHint(_e.ANIMATING, -this.hints_[_e.ANIMATING]);
          let e;
          for (let t = 0, n = this.animations_.length; t < n; ++t) {
            const r = this.animations_[t];
            if ((r[0].callback && dn(r[0].callback, !1), !e))
              for (let s = 0, o = r.length; s < o; ++s) {
                const a = r[s];
                if (!a.complete) {
                  e = a.anchor;
                  break;
                }
              }
          }
          (this.animations_.length = 0),
            (this.cancelAnchor_ = e),
            (this.nextCenter_ = null),
            (this.nextResolution_ = NaN),
            (this.nextRotation_ = NaN);
        }
        updateAnimations_() {
          if (
            (this.updateAnimationKey_ !== void 0 &&
              (cancelAnimationFrame(this.updateAnimationKey_),
              (this.updateAnimationKey_ = void 0)),
            !this.getAnimating())
          )
            return;
          const e = Date.now();
          let t = !1;
          for (let n = this.animations_.length - 1; n >= 0; --n) {
            const r = this.animations_[n];
            let s = !0;
            for (let o = 0, a = r.length; o < a; ++o) {
              const l = r[o];
              if (l.complete) continue;
              const h = e - l.start;
              let c = l.duration > 0 ? h / l.duration : 1;
              c >= 1 ? ((l.complete = !0), (c = 1)) : (s = !1);
              const u = l.easing(c);
              if (l.sourceCenter) {
                const d = l.sourceCenter[0],
                  g = l.sourceCenter[1],
                  f = l.targetCenter[0],
                  _ = l.targetCenter[1];
                this.nextCenter_ = l.targetCenter;
                const p = d + u * (f - d),
                  E = g + u * (_ - g);
                this.targetCenter_ = [p, E];
              }
              if (l.sourceResolution && l.targetResolution) {
                const d =
                  u === 1
                    ? l.targetResolution
                    : l.sourceResolution +
                      u * (l.targetResolution - l.sourceResolution);
                if (l.anchor) {
                  const g = this.getViewportSize_(this.getRotation()),
                    f = this.constraints_.resolution(d, 0, g, !0);
                  this.targetCenter_ = this.calculateCenterZoom(f, l.anchor);
                }
                (this.nextResolution_ = l.targetResolution),
                  (this.targetResolution_ = d),
                  this.applyTargetState_(!0);
              }
              if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
                const d =
                  u === 1
                    ? wt(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI
                    : l.sourceRotation +
                      u * (l.targetRotation - l.sourceRotation);
                if (l.anchor) {
                  const g = this.constraints_.rotation(d, !0);
                  this.targetCenter_ = this.calculateCenterRotate(g, l.anchor);
                }
                (this.nextRotation_ = l.targetRotation),
                  (this.targetRotation_ = d);
              }
              if ((this.applyTargetState_(!0), (t = !0), !l.complete)) break;
            }
            if (s) {
              (this.animations_[n] = null),
                this.setHint(_e.ANIMATING, -1),
                (this.nextCenter_ = null),
                (this.nextResolution_ = NaN),
                (this.nextRotation_ = NaN);
              const o = r[0].callback;
              o && dn(o, !0);
            }
          }
          (this.animations_ = this.animations_.filter(Boolean)),
            t &&
              this.updateAnimationKey_ === void 0 &&
              (this.updateAnimationKey_ = requestAnimationFrame(
                this.updateAnimations_.bind(this)
              ));
        }
        calculateCenterRotate(e, t) {
          let n;
          const r = this.getCenterInternal();
          return (
            r !== void 0 &&
              ((n = [r[0] - t[0], r[1] - t[1]]),
              Mi(n, e - this.getRotation()),
              Wo(n, t)),
            n
          );
        }
        calculateCenterZoom(e, t) {
          let n;
          const r = this.getCenterInternal(),
            s = this.getResolution();
          if (r !== void 0 && s !== void 0) {
            const o = t[0] - (e * (t[0] - r[0])) / s,
              a = t[1] - (e * (t[1] - r[1])) / s;
            n = [o, a];
          }
          return n;
        }
        getViewportSize_(e) {
          const t = this.viewportSize_;
          if (e) {
            const n = t[0],
              r = t[1];
            return [
              Math.abs(n * Math.cos(e)) + Math.abs(r * Math.sin(e)),
              Math.abs(n * Math.sin(e)) + Math.abs(r * Math.cos(e)),
            ];
          }
          return t;
        }
        setViewportSize(e) {
          (this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100]),
            this.getAnimating() || this.resolveConstraints(0);
        }
        getCenter() {
          const e = this.getCenterInternal();
          return e && pi(e, this.getProjection());
        }
        getCenterInternal() {
          return this.get(we.CENTER);
        }
        getConstraints() {
          return this.constraints_;
        }
        getConstrainResolution() {
          return this.get("constrainResolution");
        }
        getHints(e) {
          return e !== void 0
            ? ((e[0] = this.hints_[0]), (e[1] = this.hints_[1]), e)
            : this.hints_.slice();
        }
        calculateExtent(e) {
          const t = this.calculateExtentInternal(e);
          return ia(t, this.getProjection());
        }
        calculateExtentInternal(e) {
          e = e || this.getViewportSizeMinusPadding_();
          const t = this.getCenterInternal();
          G(t, "The view center is not defined");
          const n = this.getResolution();
          G(n !== void 0, "The view resolution is not defined");
          const r = this.getRotation();
          return (
            G(r !== void 0, "The view rotation is not defined"), gi(t, n, r, e)
          );
        }
        getMaxResolution() {
          return this.maxResolution_;
        }
        getMinResolution() {
          return this.minResolution_;
        }
        getMaxZoom() {
          return this.getZoomForResolution(this.minResolution_);
        }
        setMaxZoom(e) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
        }
        getMinZoom() {
          return this.getZoomForResolution(this.maxResolution_);
        }
        setMinZoom(e) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
        }
        setConstrainResolution(e) {
          this.applyOptions_(
            this.getUpdatedOptions_({ constrainResolution: e })
          );
        }
        getProjection() {
          return this.projection_;
        }
        getResolution() {
          return this.get(we.RESOLUTION);
        }
        getResolutions() {
          return this.resolutions_;
        }
        getResolutionForExtent(e, t) {
          return this.getResolutionForExtentInternal(
            Je(e, this.getProjection()),
            t
          );
        }
        getResolutionForExtentInternal(e, t) {
          t = t || this.getViewportSizeMinusPadding_();
          const n = X(e) / t[0],
            r = de(e) / t[1];
          return Math.max(n, r);
        }
        getResolutionForValueFunction(e) {
          e = e || 2;
          const t = this.getConstrainedResolution(this.maxResolution_),
            n = this.minResolution_,
            r = Math.log(t / n) / Math.log(e);
          return function (s) {
            return t / Math.pow(e, s * r);
          };
        }
        getRotation() {
          return this.get(we.ROTATION);
        }
        getValueForResolutionFunction(e) {
          const t = Math.log(e || 2),
            n = this.getConstrainedResolution(this.maxResolution_),
            r = this.minResolution_,
            s = Math.log(n / r) / t;
          return function (o) {
            return Math.log(n / o) / t / s;
          };
        }
        getViewportSizeMinusPadding_(e) {
          let t = this.getViewportSize_(e);
          const n = this.padding_;
          return n && (t = [t[0] - n[1] - n[3], t[1] - n[0] - n[2]]), t;
        }
        getState() {
          const e = this.getProjection(),
            t = this.getResolution(),
            n = this.getRotation();
          let r = this.getCenterInternal();
          const s = this.padding_;
          if (s) {
            const o = this.getViewportSizeMinusPadding_();
            r = ii(
              r,
              this.getViewportSize_(),
              [o[0] / 2 + s[3], o[1] / 2 + s[0]],
              t,
              n
            );
          }
          return {
            center: r.slice(0),
            projection: e !== void 0 ? e : null,
            resolution: t,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: n,
            zoom: this.getZoom(),
          };
        }
        getViewStateAndExtent() {
          return { viewState: this.getState(), extent: this.calculateExtent() };
        }
        getZoom() {
          let e;
          const t = this.getResolution();
          return t !== void 0 && (e = this.getZoomForResolution(t)), e;
        }
        getZoomForResolution(e) {
          let t = this.minZoom_ || 0,
            n,
            r;
          if (this.resolutions_) {
            const s = xi(this.resolutions_, e, 1);
            (t = s),
              (n = this.resolutions_[s]),
              s == this.resolutions_.length - 1
                ? (r = 2)
                : (r = n / this.resolutions_[s + 1]);
          } else (n = this.maxResolution_), (r = this.zoomFactor_);
          return t + Math.log(n / e) / Math.log(r);
        }
        getResolutionForZoom(e) {
          var t;
          if ((t = this.resolutions_) != null && t.length) {
            if (this.resolutions_.length === 1) return this.resolutions_[0];
            const n = q(Math.floor(e), 0, this.resolutions_.length - 2),
              r = this.resolutions_[n] / this.resolutions_[n + 1];
            return this.resolutions_[n] / Math.pow(r, q(e - n, 0, 1));
          }
          return (
            this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_)
          );
        }
        fit(e, t) {
          let n;
          if (
            (G(
              Array.isArray(e) || typeof e.getSimplifiedGeometry == "function",
              "Invalid extent or geometry provided as `geometry`"
            ),
            Array.isArray(e))
          ) {
            G(!$t(e), "Cannot fit empty extent provided as `geometry`");
            const r = Je(e, this.getProjection());
            n = Cr(r);
          } else if (e.getType() === "Circle") {
            const r = Je(e.getExtent(), this.getProjection());
            (n = Cr(r)), n.rotate(this.getRotation(), vt(r));
          } else {
            const r = ta();
            r ? (n = e.clone().transform(r, this.getProjection())) : (n = e);
          }
          this.fitInternal(n, t);
        }
        rotatedExtentForGeometry(e) {
          const t = this.getRotation(),
            n = Math.cos(t),
            r = Math.sin(-t),
            s = e.getFlatCoordinates(),
            o = e.getStride();
          let a = 1 / 0,
            l = 1 / 0,
            h = -1 / 0,
            c = -1 / 0;
          for (let u = 0, d = s.length; u < d; u += o) {
            const g = s[u] * n - s[u + 1] * r,
              f = s[u] * r + s[u + 1] * n;
            (a = Math.min(a, g)),
              (l = Math.min(l, f)),
              (h = Math.max(h, g)),
              (c = Math.max(c, f));
          }
          return [a, l, h, c];
        }
        fitInternal(e, t) {
          t = t || {};
          let n = t.size;
          n || (n = this.getViewportSizeMinusPadding_());
          const r = t.padding !== void 0 ? t.padding : [0, 0, 0, 0],
            s = t.nearest !== void 0 ? t.nearest : !1;
          let o;
          t.minResolution !== void 0
            ? (o = t.minResolution)
            : t.maxZoom !== void 0
            ? (o = this.getResolutionForZoom(t.maxZoom))
            : (o = 0);
          const a = this.rotatedExtentForGeometry(e);
          let l = this.getResolutionForExtentInternal(a, [
            n[0] - r[1] - r[3],
            n[1] - r[0] - r[2],
          ]);
          (l = isNaN(l) ? o : Math.max(l, o)),
            (l = this.getConstrainedResolution(l, s ? 0 : 1));
          const h = this.getRotation(),
            c = Math.sin(h),
            u = Math.cos(h),
            d = vt(a);
          (d[0] += ((r[1] - r[3]) / 2) * l), (d[1] += ((r[0] - r[2]) / 2) * l);
          const g = d[0] * u - d[1] * c,
            f = d[1] * u + d[0] * c,
            _ = this.getConstrainedCenter([g, f], l),
            p = t.callback ? t.callback : vn;
          t.duration !== void 0
            ? this.animateInternal(
                {
                  resolution: l,
                  center: _,
                  duration: t.duration,
                  easing: t.easing,
                },
                p
              )
            : ((this.targetResolution_ = l),
              (this.targetCenter_ = _),
              this.applyTargetState_(!1, !0),
              dn(p, !0));
        }
        centerOn(e, t, n) {
          this.centerOnInternal(be(e, this.getProjection()), t, n);
        }
        centerOnInternal(e, t, n) {
          this.setCenterInternal(
            ii(e, t, n, this.getResolution(), this.getRotation())
          );
        }
        calculateCenterShift(e, t, n, r) {
          let s;
          const o = this.padding_;
          if (o && e) {
            const a = this.getViewportSizeMinusPadding_(-n),
              l = ii(e, r, [a[0] / 2 + o[3], a[1] / 2 + o[0]], t, n);
            s = [e[0] - l[0], e[1] - l[1]];
          }
          return s;
        }
        isDef() {
          return !!this.getCenterInternal() && this.getResolution() !== void 0;
        }
        adjustCenter(e) {
          const t = pi(this.targetCenter_, this.getProjection());
          this.setCenter([t[0] + e[0], t[1] + e[1]]);
        }
        adjustCenterInternal(e) {
          const t = this.targetCenter_;
          this.setCenterInternal([t[0] + e[0], t[1] + e[1]]);
        }
        adjustResolution(e, t) {
          (t = t && be(t, this.getProjection())),
            this.adjustResolutionInternal(e, t);
        }
        adjustResolutionInternal(e, t) {
          const n = this.getAnimating() || this.getInteracting(),
            r = this.getViewportSize_(this.getRotation()),
            s = this.constraints_.resolution(
              this.targetResolution_ * e,
              0,
              r,
              n
            );
          t && (this.targetCenter_ = this.calculateCenterZoom(s, t)),
            (this.targetResolution_ *= e),
            this.applyTargetState_();
        }
        adjustZoom(e, t) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
        }
        adjustRotation(e, t) {
          t && (t = be(t, this.getProjection())),
            this.adjustRotationInternal(e, t);
        }
        adjustRotationInternal(e, t) {
          const n = this.getAnimating() || this.getInteracting(),
            r = this.constraints_.rotation(this.targetRotation_ + e, n);
          t && (this.targetCenter_ = this.calculateCenterRotate(r, t)),
            (this.targetRotation_ += e),
            this.applyTargetState_();
        }
        setCenter(e) {
          this.setCenterInternal(e && be(e, this.getProjection()));
        }
        setCenterInternal(e) {
          (this.targetCenter_ = e), this.applyTargetState_();
        }
        setHint(e, t) {
          return (this.hints_[e] += t), this.changed(), this.hints_[e];
        }
        setResolution(e) {
          (this.targetResolution_ = e), this.applyTargetState_();
        }
        setRotation(e) {
          (this.targetRotation_ = e), this.applyTargetState_();
        }
        setZoom(e) {
          this.setResolution(this.getResolutionForZoom(e));
        }
        applyTargetState_(e, t) {
          const n = this.getAnimating() || this.getInteracting() || t,
            r = this.constraints_.rotation(this.targetRotation_, n),
            s = this.getViewportSize_(r),
            o = this.constraints_.resolution(this.targetResolution_, 0, s, n),
            a = this.constraints_.center(
              this.targetCenter_,
              o,
              s,
              n,
              this.calculateCenterShift(this.targetCenter_, o, r, s)
            );
          this.get(we.ROTATION) !== r && this.set(we.ROTATION, r),
            this.get(we.RESOLUTION) !== o &&
              (this.set(we.RESOLUTION, o),
              this.set("zoom", this.getZoom(), !0)),
            (!a || !this.get(we.CENTER) || !Tn(this.get(we.CENTER), a)) &&
              this.set(we.CENTER, a),
            this.getAnimating() && !e && this.cancelAnimations(),
            (this.cancelAnchor_ = void 0);
        }
        resolveConstraints(e, t, n) {
          e = e !== void 0 ? e : 200;
          const r = t || 0,
            s = this.constraints_.rotation(this.targetRotation_),
            o = this.getViewportSize_(s),
            a = this.constraints_.resolution(this.targetResolution_, r, o),
            l = this.constraints_.center(
              this.targetCenter_,
              a,
              o,
              !1,
              this.calculateCenterShift(this.targetCenter_, a, s, o)
            );
          if (e === 0 && !this.cancelAnchor_) {
            (this.targetResolution_ = a),
              (this.targetRotation_ = s),
              (this.targetCenter_ = l),
              this.applyTargetState_();
            return;
          }
          (n = n || (e === 0 ? this.cancelAnchor_ : void 0)),
            (this.cancelAnchor_ = void 0),
            (this.getResolution() !== a ||
              this.getRotation() !== s ||
              !this.getCenterInternal() ||
              !Tn(this.getCenterInternal(), l)) &&
              (this.getAnimating() && this.cancelAnimations(),
              this.animateInternal({
                rotation: s,
                center: l,
                resolution: a,
                duration: e,
                easing: Ct,
                anchor: n,
              }));
        }
        beginInteraction() {
          this.resolveConstraints(0), this.setHint(_e.INTERACTING, 1);
        }
        endInteraction(e, t, n) {
          (n = n && be(n, this.getProjection())),
            this.endInteractionInternal(e, t, n);
        }
        endInteractionInternal(e, t, n) {
          this.getInteracting() &&
            (this.setHint(_e.INTERACTING, -1),
            this.resolveConstraints(e, t, n));
        }
        getConstrainedCenter(e, t) {
          const n = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(e, t || this.getResolution(), n);
        }
        getConstrainedZoom(e, t) {
          const n = this.getResolutionForZoom(e);
          return this.getZoomForResolution(this.getConstrainedResolution(n, t));
        }
        getConstrainedResolution(e, t) {
          t = t || 0;
          const n = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(e, t, n);
        }
      }
      function dn(i, e) {
        setTimeout(function () {
          i(e);
        }, 0);
      }
      function al(i) {
        if (i.extent !== void 0) {
          const t =
            i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
          return Fr(i.extent, i.constrainOnlyCenter, t);
        }
        const e = bi(i.projection, "EPSG:3857");
        if (i.multiWorld !== !0 && e.isGlobal()) {
          const t = e.getExtent().slice();
          return (t[0] = -1 / 0), (t[2] = 1 / 0), Fr(t, !1, !1);
        }
        return el;
      }
      function ll(i) {
        let e,
          t,
          n,
          o = i.minZoom !== void 0 ? i.minZoom : ni,
          a = i.maxZoom !== void 0 ? i.maxZoom : 28;
        const l = i.zoomFactor !== void 0 ? i.zoomFactor : 2,
          h = i.multiWorld !== void 0 ? i.multiWorld : !1,
          c =
            i.smoothResolutionConstraint !== void 0
              ? i.smoothResolutionConstraint
              : !0,
          u = i.showFullExtent !== void 0 ? i.showFullExtent : !1,
          d = bi(i.projection, "EPSG:3857"),
          g = d.getExtent();
        let f = i.constrainOnlyCenter,
          _ = i.extent;
        if (
          (!h && !_ && d.isGlobal() && ((f = !1), (_ = g)),
          i.resolutions !== void 0)
        ) {
          const p = i.resolutions;
          (t = p[o]),
            (n = p[a] !== void 0 ? p[a] : p[p.length - 1]),
            i.constrainResolution
              ? (e = tl(p, c, !f && _, u))
              : (e = Nr(t, n, c, !f && _, u));
        } else {
          const E =
              (g
                ? Math.max(X(g), de(g))
                : (360 * Ai.degrees) / d.getMetersPerUnit()) /
              Zi /
              Math.pow(2, ni),
            y = E / Math.pow(2, 28 - ni);
          (t = i.maxResolution),
            t !== void 0 ? (o = 0) : (t = E / Math.pow(l, o)),
            (n = i.minResolution),
            n === void 0 &&
              (i.maxZoom !== void 0
                ? i.maxResolution !== void 0
                  ? (n = t / Math.pow(l, a))
                  : (n = E / Math.pow(l, a))
                : (n = y)),
            (a = o + Math.floor(Math.log(t / n) / Math.log(l))),
            (n = t / Math.pow(l, a - o)),
            i.constrainResolution
              ? (e = nl(l, t, n, c, !f && _, u))
              : (e = Nr(t, n, c, !f && _, u));
        }
        return {
          constraint: e,
          maxResolution: t,
          minResolution: n,
          minZoom: o,
          zoomFactor: l,
        };
      }
      function hl(i) {
        if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
          const t = i.constrainRotation;
          return t === void 0 || t === !0
            ? rl()
            : t === !1
            ? zr
            : typeof t == "number"
            ? il(t)
            : zr;
        }
        return Wi;
      }
      function cl(i) {
        return !(
          (i.sourceCenter &&
            i.targetCenter &&
            !Tn(i.sourceCenter, i.targetCenter)) ||
          i.sourceResolution !== i.targetResolution ||
          i.sourceRotation !== i.targetRotation
        );
      }
      function ii(i, e, t, n, r) {
        const s = Math.cos(-r);
        let o = Math.sin(-r),
          a = i[0] * s - i[1] * o,
          l = i[1] * s + i[0] * o;
        (a += (e[0] / 2 - t[0]) * n), (l += (t[1] - e[1] / 2) * n), (o = -o);
        const h = a * s - l * o,
          c = l * s + a * o;
        return [h, c];
      }
      class ul extends Ps {
        constructor(e) {
          const t = Object.assign({}, e);
          delete t.source,
            super(t),
            this.on,
            this.once,
            this.un,
            (this.mapPrecomposeKey_ = null),
            (this.mapRenderKey_ = null),
            (this.sourceChangeKey_ = null),
            (this.renderer_ = null),
            (this.sourceReady_ = !1),
            (this.rendered = !1),
            e.render && (this.render = e.render),
            e.map && this.setMap(e.map),
            this.addChangeListener(z.SOURCE, this.handleSourcePropertyChange_);
          const n = e.source ? e.source : null;
          this.setSource(n);
        }
        getLayersArray(e) {
          return (e = e || []), e.push(this), e;
        }
        getLayerStatesArray(e) {
          return (e = e || []), e.push(this.getLayerState()), e;
        }
        getSource() {
          return this.get(z.SOURCE) || null;
        }
        getRenderSource() {
          return this.getSource();
        }
        getSourceState() {
          const e = this.getSource();
          return e ? e.getState() : "undefined";
        }
        handleSourceChange_() {
          this.changed(),
            !(this.sourceReady_ || this.getSource().getState() !== "ready") &&
              ((this.sourceReady_ = !0), this.dispatchEvent("sourceready"));
        }
        handleSourcePropertyChange_() {
          this.sourceChangeKey_ &&
            (V(this.sourceChangeKey_), (this.sourceChangeKey_ = null)),
            (this.sourceReady_ = !1);
          const e = this.getSource();
          e &&
            ((this.sourceChangeKey_ = N(
              e,
              b.CHANGE,
              this.handleSourceChange_,
              this
            )),
            e.getState() === "ready" &&
              ((this.sourceReady_ = !0),
              setTimeout(() => {
                this.dispatchEvent("sourceready");
              }, 0))),
            this.changed();
        }
        getFeatures(e) {
          return this.renderer_
            ? this.renderer_.getFeatures(e)
            : Promise.resolve([]);
        }
        getData(e) {
          return !this.renderer_ || !this.rendered
            ? null
            : this.renderer_.getData(e);
        }
        isVisible(e) {
          let t;
          const n = this.getMapInternal();
          !e && n && (e = n.getView()),
            e instanceof xe
              ? (t = { viewState: e.getState(), extent: e.calculateExtent() })
              : (t = e),
            !t.layerStatesArray &&
              n &&
              (t.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
          let r;
          t.layerStatesArray
            ? (r = t.layerStatesArray.find((o) => o.layer === this))
            : (r = this.getLayerState());
          const s = this.getExtent();
          return Ui(r, t.viewState) && (!s || qt(s, t.extent));
        }
        getAttributions(e) {
          var s;
          if (!this.isVisible(e)) return [];
          const t =
            (s = this.getSource()) == null ? void 0 : s.getAttributions();
          if (!t) return [];
          const n = e instanceof xe ? e.getViewStateAndExtent() : e;
          let r = t(n);
          return Array.isArray(r) || (r = [r]), r;
        }
        render(e, t) {
          const n = this.getRenderer();
          return n.prepareFrame(e)
            ? ((this.rendered = !0), n.renderFrame(e, t))
            : null;
        }
        unrender() {
          this.rendered = !1;
        }
        getDeclutter() {}
        renderDeclutter(e, t) {}
        renderDeferred(e) {
          const t = this.getRenderer();
          t && t.renderDeferred(e);
        }
        setMapInternal(e) {
          e || this.unrender(), this.set(z.MAP, e);
        }
        getMapInternal() {
          return this.get(z.MAP);
        }
        setMap(e) {
          this.mapPrecomposeKey_ &&
            (V(this.mapPrecomposeKey_), (this.mapPrecomposeKey_ = null)),
            e || this.changed(),
            this.mapRenderKey_ &&
              (V(this.mapRenderKey_), (this.mapRenderKey_ = null)),
            e &&
              ((this.mapPrecomposeKey_ = N(
                e,
                Ie.PRECOMPOSE,
                this.handlePrecompose_,
                this
              )),
              (this.mapRenderKey_ = N(this, b.CHANGE, e.render, e)),
              this.changed());
        }
        handlePrecompose_(e) {
          const t = e.frameState.layerStatesArray,
            n = this.getLayerState(!1);
          G(
            !t.some((r) => r.layer === n.layer),
            "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
          ),
            t.push(n);
        }
        setSource(e) {
          this.set(z.SOURCE, e);
        }
        getRenderer() {
          return (
            this.renderer_ || (this.renderer_ = this.createRenderer()),
            this.renderer_
          );
        }
        hasRenderer() {
          return !!this.renderer_;
        }
        createRenderer() {
          return null;
        }
        disposeInternal() {
          this.renderer_ && (this.renderer_.dispose(), delete this.renderer_),
            this.setSource(null),
            super.disposeInternal();
        }
      }
      function Ui(i, e) {
        if (!i.visible) return !1;
        const t = e.resolution;
        if (t < i.minResolution || t >= i.maxResolution) return !1;
        const n = e.zoom;
        return n > i.minZoom && n <= i.maxZoom;
      }
      const Un = ul;
      function dl(i, e, t, n, r) {
        Ds(i, e, t || 0, n || i.length - 1, r || fl);
      }
      function Ds(i, e, t, n, r) {
        for (; n > t; ) {
          if (n - t > 600) {
            var s = n - t + 1,
              o = e - t + 1,
              a = Math.log(s),
              l = 0.5 * Math.exp((2 * a) / 3),
              h =
                0.5 *
                Math.sqrt((a * l * (s - l)) / s) *
                (o - s / 2 < 0 ? -1 : 1),
              c = Math.max(t, Math.floor(e - (o * l) / s + h)),
              u = Math.min(n, Math.floor(e + ((s - o) * l) / s + h));
            Ds(i, e, c, u, r);
          }
          var d = i[e],
            g = t,
            f = n;
          for (Mt(i, t, e), r(i[n], d) > 0 && Mt(i, t, n); g < f; ) {
            for (Mt(i, g, f), g++, f--; r(i[g], d) < 0; ) g++;
            for (; r(i[f], d) > 0; ) f--;
          }
          r(i[t], d) === 0 ? Mt(i, t, f) : (f++, Mt(i, f, n)),
            f <= e && (t = f + 1),
            e <= f && (n = f - 1);
        }
      }
      function Mt(i, e, t) {
        var n = i[e];
        (i[e] = i[t]), (i[t] = n);
      }
      function fl(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      class gl {
        constructor(e = 9) {
          (this._maxEntries = Math.max(4, e)),
            (this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4))),
            this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(e) {
          let t = this.data;
          const n = [];
          if (!gn(e, t)) return n;
          const r = this.toBBox,
            s = [];
          for (; t; ) {
            for (let o = 0; o < t.children.length; o++) {
              const a = t.children[o],
                l = t.leaf ? r(a) : a;
              gn(e, l) &&
                (t.leaf ? n.push(a) : si(e, l) ? this._all(a, n) : s.push(a));
            }
            t = s.pop();
          }
          return n;
        }
        collides(e) {
          let t = this.data;
          if (!gn(e, t)) return !1;
          const n = [];
          for (; t; ) {
            for (let r = 0; r < t.children.length; r++) {
              const s = t.children[r],
                o = t.leaf ? this.toBBox(s) : s;
              if (gn(e, o)) {
                if (t.leaf || si(e, o)) return !0;
                n.push(s);
              }
            }
            t = n.pop();
          }
          return !1;
        }
        load(e) {
          if (!(e && e.length)) return this;
          if (e.length < this._minEntries) {
            for (let n = 0; n < e.length; n++) this.insert(e[n]);
            return this;
          }
          let t = this._build(e.slice(), 0, e.length - 1, 0);
          if (!this.data.children.length) this.data = t;
          else if (this.data.height === t.height) this._splitRoot(this.data, t);
          else {
            if (this.data.height < t.height) {
              const n = this.data;
              (this.data = t), (t = n);
            }
            this._insert(t, this.data.height - t.height - 1, !0);
          }
          return this;
        }
        insert(e) {
          return e && this._insert(e, this.data.height - 1), this;
        }
        clear() {
          return (this.data = ft([])), this;
        }
        remove(e, t) {
          if (!e) return this;
          let n = this.data;
          const r = this.toBBox(e),
            s = [],
            o = [];
          let a, l, h;
          for (; n || s.length; ) {
            if (
              (n ||
                ((n = s.pop()), (l = s[s.length - 1]), (a = o.pop()), (h = !0)),
              n.leaf)
            ) {
              const c = _l(e, n.children, t);
              if (c !== -1)
                return (
                  n.children.splice(c, 1), s.push(n), this._condense(s), this
                );
            }
            !h && !n.leaf && si(n, r)
              ? (s.push(n), o.push(a), (a = 0), (l = n), (n = n.children[0]))
              : l
              ? (a++, (n = l.children[a]), (h = !1))
              : (n = null);
          }
          return this;
        }
        toBBox(e) {
          return e;
        }
        compareMinX(e, t) {
          return e.minX - t.minX;
        }
        compareMinY(e, t) {
          return e.minY - t.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(e) {
          return (this.data = e), this;
        }
        _all(e, t) {
          const n = [];
          for (; e; )
            e.leaf ? t.push(...e.children) : n.push(...e.children),
              (e = n.pop());
          return t;
        }
        _build(e, t, n, r) {
          const s = n - t + 1;
          let o = this._maxEntries,
            a;
          if (s <= o) return (a = ft(e.slice(t, n + 1))), at(a, this.toBBox), a;
          r ||
            ((r = Math.ceil(Math.log(s) / Math.log(o))),
            (o = Math.ceil(s / Math.pow(o, r - 1)))),
            (a = ft([])),
            (a.leaf = !1),
            (a.height = r);
          const l = Math.ceil(s / o),
            h = l * Math.ceil(Math.sqrt(o));
          kr(e, t, n, h, this.compareMinX);
          for (let c = t; c <= n; c += h) {
            const u = Math.min(c + h - 1, n);
            kr(e, c, u, l, this.compareMinY);
            for (let d = c; d <= u; d += l) {
              const g = Math.min(d + l - 1, u);
              a.children.push(this._build(e, d, g, r - 1));
            }
          }
          return at(a, this.toBBox), a;
        }
        _chooseSubtree(e, t, n, r) {
          for (; r.push(t), !(t.leaf || r.length - 1 === n); ) {
            let s = 1 / 0,
              o = 1 / 0,
              a;
            for (let l = 0; l < t.children.length; l++) {
              const h = t.children[l],
                c = ri(h),
                u = yl(e, h) - c;
              u < o
                ? ((o = u), (s = c < s ? c : s), (a = h))
                : u === o && c < s && ((s = c), (a = h));
            }
            t = a || t.children[0];
          }
          return t;
        }
        _insert(e, t, n) {
          const r = n ? e : this.toBBox(e),
            s = [],
            o = this._chooseSubtree(r, this.data, t, s);
          for (
            o.children.push(e), St(o, r);
            t >= 0 && s[t].children.length > this._maxEntries;

          )
            this._split(s, t), t--;
          this._adjustParentBBoxes(r, s, t);
        }
        _split(e, t) {
          const n = e[t],
            r = n.children.length,
            s = this._minEntries;
          this._chooseSplitAxis(n, s, r);
          const o = this._chooseSplitIndex(n, s, r),
            a = ft(n.children.splice(o, n.children.length - o));
          (a.height = n.height),
            (a.leaf = n.leaf),
            at(n, this.toBBox),
            at(a, this.toBBox),
            t ? e[t - 1].children.push(a) : this._splitRoot(n, a);
        }
        _splitRoot(e, t) {
          (this.data = ft([e, t])),
            (this.data.height = e.height + 1),
            (this.data.leaf = !1),
            at(this.data, this.toBBox);
        }
        _chooseSplitIndex(e, t, n) {
          let r,
            s = 1 / 0,
            o = 1 / 0;
          for (let a = t; a <= n - t; a++) {
            const l = bt(e, 0, a, this.toBBox),
              h = bt(e, a, n, this.toBBox),
              c = El(l, h),
              u = ri(l) + ri(h);
            c < s
              ? ((s = c), (r = a), (o = u < o ? u : o))
              : c === s && u < o && ((o = u), (r = a));
          }
          return r || n - t;
        }
        _chooseSplitAxis(e, t, n) {
          const r = e.leaf ? this.compareMinX : ml,
            s = e.leaf ? this.compareMinY : pl,
            o = this._allDistMargin(e, t, n, r),
            a = this._allDistMargin(e, t, n, s);
          o < a && e.children.sort(r);
        }
        _allDistMargin(e, t, n, r) {
          e.children.sort(r);
          const s = this.toBBox,
            o = bt(e, 0, t, s),
            a = bt(e, n - t, n, s);
          let l = fn(o) + fn(a);
          for (let h = t; h < n - t; h++) {
            const c = e.children[h];
            St(o, e.leaf ? s(c) : c), (l += fn(o));
          }
          for (let h = n - t - 1; h >= t; h--) {
            const c = e.children[h];
            St(a, e.leaf ? s(c) : c), (l += fn(a));
          }
          return l;
        }
        _adjustParentBBoxes(e, t, n) {
          for (let r = n; r >= 0; r--) St(t[r], e);
        }
        _condense(e) {
          for (let t = e.length - 1, n; t >= 0; t--)
            e[t].children.length === 0
              ? t > 0
                ? ((n = e[t - 1].children), n.splice(n.indexOf(e[t]), 1))
                : this.clear()
              : at(e[t], this.toBBox);
        }
      }
      function _l(i, e, t) {
        if (!t) return e.indexOf(i);
        for (let n = 0; n < e.length; n++) if (t(i, e[n])) return n;
        return -1;
      }
      function at(i, e) {
        bt(i, 0, i.children.length, e, i);
      }
      function bt(i, e, t, n, r) {
        r || (r = ft(null)),
          (r.minX = 1 / 0),
          (r.minY = 1 / 0),
          (r.maxX = -1 / 0),
          (r.maxY = -1 / 0);
        for (let s = e; s < t; s++) {
          const o = i.children[s];
          St(r, i.leaf ? n(o) : o);
        }
        return r;
      }
      function St(i, e) {
        return (
          (i.minX = Math.min(i.minX, e.minX)),
          (i.minY = Math.min(i.minY, e.minY)),
          (i.maxX = Math.max(i.maxX, e.maxX)),
          (i.maxY = Math.max(i.maxY, e.maxY)),
          i
        );
      }
      function ml(i, e) {
        return i.minX - e.minX;
      }
      function pl(i, e) {
        return i.minY - e.minY;
      }
      function ri(i) {
        return (i.maxX - i.minX) * (i.maxY - i.minY);
      }
      function fn(i) {
        return i.maxX - i.minX + (i.maxY - i.minY);
      }
      function yl(i, e) {
        return (
          (Math.max(e.maxX, i.maxX) - Math.min(e.minX, i.minX)) *
          (Math.max(e.maxY, i.maxY) - Math.min(e.minY, i.minY))
        );
      }
      function El(i, e) {
        const t = Math.max(i.minX, e.minX),
          n = Math.max(i.minY, e.minY),
          r = Math.min(i.maxX, e.maxX),
          s = Math.min(i.maxY, e.maxY);
        return Math.max(0, r - t) * Math.max(0, s - n);
      }
      function si(i, e) {
        return (
          i.minX <= e.minX &&
          i.minY <= e.minY &&
          e.maxX <= i.maxX &&
          e.maxY <= i.maxY
        );
      }
      function gn(i, e) {
        return (
          e.minX <= i.maxX &&
          e.minY <= i.maxY &&
          e.maxX >= i.minX &&
          e.maxY >= i.minY
        );
      }
      function ft(i) {
        return {
          children: i,
          height: 1,
          leaf: !0,
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0,
        };
      }
      function kr(i, e, t, n, r) {
        const s = [e, t];
        for (; s.length; ) {
          if (((t = s.pop()), (e = s.pop()), t - e <= n)) continue;
          const o = e + Math.ceil((t - e) / n / 2) * n;
          dl(i, o, e, t, r), s.push(e, o, o, t);
        }
      }
      function Gr(i, e, t, n) {
        return t !== void 0 && n !== void 0
          ? [t / i, n / e]
          : t !== void 0
          ? t / i
          : n !== void 0
          ? n / e
          : 1;
      }
      class ji extends Yn {
        constructor(e) {
          e = e || {};
          const t = e.opacity !== void 0 ? e.opacity : 1,
            n = e.rotation !== void 0 ? e.rotation : 0,
            r = e.scale !== void 0 ? e.scale : 1,
            s = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
          super({
            opacity: t,
            rotation: n,
            scale: r,
            displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
            rotateWithView: s,
            declutterMode: e.declutterMode,
          }),
            (this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5]),
            (this.normalizedAnchor_ = null),
            (this.anchorOrigin_ =
              e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left"),
            (this.anchorXUnits_ =
              e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction"),
            (this.anchorYUnits_ =
              e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction"),
            (this.crossOrigin_ =
              e.crossOrigin !== void 0 ? e.crossOrigin : null);
          const o = e.img !== void 0 ? e.img : null;
          let a = e.src;
          G(
            !(a !== void 0 && o),
            "`image` and `src` cannot be provided at the same time"
          ),
            (a === void 0 || a.length === 0) && o && (a = o.src || re(o)),
            G(
              a !== void 0 && a.length > 0,
              "A defined and non-empty `src` or `image` must be provided"
            ),
            G(
              !(
                (e.width !== void 0 || e.height !== void 0) &&
                e.scale !== void 0
              ),
              "`width` or `height` cannot be provided together with `scale`"
            );
          let l;
          if (
            (e.src !== void 0
              ? (l = O.IDLE)
              : o !== void 0 &&
                ("complete" in o
                  ? o.complete
                    ? (l = o.src ? O.LOADED : O.IDLE)
                    : (l = O.LOADING)
                  : (l = O.LOADED)),
            (this.color_ = e.color !== void 0 ? Kt(e.color) : null),
            (this.iconImage_ = Gi(o, a, this.crossOrigin_, l, this.color_)),
            (this.offset_ = e.offset !== void 0 ? e.offset : [0, 0]),
            (this.offsetOrigin_ =
              e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left"),
            (this.origin_ = null),
            (this.size_ = e.size !== void 0 ? e.size : null),
            this.initialOptions_,
            e.width !== void 0 || e.height !== void 0)
          ) {
            let h, c;
            if (e.size) [h, c] = e.size;
            else {
              const u = this.getImage(1);
              if (u.width && u.height) (h = u.width), (c = u.height);
              else if (u instanceof HTMLImageElement) {
                this.initialOptions_ = e;
                const d = () => {
                  if ((this.unlistenImageChange(d), !this.initialOptions_))
                    return;
                  const g = this.iconImage_.getSize();
                  this.setScale(Gr(g[0], g[1], e.width, e.height));
                };
                this.listenImageChange(d);
                return;
              }
            }
            h !== void 0 && this.setScale(Gr(h, c, e.width, e.height));
          }
        }
        clone() {
          let e, t, n;
          return (
            this.initialOptions_
              ? ((t = this.initialOptions_.width),
                (n = this.initialOptions_.height))
              : ((e = this.getScale()), (e = Array.isArray(e) ? e.slice() : e)),
            new ji({
              anchor: this.anchor_.slice(),
              anchorOrigin: this.anchorOrigin_,
              anchorXUnits: this.anchorXUnits_,
              anchorYUnits: this.anchorYUnits_,
              color:
                this.color_ && this.color_.slice
                  ? this.color_.slice()
                  : this.color_ || void 0,
              crossOrigin: this.crossOrigin_,
              offset: this.offset_.slice(),
              offsetOrigin: this.offsetOrigin_,
              opacity: this.getOpacity(),
              rotateWithView: this.getRotateWithView(),
              rotation: this.getRotation(),
              scale: e,
              width: t,
              height: n,
              size: this.size_ !== null ? this.size_.slice() : void 0,
              src: this.getSrc(),
              displacement: this.getDisplacement().slice(),
              declutterMode: this.getDeclutterMode(),
            })
          );
        }
        getAnchor() {
          let e = this.normalizedAnchor_;
          if (!e) {
            e = this.anchor_;
            const r = this.getSize();
            if (
              this.anchorXUnits_ == "fraction" ||
              this.anchorYUnits_ == "fraction"
            ) {
              if (!r) return null;
              (e = this.anchor_.slice()),
                this.anchorXUnits_ == "fraction" && (e[0] *= r[0]),
                this.anchorYUnits_ == "fraction" && (e[1] *= r[1]);
            }
            if (this.anchorOrigin_ != "top-left") {
              if (!r) return null;
              e === this.anchor_ && (e = this.anchor_.slice()),
                (this.anchorOrigin_ == "top-right" ||
                  this.anchorOrigin_ == "bottom-right") &&
                  (e[0] = -e[0] + r[0]),
                (this.anchorOrigin_ == "bottom-left" ||
                  this.anchorOrigin_ == "bottom-right") &&
                  (e[1] = -e[1] + r[1]);
            }
            this.normalizedAnchor_ = e;
          }
          const t = this.getDisplacement(),
            n = this.getScaleArray();
          return [e[0] - t[0] / n[0], e[1] + t[1] / n[1]];
        }
        setAnchor(e) {
          (this.anchor_ = e), (this.normalizedAnchor_ = null);
        }
        getColor() {
          return this.color_;
        }
        getImage(e) {
          return this.iconImage_.getImage(e);
        }
        getPixelRatio(e) {
          return this.iconImage_.getPixelRatio(e);
        }
        getImageSize() {
          return this.iconImage_.getSize();
        }
        getImageState() {
          return this.iconImage_.getImageState();
        }
        getHitDetectionImage() {
          return this.iconImage_.getHitDetectionImage();
        }
        getOrigin() {
          if (this.origin_) return this.origin_;
          let e = this.offset_;
          if (this.offsetOrigin_ != "top-left") {
            const t = this.getSize(),
              n = this.iconImage_.getSize();
            if (!t || !n) return null;
            (e = e.slice()),
              (this.offsetOrigin_ == "top-right" ||
                this.offsetOrigin_ == "bottom-right") &&
                (e[0] = n[0] - t[0] - e[0]),
              (this.offsetOrigin_ == "bottom-left" ||
                this.offsetOrigin_ == "bottom-right") &&
                (e[1] = n[1] - t[1] - e[1]);
          }
          return (this.origin_ = e), this.origin_;
        }
        getSrc() {
          return this.iconImage_.getSrc();
        }
        getSize() {
          return this.size_ ? this.size_ : this.iconImage_.getSize();
        }
        getWidth() {
          const e = this.getScaleArray();
          if (this.size_) return this.size_[0] * e[0];
          if (this.iconImage_.getImageState() == O.LOADED)
            return this.iconImage_.getSize()[0] * e[0];
        }
        getHeight() {
          const e = this.getScaleArray();
          if (this.size_) return this.size_[1] * e[1];
          if (this.iconImage_.getImageState() == O.LOADED)
            return this.iconImage_.getSize()[1] * e[1];
        }
        setScale(e) {
          delete this.initialOptions_, super.setScale(e);
        }
        listenImageChange(e) {
          this.iconImage_.addEventListener(b.CHANGE, e);
        }
        load() {
          this.iconImage_.load();
        }
        unlistenImageChange(e) {
          this.iconImage_.removeEventListener(b.CHANGE, e);
        }
        ready() {
          return this.iconImage_.ready();
        }
      }
      let rt = 0;
      const se = 1 << rt++,
        P = 1 << rt++,
        le = 1 << rt++,
        ve = 1 << rt++,
        tt = 1 << rt++,
        Pt = 1 << rt++,
        _n = Math.pow(2, rt) - 1,
        Bi = {
          [se]: "boolean",
          [P]: "number",
          [le]: "string",
          [ve]: "color",
          [tt]: "number[]",
          [Pt]: "size",
        },
        wl = Object.keys(Bi).map(Number).sort(Pn);
      function vl(i) {
        return i in Bi;
      }
      function Ot(i) {
        const e = [];
        for (const t of wl) Dt(i, t) && e.push(Bi[t]);
        return e.length === 0
          ? "untyped"
          : e.length < 3
          ? e.join(" or ")
          : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
      }
      function Dt(i, e) {
        return (i & e) === e;
      }
      function Xe(i, e) {
        return i === e;
      }
      class $ {
        constructor(e, t) {
          if (!vl(e))
            throw new Error(
              `literal expressions must have a specific type, got ${Ot(e)}`
            );
          (this.type = e), (this.value = t);
        }
      }
      class Rl {
        constructor(e, t, ...n) {
          (this.type = e), (this.operator = t), (this.args = n);
        }
      }
      function Fs() {
        return {
          variables: new Set(),
          properties: new Set(),
          featureId: !1,
          geometryType: !1,
        };
      }
      function ee(i, e, t) {
        switch (typeof i) {
          case "boolean": {
            if (Xe(e, le)) return new $(le, i ? "true" : "false");
            if (!Dt(e, se))
              throw new Error(`got a boolean, but expected ${Ot(e)}`);
            return new $(se, i);
          }
          case "number": {
            if (Xe(e, Pt)) return new $(Pt, ce(i));
            if (Xe(e, se)) return new $(se, !!i);
            if (Xe(e, le)) return new $(le, i.toString());
            if (!Dt(e, P))
              throw new Error(`got a number, but expected ${Ot(e)}`);
            return new $(P, i);
          }
          case "string": {
            if (Xe(e, ve)) return new $(ve, zi(i));
            if (Xe(e, se)) return new $(se, !!i);
            if (!Dt(e, le))
              throw new Error(`got a string, but expected ${Ot(e)}`);
            return new $(le, i);
          }
        }
        if (!Array.isArray(i))
          throw new Error("expression must be an array or a primitive value");
        if (i.length === 0) throw new Error("empty expression");
        if (typeof i[0] == "string") return Ol(i, e, t);
        for (const n of i)
          if (typeof n != "number")
            throw new Error("expected an array of numbers");
        if (Xe(e, Pt)) {
          if (i.length !== 2)
            throw new Error(
              `expected an array of two values for a size, got ${i.length}`
            );
          return new $(Pt, i);
        }
        if (Xe(e, ve)) {
          if (i.length === 3) return new $(ve, [...i, 1]);
          if (i.length === 4) return new $(ve, i);
          throw new Error(
            `expected an array of 3 or 4 values for a color, got ${i.length}`
          );
        }
        if (!Dt(e, tt))
          throw new Error(`got an array of numbers, but expected ${Ot(e)}`);
        return new $(tt, i);
      }
      const m = {
          Get: "get",
          Var: "var",
          Concat: "concat",
          GeometryType: "geometry-type",
          LineMetric: "line-metric",
          Any: "any",
          All: "all",
          Not: "!",
          Resolution: "resolution",
          Zoom: "zoom",
          Time: "time",
          Equal: "==",
          NotEqual: "!=",
          GreaterThan: ">",
          GreaterThanOrEqualTo: ">=",
          LessThan: "<",
          LessThanOrEqualTo: "<=",
          Multiply: "*",
          Divide: "/",
          Add: "+",
          Subtract: "-",
          Clamp: "clamp",
          Mod: "%",
          Pow: "^",
          Abs: "abs",
          Floor: "floor",
          Ceil: "ceil",
          Round: "round",
          Sin: "sin",
          Cos: "cos",
          Atan: "atan",
          Sqrt: "sqrt",
          Match: "match",
          Between: "between",
          Interpolate: "interpolate",
          Coalesce: "coalesce",
          Case: "case",
          In: "in",
          Number: "number",
          String: "string",
          Array: "array",
          Color: "color",
          Id: "id",
          Band: "band",
          Palette: "palette",
          ToString: "to-string",
          Has: "has",
        },
        Cl = {
          [m.Get]: M(L(1, 1 / 0), Xr),
          [m.Var]: M(L(1, 1), Tl),
          [m.Has]: M(L(1, 1 / 0), Xr),
          [m.Id]: M(xl, lt),
          [m.Concat]: M(L(2, 1 / 0), F(le)),
          [m.GeometryType]: M(Il, lt),
          [m.LineMetric]: M(lt),
          [m.Resolution]: M(lt),
          [m.Zoom]: M(lt),
          [m.Time]: M(lt),
          [m.Any]: M(L(2, 1 / 0), F(se)),
          [m.All]: M(L(2, 1 / 0), F(se)),
          [m.Not]: M(L(1, 1), F(se)),
          [m.Equal]: M(L(2, 2), F(_n)),
          [m.NotEqual]: M(L(2, 2), F(_n)),
          [m.GreaterThan]: M(L(2, 2), F(P)),
          [m.GreaterThanOrEqualTo]: M(L(2, 2), F(P)),
          [m.LessThan]: M(L(2, 2), F(P)),
          [m.LessThanOrEqualTo]: M(L(2, 2), F(P)),
          [m.Multiply]: M(L(2, 1 / 0), Yr),
          [m.Coalesce]: M(L(2, 1 / 0), Yr),
          [m.Divide]: M(L(2, 2), F(P)),
          [m.Add]: M(L(2, 1 / 0), F(P)),
          [m.Subtract]: M(L(2, 2), F(P)),
          [m.Clamp]: M(L(3, 3), F(P)),
          [m.Mod]: M(L(2, 2), F(P)),
          [m.Pow]: M(L(2, 2), F(P)),
          [m.Abs]: M(L(1, 1), F(P)),
          [m.Floor]: M(L(1, 1), F(P)),
          [m.Ceil]: M(L(1, 1), F(P)),
          [m.Round]: M(L(1, 1), F(P)),
          [m.Sin]: M(L(1, 1), F(P)),
          [m.Cos]: M(L(1, 1), F(P)),
          [m.Atan]: M(L(1, 2), F(P)),
          [m.Sqrt]: M(L(1, 1), F(P)),
          [m.Match]: M(L(4, 1 / 0), Zr, Ml),
          [m.Between]: M(L(3, 3), F(P)),
          [m.Interpolate]: M(L(6, 1 / 0), Zr, Ll),
          [m.Case]: M(L(3, 1 / 0), Al, bl),
          [m.In]: M(L(2, 2), Sl),
          [m.Number]: M(L(1, 1 / 0), F(_n)),
          [m.String]: M(L(1, 1 / 0), F(_n)),
          [m.Array]: M(L(1, 1 / 0), F(P)),
          [m.Color]: M(L(1, 4), F(P)),
          [m.Band]: M(L(1, 3), F(P)),
          [m.Palette]: M(L(2, 2), Pl),
          [m.ToString]: M(L(1, 1), F(se | P | le | ve)),
        };
      function Xr(i, e, t) {
        const n = i.length - 1,
          r = new Array(n);
        for (let s = 0; s < n; ++s) {
          const o = i[s + 1];
          switch (typeof o) {
            case "number": {
              r[s] = new $(P, o);
              break;
            }
            case "string": {
              r[s] = new $(le, o);
              break;
            }
            default:
              throw new Error(
                `expected a string key or numeric array index for a get operation, got ${o}`
              );
          }
          s === 0 && t.properties.add(String(o));
        }
        return r;
      }
      function Tl(i, e, t) {
        const n = i[1];
        if (typeof n != "string")
          throw new Error("expected a string argument for var operation");
        return t.variables.add(n), [new $(le, n)];
      }
      function xl(i, e, t) {
        t.featureId = !0;
      }
      function Il(i, e, t) {
        t.geometryType = !0;
      }
      function lt(i, e, t) {
        const n = i[0];
        if (i.length !== 1)
          throw new Error(`expected no arguments for ${n} operation`);
        return [];
      }
      function L(i, e) {
        return function (t, n, r) {
          const s = t[0],
            o = t.length - 1;
          if (i === e) {
            if (o !== i) {
              const a = i === 1 ? "" : "s";
              throw new Error(`expected ${i} argument${a} for ${s}, got ${o}`);
            }
          } else if (o < i || o > e) {
            const a = e === 1 / 0 ? `${i} or more` : `${i} to ${e}`;
            throw new Error(`expected ${a} arguments for ${s}, got ${o}`);
          }
        };
      }
      function Yr(i, e, t) {
        const n = i.length - 1,
          r = new Array(n);
        for (let s = 0; s < n; ++s) {
          const o = ee(i[s + 1], e, t);
          r[s] = o;
        }
        return r;
      }
      function F(i) {
        return function (e, t, n) {
          const r = e.length - 1,
            s = new Array(r);
          for (let o = 0; o < r; ++o) {
            const a = ee(e[o + 1], i, n);
            s[o] = a;
          }
          return s;
        };
      }
      function Al(i, e, t) {
        const n = i[0],
          r = i.length - 1;
        if (r % 2 === 0)
          throw new Error(
            `expected an odd number of arguments for ${n}, got ${r} instead`
          );
      }
      function Zr(i, e, t) {
        const n = i[0],
          r = i.length - 1;
        if (r % 2 === 1)
          throw new Error(
            `expected an even number of arguments for operation ${n}, got ${r} instead`
          );
      }
      function Ml(i, e, t) {
        const n = i.length - 1,
          r = le | P | se,
          s = ee(i[1], r, t),
          o = ee(i[i.length - 1], e, t),
          a = new Array(n - 2);
        for (let l = 0; l < n - 2; l += 2) {
          try {
            const h = ee(i[l + 2], s.type, t);
            a[l] = h;
          } catch (h) {
            throw new Error(
              `failed to parse argument ${l + 1} of match expression: ${
                h.message
              }`
            );
          }
          try {
            const h = ee(i[l + 3], o.type, t);
            a[l + 1] = h;
          } catch (h) {
            throw new Error(
              `failed to parse argument ${l + 2} of match expression: ${
                h.message
              }`
            );
          }
        }
        return [s, ...a, o];
      }
      function Ll(i, e, t) {
        const n = i[1];
        let r;
        switch (n[0]) {
          case "linear":
            r = 1;
            break;
          case "exponential":
            const l = n[1];
            if (typeof l != "number" || l <= 0)
              throw new Error(
                `expected a number base for exponential interpolation, got ${JSON.stringify(
                  l
                )} instead`
              );
            r = l;
            break;
          default:
            throw new Error(`invalid interpolation type: ${JSON.stringify(n)}`);
        }
        const s = new $(P, r);
        let o;
        try {
          o = ee(i[2], P, t);
        } catch (l) {
          throw new Error(
            `failed to parse argument 1 in interpolate expression: ${l.message}`
          );
        }
        const a = new Array(i.length - 3);
        for (let l = 0; l < a.length; l += 2) {
          try {
            const h = ee(i[l + 3], P, t);
            a[l] = h;
          } catch (h) {
            throw new Error(
              `failed to parse argument ${l + 2} for interpolate expression: ${
                h.message
              }`
            );
          }
          try {
            const h = ee(i[l + 4], e, t);
            a[l + 1] = h;
          } catch (h) {
            throw new Error(
              `failed to parse argument ${l + 3} for interpolate expression: ${
                h.message
              }`
            );
          }
        }
        return [s, o, ...a];
      }
      function bl(i, e, t) {
        const n = ee(i[i.length - 1], e, t),
          r = new Array(i.length - 1);
        for (let s = 0; s < r.length - 1; s += 2) {
          try {
            const o = ee(i[s + 1], se, t);
            r[s] = o;
          } catch (o) {
            throw new Error(
              `failed to parse argument ${s} of case expression: ${o.message}`
            );
          }
          try {
            const o = ee(i[s + 2], n.type, t);
            r[s + 1] = o;
          } catch (o) {
            throw new Error(
              `failed to parse argument ${s + 1} of case expression: ${
                o.message
              }`
            );
          }
        }
        return (r[r.length - 1] = n), r;
      }
      function Sl(i, e, t) {
        let n = i[2];
        if (!Array.isArray(n))
          throw new Error(
            'the second argument for the "in" operator must be an array'
          );
        let r;
        if (typeof n[0] == "string") {
          if (n[0] !== "literal")
            throw new Error(
              'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
            );
          if (!Array.isArray(n[1]))
            throw new Error(
              'failed to parse "in" expression: the literal operator must be followed by an array'
            );
          (n = n[1]), (r = le);
        } else r = P;
        const s = new Array(n.length);
        for (let a = 0; a < s.length; a++)
          try {
            const l = ee(n[a], r, t);
            s[a] = l;
          } catch (l) {
            throw new Error(
              `failed to parse haystack item ${a} for "in" expression: ${l.message}`
            );
          }
        return [ee(i[1], r, t), ...s];
      }
      function Pl(i, e, t) {
        let n;
        try {
          n = ee(i[1], P, t);
        } catch (o) {
          throw new Error(
            `failed to parse first argument in palette expression: ${o.message}`
          );
        }
        const r = i[2];
        if (!Array.isArray(r))
          throw new Error("the second argument of palette must be an array");
        const s = new Array(r.length);
        for (let o = 0; o < s.length; o++) {
          let a;
          try {
            a = ee(r[o], ve, t);
          } catch (l) {
            throw new Error(
              `failed to parse color at index ${o} in palette expression: ${l.message}`
            );
          }
          if (!(a instanceof $))
            throw new Error(
              `the palette color at index ${o} must be a literal value`
            );
          s[o] = a;
        }
        return [n, ...s];
      }
      function M(...i) {
        return function (e, t, n) {
          const r = e[0];
          let s;
          for (let o = 0; o < i.length; o++) {
            const a = i[o](e, t, n);
            if (o == i.length - 1) {
              if (!a)
                throw new Error(
                  "expected last argument validator to return the parsed args"
                );
              s = a;
            }
          }
          return new Rl(t, r, ...s);
        };
      }
      function Ol(i, e, t) {
        const n = i[0],
          r = Cl[n];
        if (!r) throw new Error(`unknown operator: ${n}`);
        return r(i, e, t);
      }
      function Ns(i) {
        if (!i) return "";
        const e = i.getType();
        switch (e) {
          case "Point":
          case "LineString":
          case "Polygon":
            return e;
          case "MultiPoint":
          case "MultiLineString":
          case "MultiPolygon":
            return e.substring(5);
          case "Circle":
            return "Polygon";
          case "GeometryCollection":
            return Ns(i.getGeometries()[0]);
          default:
            return "";
        }
      }
      function zs() {
        return {
          variables: {},
          properties: {},
          resolution: NaN,
          featureId: null,
          geometryType: "",
        };
      }
      function Fe(i, e, t) {
        const n = ee(i, e, t);
        return Ce(n);
      }
      function Ce(i, e) {
        if (i instanceof $) {
          if (i.type === ve && typeof i.value == "string") {
            const n = zi(i.value);
            return function () {
              return n;
            };
          }
          return function () {
            return i.value;
          };
        }
        const t = i.operator;
        switch (t) {
          case m.Number:
          case m.String:
          case m.Coalesce:
            return Dl(i);
          case m.Get:
          case m.Var:
          case m.Has:
            return Fl(i);
          case m.Id:
            return (n) => n.featureId;
          case m.GeometryType:
            return (n) => n.geometryType;
          case m.Concat: {
            const n = i.args.map((r) => Ce(r));
            return (r) => "".concat(...n.map((s) => s(r).toString()));
          }
          case m.Resolution:
            return (n) => n.resolution;
          case m.Any:
          case m.All:
          case m.Between:
          case m.In:
          case m.Not:
            return zl(i);
          case m.Equal:
          case m.NotEqual:
          case m.LessThan:
          case m.LessThanOrEqualTo:
          case m.GreaterThan:
          case m.GreaterThanOrEqualTo:
            return Nl(i);
          case m.Multiply:
          case m.Divide:
          case m.Add:
          case m.Subtract:
          case m.Clamp:
          case m.Mod:
          case m.Pow:
          case m.Abs:
          case m.Floor:
          case m.Ceil:
          case m.Round:
          case m.Sin:
          case m.Cos:
          case m.Atan:
          case m.Sqrt:
            return kl(i);
          case m.Case:
            return Gl(i);
          case m.Match:
            return Xl(i);
          case m.Interpolate:
            return Yl(i);
          case m.ToString:
            return Zl(i);
          default:
            throw new Error(`Unsupported operator ${t}`);
        }
      }
      function Dl(i, e) {
        const t = i.operator,
          n = i.args.length,
          r = new Array(n);
        for (let s = 0; s < n; ++s) r[s] = Ce(i.args[s]);
        switch (t) {
          case m.Coalesce:
            return (s) => {
              for (let o = 0; o < n; ++o) {
                const a = r[o](s);
                if (typeof a < "u" && a !== null) return a;
              }
              throw new Error("Expected one of the values to be non-null");
            };
          case m.Number:
          case m.String:
            return (s) => {
              for (let o = 0; o < n; ++o) {
                const a = r[o](s);
                if (typeof a === t) return a;
              }
              throw new Error(`Expected one of the values to be a ${t}`);
            };
          default:
            throw new Error(`Unsupported assertion operator ${t}`);
        }
      }
      function Fl(i, e) {
        const n = i.args[0].value;
        switch (i.operator) {
          case m.Get:
            return (r) => {
              const s = i.args;
              let o = r.properties[n];
              for (let a = 1, l = s.length; a < l; ++a) {
                const c = s[a].value;
                o = o[c];
              }
              return o;
            };
          case m.Var:
            return (r) => r.variables[n];
          case m.Has:
            return (r) => {
              const s = i.args;
              if (!(n in r.properties)) return !1;
              let o = r.properties[n];
              for (let a = 1, l = s.length; a < l; ++a) {
                const c = s[a].value;
                if (!o || !Object.hasOwn(o, c)) return !1;
                o = o[c];
              }
              return !0;
            };
          default:
            throw new Error(`Unsupported accessor operator ${i.operator}`);
        }
      }
      function Nl(i, e) {
        const t = i.operator,
          n = Ce(i.args[0]),
          r = Ce(i.args[1]);
        switch (t) {
          case m.Equal:
            return (s) => n(s) === r(s);
          case m.NotEqual:
            return (s) => n(s) !== r(s);
          case m.LessThan:
            return (s) => n(s) < r(s);
          case m.LessThanOrEqualTo:
            return (s) => n(s) <= r(s);
          case m.GreaterThan:
            return (s) => n(s) > r(s);
          case m.GreaterThanOrEqualTo:
            return (s) => n(s) >= r(s);
          default:
            throw new Error(`Unsupported comparison operator ${t}`);
        }
      }
      function zl(i, e) {
        const t = i.operator,
          n = i.args.length,
          r = new Array(n);
        for (let s = 0; s < n; ++s) r[s] = Ce(i.args[s]);
        switch (t) {
          case m.Any:
            return (s) => {
              for (let o = 0; o < n; ++o) if (r[o](s)) return !0;
              return !1;
            };
          case m.All:
            return (s) => {
              for (let o = 0; o < n; ++o) if (!r[o](s)) return !1;
              return !0;
            };
          case m.Between:
            return (s) => {
              const o = r[0](s),
                a = r[1](s),
                l = r[2](s);
              return o >= a && o <= l;
            };
          case m.In:
            return (s) => {
              const o = r[0](s);
              for (let a = 1; a < n; ++a) if (o === r[a](s)) return !0;
              return !1;
            };
          case m.Not:
            return (s) => !r[0](s);
          default:
            throw new Error(`Unsupported logical operator ${t}`);
        }
      }
      function kl(i, e) {
        const t = i.operator,
          n = i.args.length,
          r = new Array(n);
        for (let s = 0; s < n; ++s) r[s] = Ce(i.args[s]);
        switch (t) {
          case m.Multiply:
            return (s) => {
              let o = 1;
              for (let a = 0; a < n; ++a) o *= r[a](s);
              return o;
            };
          case m.Divide:
            return (s) => r[0](s) / r[1](s);
          case m.Add:
            return (s) => {
              let o = 0;
              for (let a = 0; a < n; ++a) o += r[a](s);
              return o;
            };
          case m.Subtract:
            return (s) => r[0](s) - r[1](s);
          case m.Clamp:
            return (s) => {
              const o = r[0](s),
                a = r[1](s);
              if (o < a) return a;
              const l = r[2](s);
              return o > l ? l : o;
            };
          case m.Mod:
            return (s) => r[0](s) % r[1](s);
          case m.Pow:
            return (s) => Math.pow(r[0](s), r[1](s));
          case m.Abs:
            return (s) => Math.abs(r[0](s));
          case m.Floor:
            return (s) => Math.floor(r[0](s));
          case m.Ceil:
            return (s) => Math.ceil(r[0](s));
          case m.Round:
            return (s) => Math.round(r[0](s));
          case m.Sin:
            return (s) => Math.sin(r[0](s));
          case m.Cos:
            return (s) => Math.cos(r[0](s));
          case m.Atan:
            return n === 2
              ? (s) => Math.atan2(r[0](s), r[1](s))
              : (s) => Math.atan(r[0](s));
          case m.Sqrt:
            return (s) => Math.sqrt(r[0](s));
          default:
            throw new Error(`Unsupported numeric operator ${t}`);
        }
      }
      function Gl(i, e) {
        const t = i.args.length,
          n = new Array(t);
        for (let r = 0; r < t; ++r) n[r] = Ce(i.args[r]);
        return (r) => {
          for (let s = 0; s < t - 1; s += 2) if (n[s](r)) return n[s + 1](r);
          return n[t - 1](r);
        };
      }
      function Xl(i, e) {
        const t = i.args.length,
          n = new Array(t);
        for (let r = 0; r < t; ++r) n[r] = Ce(i.args[r]);
        return (r) => {
          const s = n[0](r);
          for (let o = 1; o < t; o += 2) if (s === n[o](r)) return n[o + 1](r);
          return n[t - 1](r);
        };
      }
      function Yl(i, e) {
        const t = i.args.length,
          n = new Array(t);
        for (let r = 0; r < t; ++r) n[r] = Ce(i.args[r]);
        return (r) => {
          const s = n[0](r),
            o = n[1](r);
          let a, l;
          for (let h = 2; h < t; h += 2) {
            const c = n[h](r);
            let u = n[h + 1](r);
            const d = Array.isArray(u);
            if ((d && (u = Pa(u)), c >= o))
              return h === 2
                ? u
                : d
                ? Kl(s, o, a, l, c, u)
                : Ft(s, o, a, l, c, u);
            (a = c), (l = u);
          }
          return l;
        };
      }
      function Zl(i, e) {
        const t = i.operator,
          n = i.args.length,
          r = new Array(n);
        for (let s = 0; s < n; ++s) r[s] = Ce(i.args[s]);
        switch (t) {
          case m.ToString:
            return (s) => {
              const o = r[0](s);
              return i.args[0].type === ve ? ki(o) : o.toString();
            };
          default:
            throw new Error(`Unsupported convert operator ${t}`);
        }
      }
      function Ft(i, e, t, n, r, s) {
        const o = r - t;
        if (o === 0) return n;
        const a = e - t,
          l = i === 1 ? a / o : (Math.pow(i, a) - 1) / (Math.pow(i, o) - 1);
        return n + l * (s - n);
      }
      function Kl(i, e, t, n, r, s) {
        if (r - t === 0) return n;
        const a = Ir(n),
          l = Ir(s);
        let h = l[2] - a[2];
        h > 180 ? (h -= 360) : h < -180 && (h += 360);
        const c = [
          Ft(i, e, t, a[0], r, l[0]),
          Ft(i, e, t, a[1], r, l[1]),
          a[2] + Ft(i, e, t, 0, r, h),
          Ft(i, e, t, n[3], r, s[3]),
        ];
        return Is(Oa(c));
      }
      function Vl(i) {
        return !0;
      }
      function Wl(i) {
        const e = Fs(),
          t = Ul(i, e),
          n = zs();
        return function (r, s) {
          if (
            ((n.properties = r.getPropertiesInternal()),
            (n.resolution = s),
            e.featureId)
          ) {
            const o = r.getId();
            o !== void 0 ? (n.featureId = o) : (n.featureId = null);
          }
          return e.geometryType && (n.geometryType = Ns(r.getGeometry())), t(n);
        };
      }
      function Kr(i) {
        const e = Fs(),
          t = i.length,
          n = new Array(t);
        for (let o = 0; o < t; ++o) n[o] = yi(i[o], e);
        const r = zs(),
          s = new Array(t);
        return function (o, a) {
          if (
            ((r.properties = o.getPropertiesInternal()),
            (r.resolution = a),
            e.featureId)
          ) {
            const h = o.getId();
            h !== void 0 ? (r.featureId = h) : (r.featureId = null);
          }
          let l = 0;
          for (let h = 0; h < t; ++h) {
            const c = n[h](r);
            c && ((s[l] = c), (l += 1));
          }
          return (s.length = l), s;
        };
      }
      function Ul(i, e) {
        const t = i.length,
          n = new Array(t);
        for (let r = 0; r < t; ++r) {
          const s = i[r],
            o = "filter" in s ? Fe(s.filter, se, e) : Vl;
          let a;
          if (Array.isArray(s.style)) {
            const l = s.style.length;
            a = new Array(l);
            for (let h = 0; h < l; ++h) a[h] = yi(s.style[h], e);
          } else a = [yi(s.style, e)];
          n[r] = { filter: o, styles: a };
        }
        return function (r) {
          const s = [];
          let o = !1;
          for (let a = 0; a < t; ++a) {
            const l = n[a].filter;
            if (l(r) && !(i[a].else && o)) {
              o = !0;
              for (const h of n[a].styles) {
                const c = h(r);
                c && s.push(c);
              }
            }
          }
          return s;
        };
      }
      function yi(i, e) {
        const t = Wt(i, "", e),
          n = Ut(i, "", e),
          r = jl(i, e),
          s = Bl(i, e),
          o = he(i, "z-index", e);
        if (!t && !n && !r && !s && !rs(i))
          throw new Error(
            "No fill, stroke, point, or text symbolizer properties in style: " +
              JSON.stringify(i)
          );
        const a = new En();
        return function (l) {
          let h = !0;
          if (t) {
            const c = t(l);
            c && (h = !1), a.setFill(c);
          }
          if (n) {
            const c = n(l);
            c && (h = !1), a.setStroke(c);
          }
          if (r) {
            const c = r(l);
            c && (h = !1), a.setText(c);
          }
          if (s) {
            const c = s(l);
            c && (h = !1), a.setImage(c);
          }
          return o && a.setZIndex(o(l)), h ? null : a;
        };
      }
      function Wt(i, e, t) {
        let n;
        if (e + "fill-pattern-src" in i) n = Jl(i, e + "fill-", t);
        else {
          if (i[e + "fill-color"] === "none") return (s) => null;
          n = Hi(i, e + "fill-color", t);
        }
        if (!n) return null;
        const r = new Qt();
        return function (s) {
          const o = n(s);
          return o === Ni ? null : (r.setColor(o), r);
        };
      }
      function Ut(i, e, t) {
        const n = he(i, e + "stroke-width", t),
          r = Hi(i, e + "stroke-color", t);
        if (!n && !r) return null;
        const s = Se(i, e + "stroke-line-cap", t),
          o = Se(i, e + "stroke-line-join", t),
          a = ks(i, e + "stroke-line-dash", t),
          l = he(i, e + "stroke-line-dash-offset", t),
          h = he(i, e + "stroke-miter-limit", t),
          c = new Xn();
        return function (u) {
          if (r) {
            const d = r(u);
            if (d === Ni) return null;
            c.setColor(d);
          }
          if ((n && c.setWidth(n(u)), s)) {
            const d = s(u);
            if (d !== "butt" && d !== "round" && d !== "square")
              throw new Error("Expected butt, round, or square line cap");
            c.setLineCap(d);
          }
          if (o) {
            const d = o(u);
            if (d !== "bevel" && d !== "round" && d !== "miter")
              throw new Error("Expected bevel, round, or miter line join");
            c.setLineJoin(d);
          }
          return (
            a && c.setLineDash(a(u)),
            l && c.setLineDashOffset(l(u)),
            h && c.setMiterLimit(h(u)),
            c
          );
        };
      }
      function jl(i, e) {
        const t = "text-",
          n = Se(i, t + "value", e);
        if (!n) return null;
        const r = Wt(i, t, e),
          s = Wt(i, t + "background-", e),
          o = Ut(i, t, e),
          a = Ut(i, t + "background-", e),
          l = Se(i, t + "font", e),
          h = he(i, t + "max-angle", e),
          c = he(i, t + "offset-x", e),
          u = he(i, t + "offset-y", e),
          d = jt(i, t + "overflow", e),
          g = Se(i, t + "placement", e),
          f = he(i, t + "repeat", e),
          _ = jn(i, t + "scale", e),
          p = jt(i, t + "rotate-with-view", e),
          E = he(i, t + "rotation", e),
          y = Se(i, t + "align", e),
          R = Se(i, t + "justify", e),
          v = Se(i, t + "baseline", e),
          w = ks(i, t + "padding", e),
          A = Bn(i, t + "declutter-mode"),
          x = new Yi({ declutterMode: A });
        return function (C) {
          if (
            (x.setText(n(C)),
            r && x.setFill(r(C)),
            s && x.setBackgroundFill(s(C)),
            o && x.setStroke(o(C)),
            a && x.setBackgroundStroke(a(C)),
            l && x.setFont(l(C)),
            h && x.setMaxAngle(h(C)),
            c && x.setOffsetX(c(C)),
            u && x.setOffsetY(u(C)),
            d && x.setOverflow(d(C)),
            g)
          ) {
            const I = g(C);
            if (I !== "point" && I !== "line")
              throw new Error("Expected point or line for text-placement");
            x.setPlacement(I);
          }
          if (
            (f && x.setRepeat(f(C)),
            _ && x.setScale(_(C)),
            p && x.setRotateWithView(p(C)),
            E && x.setRotation(E(C)),
            y)
          ) {
            const I = y(C);
            if (
              I !== "left" &&
              I !== "center" &&
              I !== "right" &&
              I !== "end" &&
              I !== "start"
            )
              throw new Error(
                "Expected left, right, center, start, or end for text-align"
              );
            x.setTextAlign(I);
          }
          if (R) {
            const I = R(C);
            if (I !== "left" && I !== "right" && I !== "center")
              throw new Error(
                "Expected left, right, or center for text-justify"
              );
            x.setJustify(I);
          }
          if (v) {
            const I = v(C);
            if (
              I !== "bottom" &&
              I !== "top" &&
              I !== "middle" &&
              I !== "alphabetic" &&
              I !== "hanging"
            )
              throw new Error(
                "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
              );
            x.setTextBaseline(I);
          }
          return w && x.setPadding(w(C)), x;
        };
      }
      function Bl(i, e) {
        return "icon-src" in i
          ? Hl(i, e)
          : "shape-points" in i
          ? ql(i, e)
          : "circle-radius" in i
          ? $l(i, e)
          : null;
      }
      function Hl(i, e) {
        const t = "icon-",
          n = t + "src",
          r = Gs(i[n], n),
          s = In(i, t + "anchor", e),
          o = jn(i, t + "scale", e),
          a = he(i, t + "opacity", e),
          l = In(i, t + "displacement", e),
          h = he(i, t + "rotation", e),
          c = jt(i, t + "rotate-with-view", e),
          u = Wr(i, t + "anchor-origin"),
          d = Ur(i, t + "anchor-x-units"),
          g = Ur(i, t + "anchor-y-units"),
          f = nh(i, t + "color"),
          _ = eh(i, t + "cross-origin"),
          p = th(i, t + "offset"),
          E = Wr(i, t + "offset-origin"),
          y = An(i, t + "width"),
          R = An(i, t + "height"),
          v = Ql(i, t + "size"),
          w = Bn(i, t + "declutter-mode"),
          A = new ji({
            src: r,
            anchorOrigin: u,
            anchorXUnits: d,
            anchorYUnits: g,
            color: f,
            crossOrigin: _,
            offset: p,
            offsetOrigin: E,
            height: R,
            width: y,
            size: v,
            declutterMode: w,
          });
        return function (x) {
          return (
            a && A.setOpacity(a(x)),
            l && A.setDisplacement(l(x)),
            h && A.setRotation(h(x)),
            c && A.setRotateWithView(c(x)),
            o && A.setScale(o(x)),
            s && A.setAnchor(s(x)),
            A
          );
        };
      }
      function ql(i, e) {
        const t = "shape-",
          n = t + "points",
          r = t + "radius",
          s = Ei(i[n], n),
          o = Ei(i[r], r),
          a = Wt(i, t, e),
          l = Ut(i, t, e),
          h = jn(i, t + "scale", e),
          c = In(i, t + "displacement", e),
          u = he(i, t + "rotation", e),
          d = jt(i, t + "rotate-with-view", e),
          g = An(i, t + "radius2"),
          f = An(i, t + "angle"),
          _ = Bn(i, t + "declutter-mode"),
          p = new Kn({
            points: s,
            radius: o,
            radius2: g,
            angle: f,
            declutterMode: _,
          });
        return function (E) {
          return (
            a && p.setFill(a(E)),
            l && p.setStroke(l(E)),
            c && p.setDisplacement(c(E)),
            u && p.setRotation(u(E)),
            d && p.setRotateWithView(d(E)),
            h && p.setScale(h(E)),
            p
          );
        };
      }
      function $l(i, e) {
        const t = "circle-",
          n = Wt(i, t, e),
          r = Ut(i, t, e),
          s = he(i, t + "radius", e),
          o = jn(i, t + "scale", e),
          a = In(i, t + "displacement", e),
          l = he(i, t + "rotation", e),
          h = jt(i, t + "rotate-with-view", e),
          c = Bn(i, t + "declutter-mode"),
          u = new Vn({ radius: 5, declutterMode: c });
        return function (d) {
          return (
            s && u.setRadius(s(d)),
            n && u.setFill(n(d)),
            r && u.setStroke(r(d)),
            a && u.setDisplacement(a(d)),
            l && u.setRotation(l(d)),
            h && u.setRotateWithView(h(d)),
            o && u.setScale(o(d)),
            u
          );
        };
      }
      function he(i, e, t) {
        if (!(e in i)) return;
        const n = Fe(i[e], P, t);
        return function (r) {
          return Ei(n(r), e);
        };
      }
      function Se(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], le, t);
        return function (r) {
          return Gs(n(r), e);
        };
      }
      function Jl(i, e, t) {
        const n = Se(i, e + "pattern-src", t),
          r = Vr(i, e + "pattern-offset", t),
          s = Vr(i, e + "pattern-size", t),
          o = Hi(i, e + "color", t);
        return function (a) {
          return {
            src: n(a),
            offset: r && r(a),
            size: s && s(a),
            color: o && o(a),
          };
        };
      }
      function jt(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], se, t);
        return function (r) {
          const s = n(r);
          if (typeof s != "boolean")
            throw new Error(`Expected a boolean for ${e}`);
          return s;
        };
      }
      function Hi(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], ve, t);
        return function (r) {
          return Xs(n(r), e);
        };
      }
      function ks(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], tt, t);
        return function (r) {
          return en(n(r), e);
        };
      }
      function In(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], tt, t);
        return function (r) {
          const s = en(n(r), e);
          if (s.length !== 2) throw new Error(`Expected two numbers for ${e}`);
          return s;
        };
      }
      function Vr(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], tt, t);
        return function (r) {
          return Ys(n(r), e);
        };
      }
      function jn(i, e, t) {
        if (!(e in i)) return null;
        const n = Fe(i[e], tt | P, t);
        return function (r) {
          return ih(n(r), e);
        };
      }
      function An(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (typeof t != "number")
            throw new Error(`Expected a number for ${e}`);
          return t;
        }
      }
      function Ql(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (typeof t == "number") return ce(t);
          if (!Array.isArray(t))
            throw new Error(`Expected a number or size array for ${e}`);
          if (
            t.length !== 2 ||
            typeof t[0] != "number" ||
            typeof t[1] != "number"
          )
            throw new Error(`Expected a number or size array for ${e}`);
          return t;
        }
      }
      function eh(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (typeof t != "string")
            throw new Error(`Expected a string for ${e}`);
          return t;
        }
      }
      function Wr(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (
            t !== "bottom-left" &&
            t !== "bottom-right" &&
            t !== "top-left" &&
            t !== "top-right"
          )
            throw new Error(
              `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
            );
          return t;
        }
      }
      function Ur(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (t !== "pixels" && t !== "fraction")
            throw new Error(`Expected pixels or fraction for ${e}`);
          return t;
        }
      }
      function th(i, e) {
        const t = i[e];
        if (t !== void 0) return en(t, e);
      }
      function Bn(i, e) {
        const t = i[e];
        if (t !== void 0) {
          if (typeof t != "string")
            throw new Error(`Expected a string for ${e}`);
          if (t !== "declutter" && t !== "obstacle" && t !== "none")
            throw new Error(`Expected declutter, obstacle, or none for ${e}`);
          return t;
        }
      }
      function nh(i, e) {
        const t = i[e];
        if (t !== void 0) return Xs(t, e);
      }
      function en(i, e) {
        if (!Array.isArray(i)) throw new Error(`Expected an array for ${e}`);
        const t = i.length;
        for (let n = 0; n < t; ++n)
          if (typeof i[n] != "number")
            throw new Error(`Expected an array of numbers for ${e}`);
        return i;
      }
      function Gs(i, e) {
        if (typeof i != "string") throw new Error(`Expected a string for ${e}`);
        return i;
      }
      function Ei(i, e) {
        if (typeof i != "number") throw new Error(`Expected a number for ${e}`);
        return i;
      }
      function Xs(i, e) {
        if (typeof i == "string") return i;
        const t = en(i, e),
          n = t.length;
        if (n < 3 || n > 4)
          throw new Error(`Expected a color with 3 or 4 values for ${e}`);
        return t;
      }
      function Ys(i, e) {
        const t = en(i, e);
        if (t.length !== 2)
          throw new Error(`Expected an array of two numbers for ${e}`);
        return t;
      }
      function ih(i, e) {
        return typeof i == "number" ? i : Ys(i, e);
      }
      const jr = { RENDER_ORDER: "renderOrder" };
      class rh extends Un {
        constructor(e) {
          e = e || {};
          const t = Object.assign({}, e);
          delete t.style,
            delete t.renderBuffer,
            delete t.updateWhileAnimating,
            delete t.updateWhileInteracting,
            super(t),
            (this.declutter_ = e.declutter ? String(e.declutter) : void 0),
            (this.renderBuffer_ =
              e.renderBuffer !== void 0 ? e.renderBuffer : 100),
            (this.style_ = null),
            (this.styleFunction_ = void 0),
            this.setStyle(e.style),
            (this.updateWhileAnimating_ =
              e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1),
            (this.updateWhileInteracting_ =
              e.updateWhileInteracting !== void 0
                ? e.updateWhileInteracting
                : !1);
        }
        getDeclutter() {
          return this.declutter_;
        }
        getFeatures(e) {
          return super.getFeatures(e);
        }
        getRenderBuffer() {
          return this.renderBuffer_;
        }
        getRenderOrder() {
          return this.get(jr.RENDER_ORDER);
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        getUpdateWhileAnimating() {
          return this.updateWhileAnimating_;
        }
        getUpdateWhileInteracting() {
          return this.updateWhileInteracting_;
        }
        renderDeclutter(e, t) {
          const n = this.getDeclutter();
          n in e.declutter || (e.declutter[n] = new gl(9)),
            this.getRenderer().renderDeclutter(e, t);
        }
        setRenderOrder(e) {
          this.set(jr.RENDER_ORDER, e);
        }
        setStyle(e) {
          this.style_ = e === void 0 ? Ss : e;
          const t = sh(e);
          (this.styleFunction_ = e === null ? void 0 : $a(t)), this.changed();
        }
      }
      function sh(i) {
        if (i === void 0) return Ss;
        if (!i) return null;
        if (typeof i == "function" || i instanceof En) return i;
        if (!Array.isArray(i)) return Kr([i]);
        if (i.length === 0) return [];
        const e = i.length,
          t = i[0];
        if (t instanceof En) {
          const r = new Array(e);
          for (let s = 0; s < e; ++s) {
            const o = i[s];
            if (!(o instanceof En))
              throw new Error("Expected a list of style instances");
            r[s] = o;
          }
          return r;
        }
        if ("style" in t) {
          const r = new Array(e);
          for (let s = 0; s < e; ++s) {
            const o = i[s];
            if (!("style" in o))
              throw new Error("Expected a list of rules with a style property");
            r[s] = o;
          }
          return Wl(r);
        }
        return Kr(i);
      }
      const oh = 5;
      class ah extends Bt {
        constructor(e) {
          super(),
            (this.ready = !0),
            (this.boundHandleImageChange_ = this.handleImageChange_.bind(this)),
            (this.layer_ = e),
            (this.staleKeys_ = new Array()),
            (this.maxStaleKeys = oh);
        }
        getStaleKeys() {
          return this.staleKeys_;
        }
        prependStaleKey(e) {
          this.staleKeys_.unshift(e),
            this.staleKeys_.length > this.maxStaleKeys &&
              (this.staleKeys_.length = this.maxStaleKeys);
        }
        getFeatures(e) {
          return D();
        }
        getData(e) {
          return null;
        }
        prepareFrame(e) {
          return D();
        }
        renderFrame(e, t) {
          return D();
        }
        forEachFeatureAtCoordinate(e, t, n, r, s) {}
        getLayer() {
          return this.layer_;
        }
        handleFontsChanged() {}
        handleImageChange_(e) {
          const t = e.target;
          (t.getState() === O.LOADED || t.getState() === O.ERROR) &&
            this.renderIfReadyAndVisible();
        }
        loadImage(e) {
          let t = e.getState();
          return (
            t != O.LOADED &&
              t != O.ERROR &&
              e.addEventListener(b.CHANGE, this.boundHandleImageChange_),
            t == O.IDLE && (e.load(), (t = e.getState())),
            t == O.LOADED
          );
        }
        renderIfReadyAndVisible() {
          const e = this.getLayer();
          e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
        }
        renderDeferred(e) {}
        disposeInternal() {
          delete this.layer_, super.disposeInternal();
        }
      }
      class Zs extends je {
        constructor(e, t, n, r) {
          super(e),
            (this.inversePixelTransform = t),
            (this.frameState = n),
            (this.context = r);
        }
      }
      class lh {
        constructor() {
          ar(
            this,
            "pushMethodArgs_",
            (...e) => (
              this.instructions_[this.zIndex + this.offset_].push(e), this
            )
          );
          (this.instructions_ = []),
            (this.zIndex = 0),
            (this.offset_ = 0),
            (this.context_ = new Proxy(xn(), {
              get: (e, t) => {
                if (typeof xn()[t] == "function")
                  return (
                    this.instructions_[this.zIndex + this.offset_] ||
                      (this.instructions_[this.zIndex + this.offset_] = []),
                    this.instructions_[this.zIndex + this.offset_].push(t),
                    this.pushMethodArgs_
                  );
              },
              set: (e, t, n) => (
                this.instructions_[this.zIndex + this.offset_] ||
                  (this.instructions_[this.zIndex + this.offset_] = []),
                this.instructions_[this.zIndex + this.offset_].push(t, n),
                !0
              ),
            }));
        }
        pushFunction(e) {
          this.instructions_[this.zIndex + this.offset_].push(e);
        }
        getContext() {
          return this.context_;
        }
        draw(e) {
          this.instructions_.forEach((t) => {
            for (let n = 0, r = t.length; n < r; ++n) {
              const s = t[n];
              if (typeof s == "function") {
                s(e);
                continue;
              }
              const o = t[++n];
              if (typeof e[s] == "function") e[s](...o);
              else {
                if (typeof o == "function") {
                  e[s] = o(e);
                  continue;
                }
                e[s] = o;
              }
            }
          });
        }
        clear() {
          (this.instructions_.length = 0),
            (this.zIndex = 0),
            (this.offset_ = 0);
        }
        offset() {
          (this.offset_ = this.instructions_.length), (this.zIndex = 0);
        }
      }
      let gt = null;
      function hh() {
        gt = ie(1, 1, void 0, { willReadFrequently: !0 });
      }
      class ch extends ah {
        constructor(e) {
          super(e),
            (this.container = null),
            this.renderedResolution,
            (this.tempTransform = pt()),
            (this.pixelTransform = pt()),
            (this.inversePixelTransform = pt()),
            (this.context = null),
            (this.deferredContext_ = null),
            (this.containerReused = !1),
            (this.frameState = null);
        }
        getImageData(e, t, n) {
          gt || hh(), gt.clearRect(0, 0, 1, 1);
          let r;
          try {
            gt.drawImage(e, t, n, 1, 1, 0, 0, 1, 1),
              (r = gt.getImageData(0, 0, 1, 1).data);
          } catch {
            return (gt = null), null;
          }
          return r;
        }
        getBackground(e) {
          let n = this.getLayer().getBackground();
          return (
            typeof n == "function" && (n = n(e.viewState.resolution)),
            n || void 0
          );
        }
        useContainer(e, t, n) {
          const r = this.getLayer().getClassName();
          let s, o;
          if (
            e &&
            e.className === r &&
            (!n ||
              (e &&
                e.style.backgroundColor &&
                On(Kt(e.style.backgroundColor), Kt(n))))
          ) {
            const a = e.firstElementChild;
            a instanceof HTMLCanvasElement && (o = a.getContext("2d"));
          }
          if (
            (o && o.canvas.style.transform === t
              ? ((this.container = e),
                (this.context = o),
                (this.containerReused = !0))
              : this.containerReused
              ? ((this.container = null),
                (this.context = null),
                (this.containerReused = !1))
              : this.container && (this.container.style.backgroundColor = null),
            !this.container)
          ) {
            (s = document.createElement("div")), (s.className = r);
            let a = s.style;
            (a.position = "absolute"),
              (a.width = "100%"),
              (a.height = "100%"),
              (o = ie());
            const l = o.canvas;
            s.appendChild(l),
              (a = l.style),
              (a.position = "absolute"),
              (a.left = "0"),
              (a.transformOrigin = "top left"),
              (this.container = s),
              (this.context = o);
          }
          !this.containerReused &&
            n &&
            !this.container.style.backgroundColor &&
            (this.container.style.backgroundColor = n);
        }
        clipUnrotated(e, t, n) {
          const r = it(n),
            s = Gn(n),
            o = kn(n),
            a = zn(n);
          ge(t.coordinateToPixelTransform, r),
            ge(t.coordinateToPixelTransform, s),
            ge(t.coordinateToPixelTransform, o),
            ge(t.coordinateToPixelTransform, a);
          const l = this.inversePixelTransform;
          ge(l, r),
            ge(l, s),
            ge(l, o),
            ge(l, a),
            e.save(),
            e.beginPath(),
            e.moveTo(Math.round(r[0]), Math.round(r[1])),
            e.lineTo(Math.round(s[0]), Math.round(s[1])),
            e.lineTo(Math.round(o[0]), Math.round(o[1])),
            e.lineTo(Math.round(a[0]), Math.round(a[1])),
            e.clip();
        }
        prepareContainer(e, t) {
          const n = e.extent,
            r = e.viewState.resolution,
            s = e.viewState.rotation,
            o = e.pixelRatio,
            a = Math.round((X(n) / r) * o),
            l = Math.round((de(n) / r) * o);
          zt(
            this.pixelTransform,
            e.size[0] / 2,
            e.size[1] / 2,
            1 / o,
            1 / o,
            s,
            -a / 2,
            -l / 2
          ),
            ss(this.inversePixelTransform, this.pixelTransform);
          const h = Eo(this.pixelTransform);
          if (
            (this.useContainer(t, h, this.getBackground(e)),
            !this.containerReused)
          ) {
            const c = this.context.canvas;
            c.width != a || c.height != l
              ? ((c.width = a), (c.height = l))
              : this.context.clearRect(0, 0, a, l),
              h !== c.style.transform && (c.style.transform = h);
          }
        }
        dispatchRenderEvent_(e, t, n) {
          const r = this.getLayer();
          if (r.hasListener(e)) {
            const s = new Zs(e, this.inversePixelTransform, n, t);
            r.dispatchEvent(s);
          }
        }
        preRender(e, t) {
          (this.frameState = t),
            !t.declutter && this.dispatchRenderEvent_(Ie.PRERENDER, e, t);
        }
        postRender(e, t) {
          t.declutter || this.dispatchRenderEvent_(Ie.POSTRENDER, e, t);
        }
        renderDeferredInternal(e) {}
        getRenderContext(e) {
          return (
            e.declutter &&
              !this.deferredContext_ &&
              (this.deferredContext_ = new lh()),
            e.declutter ? this.deferredContext_.getContext() : this.context
          );
        }
        renderDeferred(e) {
          e.declutter &&
            (this.dispatchRenderEvent_(Ie.PRERENDER, this.context, e),
            e.declutter &&
              this.deferredContext_ &&
              (this.deferredContext_.draw(this.context),
              this.deferredContext_.clear()),
            this.renderDeferredInternal(e),
            this.dispatchRenderEvent_(Ie.POSTRENDER, this.context, e));
        }
        getRenderTransform(e, t, n, r, s, o, a) {
          const l = s / 2,
            h = o / 2,
            c = r / t,
            u = -c,
            d = -e[0] + a,
            g = -e[1];
          return zt(this.tempTransform, l, h, c, u, -n, d, g);
        }
        disposeInternal() {
          delete this.frameState, super.disposeInternal();
        }
      }
      class uh extends De {
        constructor(e) {
          super(),
            (this.projection = pe(e.projection)),
            (this.attributions_ = Br(e.attributions)),
            (this.attributionsCollapsible_ = e.attributionsCollapsible ?? !0),
            (this.loading = !1),
            (this.state_ = e.state !== void 0 ? e.state : "ready"),
            (this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1),
            (this.interpolate_ = !!e.interpolate),
            (this.viewResolver = null),
            (this.viewRejector = null);
          const t = this;
          this.viewPromise_ = new Promise(function (n, r) {
            (t.viewResolver = n), (t.viewRejector = r);
          });
        }
        getAttributions() {
          return this.attributions_;
        }
        getAttributionsCollapsible() {
          return this.attributionsCollapsible_;
        }
        getProjection() {
          return this.projection;
        }
        getResolutions(e) {
          return null;
        }
        getView() {
          return this.viewPromise_;
        }
        getState() {
          return this.state_;
        }
        getWrapX() {
          return this.wrapX_;
        }
        getInterpolate() {
          return this.interpolate_;
        }
        refresh() {
          this.changed();
        }
        setAttributions(e) {
          (this.attributions_ = Br(e)), this.changed();
        }
        setState(e) {
          (this.state_ = e), this.changed();
        }
      }
      function Br(i) {
        return i
          ? typeof i == "function"
            ? i
            : (Array.isArray(i) || (i = [i]), (e) => i)
          : null;
      }
      const T = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 };
      class qi extends Nn {
        constructor(e, t, n) {
          super(),
            (n = n || {}),
            (this.tileCoord = e),
            (this.state = t),
            (this.key = ""),
            (this.transition_ = n.transition === void 0 ? 250 : n.transition),
            (this.transitionStarts_ = {}),
            (this.interpolate = !!n.interpolate);
        }
        changed() {
          this.dispatchEvent(b.CHANGE);
        }
        release() {
          this.state === T.ERROR && this.setState(T.EMPTY);
        }
        getKey() {
          return this.key + "/" + this.tileCoord;
        }
        getTileCoord() {
          return this.tileCoord;
        }
        getState() {
          return this.state;
        }
        setState(e) {
          if (this.state !== T.ERROR && this.state > e)
            throw new Error("Tile load sequence violation");
          (this.state = e), this.changed();
        }
        load() {
          D();
        }
        getAlpha(e, t) {
          if (!this.transition_) return 1;
          let n = this.transitionStarts_[e];
          if (!n) (n = t), (this.transitionStarts_[e] = n);
          else if (n === -1) return 1;
          const r = t - n + 1e3 / 60;
          return r >= this.transition_ ? 1 : Os(r / this.transition_);
        }
        inTransition(e) {
          return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
        }
        endTransition(e) {
          this.transition_ && (this.transitionStarts_[e] = -1);
        }
        disposeInternal() {
          this.release(), super.disposeInternal();
        }
      }
      class Ks extends qi {
        constructor(e, t, n, r, s, o) {
          super(e, t, o),
            (this.crossOrigin_ = r),
            (this.src_ = n),
            (this.key = n),
            (this.image_ = new Image()),
            r !== null && (this.image_.crossOrigin = r),
            (this.unlisten_ = null),
            (this.tileLoadFunction_ = s);
        }
        getImage() {
          return this.image_;
        }
        setImage(e) {
          (this.image_ = e),
            (this.state = T.LOADED),
            this.unlistenImage_(),
            this.changed();
        }
        handleImageError_() {
          (this.state = T.ERROR),
            this.unlistenImage_(),
            (this.image_ = dh()),
            this.changed();
        }
        handleImageLoad_() {
          const e = this.image_;
          e.naturalWidth && e.naturalHeight
            ? (this.state = T.LOADED)
            : (this.state = T.EMPTY),
            this.unlistenImage_(),
            this.changed();
        }
        load() {
          this.state == T.ERROR &&
            ((this.state = T.IDLE),
            (this.image_ = new Image()),
            this.crossOrigin_ !== null &&
              (this.image_.crossOrigin = this.crossOrigin_)),
            this.state == T.IDLE &&
              ((this.state = T.LOADING),
              this.changed(),
              this.tileLoadFunction_(this, this.src_),
              (this.unlisten_ = Xa(
                this.image_,
                this.handleImageLoad_.bind(this),
                this.handleImageError_.bind(this)
              )));
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), (this.unlisten_ = null));
        }
        disposeInternal() {
          this.unlistenImage_(), (this.image_ = null), super.disposeInternal();
        }
      }
      function dh() {
        const i = ie(1, 1);
        return (
          (i.fillStyle = "rgba(0,0,0,0)"), i.fillRect(0, 0, 1, 1), i.canvas
        );
      }
      class fh {
        constructor(e, t, n) {
          (this.decay_ = e),
            (this.minVelocity_ = t),
            (this.delay_ = n),
            (this.points_ = []),
            (this.angle_ = 0),
            (this.initialVelocity_ = 0);
        }
        begin() {
          (this.points_.length = 0),
            (this.angle_ = 0),
            (this.initialVelocity_ = 0);
        }
        update(e, t) {
          this.points_.push(e, t, Date.now());
        }
        end() {
          if (this.points_.length < 6) return !1;
          const e = Date.now() - this.delay_,
            t = this.points_.length - 3;
          if (this.points_[t + 2] < e) return !1;
          let n = t - 3;
          for (; n > 0 && this.points_[n + 2] > e; ) n -= 3;
          const r = this.points_[t + 2] - this.points_[n + 2];
          if (r < 1e3 / 60) return !1;
          const s = this.points_[t] - this.points_[n],
            o = this.points_[t + 1] - this.points_[n + 1];
          return (
            (this.angle_ = Math.atan2(o, s)),
            (this.initialVelocity_ = Math.sqrt(s * s + o * o) / r),
            this.initialVelocity_ > this.minVelocity_
          );
        }
        getDistance() {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        }
        getAngle() {
          return this.angle_;
        }
      }
      class gh extends Sn {
        constructor(e) {
          super(), (this.map_ = e);
        }
        dispatchRenderEvent(e, t) {
          D();
        }
        calculateMatrices2D(e) {
          const t = e.viewState,
            n = e.coordinateToPixelTransform,
            r = e.pixelToCoordinateTransform;
          zt(
            n,
            e.size[0] / 2,
            e.size[1] / 2,
            1 / t.resolution,
            -1 / t.resolution,
            -t.rotation,
            -t.center[0],
            -t.center[1]
          ),
            ss(r, n);
        }
        forEachFeatureAtCoordinate(e, t, n, r, s, o, a, l) {
          let h;
          const c = t.viewState;
          function u(v, w, A, x) {
            return s.call(o, w, v ? A : null, x);
          }
          const d = c.projection,
            g = jo(e.slice(), d),
            f = [[0, 0]];
          if (d.canWrapX() && r) {
            const v = d.getExtent(),
              w = X(v);
            f.push([-w, 0], [w, 0]);
          }
          const _ = t.layerStatesArray,
            p = _.length,
            E = [],
            y = [];
          for (let v = 0; v < f.length; v++)
            for (let w = p - 1; w >= 0; --w) {
              const A = _[w],
                x = A.layer;
              if (x.hasRenderer() && Ui(A, c) && a.call(l, x)) {
                const C = x.getRenderer(),
                  I = x.getSource();
                if (C && I) {
                  const Z = I.getWrapX() ? g : e,
                    W = u.bind(null, A.managed);
                  (y[0] = Z[0] + f[v][0]),
                    (y[1] = Z[1] + f[v][1]),
                    (h = C.forEachFeatureAtCoordinate(y, t, n, W, E));
                }
                if (h) return h;
              }
            }
          if (E.length === 0) return;
          const R = 1 / E.length;
          return (
            E.forEach((v, w) => (v.distanceSq += w * R)),
            E.sort((v, w) => v.distanceSq - w.distanceSq),
            E.some((v) => (h = v.callback(v.feature, v.layer, v.geometry))),
            h
          );
        }
        hasFeatureAtCoordinate(e, t, n, r, s, o) {
          return (
            this.forEachFeatureAtCoordinate(e, t, n, r, wn, this, s, o) !==
            void 0
          );
        }
        getMap() {
          return this.map_;
        }
        renderFrame(e) {
          D();
        }
        scheduleExpireIconCache(e) {
          Ae.canExpireCache() && e.postRenderFunctions.push(_h);
        }
      }
      function _h(i, e) {
        Ae.expire();
      }
      class mh extends gh {
        constructor(e) {
          super(e),
            (this.fontChangeListenerKey_ = N(
              qa,
              Nt.PROPERTYCHANGE,
              e.redrawText,
              e
            )),
            (this.element_ = document.createElement("div"));
          const t = this.element_.style;
          (t.position = "absolute"),
            (t.width = "100%"),
            (t.height = "100%"),
            (t.zIndex = "0"),
            (this.element_.className = Zn + " ol-layers");
          const n = e.getViewport();
          n.insertBefore(this.element_, n.firstChild || null),
            (this.children_ = []),
            (this.renderedVisible_ = !0);
        }
        dispatchRenderEvent(e, t) {
          const n = this.getMap();
          if (n.hasListener(e)) {
            const r = new Zs(e, void 0, t);
            n.dispatchEvent(r);
          }
        }
        disposeInternal() {
          V(this.fontChangeListenerKey_),
            this.element_.remove(),
            super.disposeInternal();
        }
        renderFrame(e) {
          if (!e) {
            this.renderedVisible_ &&
              ((this.element_.style.display = "none"),
              (this.renderedVisible_ = !1));
            return;
          }
          this.calculateMatrices2D(e),
            this.dispatchRenderEvent(Ie.PRECOMPOSE, e);
          const t = e.layerStatesArray.sort((a, l) => a.zIndex - l.zIndex);
          t.some((a) => a.layer instanceof rh && a.layer.getDeclutter()) &&
            (e.declutter = {});
          const r = e.viewState;
          this.children_.length = 0;
          const s = [];
          let o = null;
          for (let a = 0, l = t.length; a < l; ++a) {
            const h = t[a];
            e.layerIndex = a;
            const c = h.layer,
              u = c.getSourceState();
            if (!Ui(h, r) || (u != "ready" && u != "undefined")) {
              c.unrender();
              continue;
            }
            const d = c.render(e, o);
            d && (d !== o && (this.children_.push(d), (o = d)), s.push(h));
          }
          this.declutter(e, s),
            Ga(this.element_, this.children_),
            this.dispatchRenderEvent(Ie.POSTCOMPOSE, e),
            this.renderedVisible_ ||
              ((this.element_.style.display = ""),
              (this.renderedVisible_ = !0)),
            this.scheduleExpireIconCache(e);
        }
        declutter(e, t) {
          if (e.declutter) {
            for (let n = t.length - 1; n >= 0; --n) {
              const r = t[n],
                s = r.layer;
              s.getDeclutter() && s.renderDeclutter(e, r);
            }
            t.forEach((n) => n.layer.renderDeferred(e));
          }
        }
      }
      class Ve extends je {
        constructor(e, t) {
          super(e), (this.layer = t);
        }
      }
      const oi = { LAYERS: "layers" };
      class Tt extends Ps {
        constructor(e) {
          e = e || {};
          const t = Object.assign({}, e);
          delete t.layers;
          let n = e.layers;
          super(t),
            this.on,
            this.once,
            this.un,
            (this.layersListenerKeys_ = []),
            (this.listenerKeys_ = {}),
            this.addChangeListener(oi.LAYERS, this.handleLayersChanged_),
            n
              ? Array.isArray(n)
                ? (n = new Pe(n.slice(), { unique: !0 }))
                : G(
                    typeof n.getArray == "function",
                    "Expected `layers` to be an array or a `Collection`"
                  )
              : (n = new Pe(void 0, { unique: !0 })),
            this.setLayers(n);
        }
        handleLayerChange_() {
          this.changed();
        }
        handleLayersChanged_() {
          this.layersListenerKeys_.forEach(V),
            (this.layersListenerKeys_.length = 0);
          const e = this.getLayers();
          this.layersListenerKeys_.push(
            N(e, me.ADD, this.handleLayersAdd_, this),
            N(e, me.REMOVE, this.handleLayersRemove_, this)
          );
          for (const n in this.listenerKeys_) this.listenerKeys_[n].forEach(V);
          Fn(this.listenerKeys_);
          const t = e.getArray();
          for (let n = 0, r = t.length; n < r; n++) {
            const s = t[n];
            this.registerLayerListeners_(s),
              this.dispatchEvent(new Ve("addlayer", s));
          }
          this.changed();
        }
        registerLayerListeners_(e) {
          const t = [
            N(e, Nt.PROPERTYCHANGE, this.handleLayerChange_, this),
            N(e, b.CHANGE, this.handleLayerChange_, this),
          ];
          e instanceof Tt &&
            t.push(
              N(e, "addlayer", this.handleLayerGroupAdd_, this),
              N(e, "removelayer", this.handleLayerGroupRemove_, this)
            ),
            (this.listenerKeys_[re(e)] = t);
        }
        handleLayerGroupAdd_(e) {
          this.dispatchEvent(new Ve("addlayer", e.layer));
        }
        handleLayerGroupRemove_(e) {
          this.dispatchEvent(new Ve("removelayer", e.layer));
        }
        handleLayersAdd_(e) {
          const t = e.element;
          this.registerLayerListeners_(t),
            this.dispatchEvent(new Ve("addlayer", t)),
            this.changed();
        }
        handleLayersRemove_(e) {
          const t = e.element,
            n = re(t);
          this.listenerKeys_[n].forEach(V),
            delete this.listenerKeys_[n],
            this.dispatchEvent(new Ve("removelayer", t)),
            this.changed();
        }
        getLayers() {
          return this.get(oi.LAYERS);
        }
        setLayers(e) {
          const t = this.getLayers();
          if (t) {
            const n = t.getArray();
            for (let r = 0, s = n.length; r < s; ++r)
              this.dispatchEvent(new Ve("removelayer", n[r]));
          }
          this.set(oi.LAYERS, e);
        }
        getLayersArray(e) {
          return (
            (e = e !== void 0 ? e : []),
            this.getLayers().forEach(function (t) {
              t.getLayersArray(e);
            }),
            e
          );
        }
        getLayerStatesArray(e) {
          const t = e !== void 0 ? e : [],
            n = t.length;
          this.getLayers().forEach(function (o) {
            o.getLayerStatesArray(t);
          });
          const r = this.getLayerState();
          let s = r.zIndex;
          !e && r.zIndex === void 0 && (s = 0);
          for (let o = n, a = t.length; o < a; o++) {
            const l = t[o];
            (l.opacity *= r.opacity),
              (l.visible = l.visible && r.visible),
              (l.maxResolution = Math.min(l.maxResolution, r.maxResolution)),
              (l.minResolution = Math.max(l.minResolution, r.minResolution)),
              (l.minZoom = Math.max(l.minZoom, r.minZoom)),
              (l.maxZoom = Math.min(l.maxZoom, r.maxZoom)),
              r.extent !== void 0 &&
                (l.extent !== void 0
                  ? (l.extent = Re(l.extent, r.extent))
                  : (l.extent = r.extent)),
              l.zIndex === void 0 && (l.zIndex = s);
          }
          return t;
        }
        getSourceState() {
          return "ready";
        }
      }
      class _t extends je {
        constructor(e, t, n) {
          super(e), (this.map = t), (this.frameState = n !== void 0 ? n : null);
        }
      }
      class Ze extends _t {
        constructor(e, t, n, r, s, o) {
          super(e, t, s),
            (this.originalEvent = n),
            (this.pixel_ = null),
            (this.coordinate_ = null),
            (this.dragging = r !== void 0 ? r : !1),
            (this.activePointers = o);
        }
        get pixel() {
          return (
            this.pixel_ ||
              (this.pixel_ = this.map.getEventPixel(this.originalEvent)),
            this.pixel_
          );
        }
        set pixel(e) {
          this.pixel_ = e;
        }
        get coordinate() {
          return (
            this.coordinate_ ||
              (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)),
            this.coordinate_
          );
        }
        set coordinate(e) {
          this.coordinate_ = e;
        }
        preventDefault() {
          super.preventDefault(),
            "preventDefault" in this.originalEvent &&
              this.originalEvent.preventDefault();
        }
        stopPropagation() {
          super.stopPropagation(),
            "stopPropagation" in this.originalEvent &&
              this.originalEvent.stopPropagation();
        }
      }
      const U = {
          SINGLECLICK: "singleclick",
          CLICK: b.CLICK,
          DBLCLICK: b.DBLCLICK,
          POINTERDRAG: "pointerdrag",
          POINTERMOVE: "pointermove",
          POINTERDOWN: "pointerdown",
          POINTERUP: "pointerup",
          POINTEROVER: "pointerover",
          POINTEROUT: "pointerout",
          POINTERENTER: "pointerenter",
          POINTERLEAVE: "pointerleave",
          POINTERCANCEL: "pointercancel",
        },
        wi = {
          POINTERMOVE: "pointermove",
          POINTERDOWN: "pointerdown",
          POINTERUP: "pointerup",
          POINTEROVER: "pointerover",
          POINTEROUT: "pointerout",
          POINTERENTER: "pointerenter",
          POINTERLEAVE: "pointerleave",
          POINTERCANCEL: "pointercancel",
        };
      class ph extends Nn {
        constructor(e, t) {
          super(e),
            (this.map_ = e),
            this.clickTimeoutId_,
            (this.emulateClicks_ = !1),
            (this.dragging_ = !1),
            (this.dragListenerKeys_ = []),
            (this.moveTolerance_ = t === void 0 ? 1 : t),
            (this.down_ = null);
          const n = this.map_.getViewport();
          (this.activePointers_ = []),
            (this.trackedTouches_ = {}),
            (this.element_ = n),
            (this.pointerdownListenerKey_ = N(
              n,
              wi.POINTERDOWN,
              this.handlePointerDown_,
              this
            )),
            this.originalPointerMoveEvent_,
            (this.relayedListenerKey_ = N(
              n,
              wi.POINTERMOVE,
              this.relayMoveEvent_,
              this
            )),
            (this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this)),
            this.element_.addEventListener(
              b.TOUCHMOVE,
              this.boundHandleTouchMove_,
              bs ? { passive: !1 } : !1
            );
        }
        emulateClick_(e) {
          let t = new Ze(U.CLICK, this.map_, e);
          this.dispatchEvent(t),
            this.clickTimeoutId_ !== void 0
              ? (clearTimeout(this.clickTimeoutId_),
                (this.clickTimeoutId_ = void 0),
                (t = new Ze(U.DBLCLICK, this.map_, e)),
                this.dispatchEvent(t))
              : (this.clickTimeoutId_ = setTimeout(() => {
                  this.clickTimeoutId_ = void 0;
                  const n = new Ze(U.SINGLECLICK, this.map_, e);
                  this.dispatchEvent(n);
                }, 250));
        }
        updateActivePointers_(e) {
          const t = e,
            n = t.pointerId;
          if (t.type == U.POINTERUP || t.type == U.POINTERCANCEL) {
            delete this.trackedTouches_[n];
            for (const r in this.trackedTouches_)
              if (this.trackedTouches_[r].target !== t.target) {
                delete this.trackedTouches_[r];
                break;
              }
          } else
            (t.type == U.POINTERDOWN || t.type == U.POINTERMOVE) &&
              (this.trackedTouches_[n] = t);
          this.activePointers_ = Object.values(this.trackedTouches_);
        }
        handlePointerUp_(e) {
          this.updateActivePointers_(e);
          const t = new Ze(
            U.POINTERUP,
            this.map_,
            e,
            void 0,
            void 0,
            this.activePointers_
          );
          this.dispatchEvent(t),
            this.emulateClicks_ &&
              !t.defaultPrevented &&
              !this.dragging_ &&
              this.isMouseActionButton_(e) &&
              this.emulateClick_(this.down_),
            this.activePointers_.length === 0 &&
              (this.dragListenerKeys_.forEach(V),
              (this.dragListenerKeys_.length = 0),
              (this.dragging_ = !1),
              (this.down_ = null));
        }
        isMouseActionButton_(e) {
          return e.button === 0;
        }
        handlePointerDown_(e) {
          (this.emulateClicks_ = this.activePointers_.length === 0),
            this.updateActivePointers_(e);
          const t = new Ze(
            U.POINTERDOWN,
            this.map_,
            e,
            void 0,
            void 0,
            this.activePointers_
          );
          if (
            (this.dispatchEvent(t),
            (this.down_ = new PointerEvent(e.type, e)),
            Object.defineProperty(this.down_, "target", {
              writable: !1,
              value: e.target,
            }),
            this.dragListenerKeys_.length === 0)
          ) {
            const n = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(
              N(n, U.POINTERMOVE, this.handlePointerMove_, this),
              N(n, U.POINTERUP, this.handlePointerUp_, this),
              N(this.element_, U.POINTERCANCEL, this.handlePointerUp_, this)
            ),
              this.element_.getRootNode &&
                this.element_.getRootNode() !== n &&
                this.dragListenerKeys_.push(
                  N(
                    this.element_.getRootNode(),
                    U.POINTERUP,
                    this.handlePointerUp_,
                    this
                  )
                );
          }
        }
        handlePointerMove_(e) {
          if (this.isMoving_(e)) {
            this.updateActivePointers_(e), (this.dragging_ = !0);
            const t = new Ze(
              U.POINTERDRAG,
              this.map_,
              e,
              this.dragging_,
              void 0,
              this.activePointers_
            );
            this.dispatchEvent(t);
          }
        }
        relayMoveEvent_(e) {
          this.originalPointerMoveEvent_ = e;
          const t = !!(this.down_ && this.isMoving_(e));
          this.dispatchEvent(new Ze(U.POINTERMOVE, this.map_, e, t));
        }
        handleTouchMove_(e) {
          const t = this.originalPointerMoveEvent_;
          (!t || t.defaultPrevented) &&
            (typeof e.cancelable != "boolean" || e.cancelable === !0) &&
            e.preventDefault();
        }
        isMoving_(e) {
          return (
            this.dragging_ ||
            Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ ||
            Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_
          );
        }
        disposeInternal() {
          this.relayedListenerKey_ &&
            (V(this.relayedListenerKey_), (this.relayedListenerKey_ = null)),
            this.element_.removeEventListener(
              b.TOUCHMOVE,
              this.boundHandleTouchMove_
            ),
            this.pointerdownListenerKey_ &&
              (V(this.pointerdownListenerKey_),
              (this.pointerdownListenerKey_ = null)),
            this.dragListenerKeys_.forEach(V),
            (this.dragListenerKeys_.length = 0),
            (this.element_ = null),
            super.disposeInternal();
        }
      }
      const Ke = {
          POSTRENDER: "postrender",
          MOVESTART: "movestart",
          MOVEEND: "moveend",
          LOADSTART: "loadstart",
          LOADEND: "loadend",
        },
        ne = {
          LAYERGROUP: "layergroup",
          SIZE: "size",
          TARGET: "target",
          VIEW: "view",
        },
        Mn = 1 / 0;
      class yh {
        constructor(e, t) {
          (this.priorityFunction_ = e),
            (this.keyFunction_ = t),
            (this.elements_ = []),
            (this.priorities_ = []),
            (this.queuedElements_ = {});
        }
        clear() {
          (this.elements_.length = 0),
            (this.priorities_.length = 0),
            Fn(this.queuedElements_);
        }
        dequeue() {
          const e = this.elements_,
            t = this.priorities_,
            n = e[0];
          e.length == 1
            ? ((e.length = 0), (t.length = 0))
            : ((e[0] = e.pop()), (t[0] = t.pop()), this.siftUp_(0));
          const r = this.keyFunction_(n);
          return delete this.queuedElements_[r], n;
        }
        enqueue(e) {
          G(
            !(this.keyFunction_(e) in this.queuedElements_),
            "Tried to enqueue an `element` that was already added to the queue"
          );
          const t = this.priorityFunction_(e);
          return t != Mn
            ? (this.elements_.push(e),
              this.priorities_.push(t),
              (this.queuedElements_[this.keyFunction_(e)] = !0),
              this.siftDown_(0, this.elements_.length - 1),
              !0)
            : !1;
        }
        getCount() {
          return this.elements_.length;
        }
        getLeftChildIndex_(e) {
          return e * 2 + 1;
        }
        getRightChildIndex_(e) {
          return e * 2 + 2;
        }
        getParentIndex_(e) {
          return (e - 1) >> 1;
        }
        heapify_() {
          let e;
          for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
            this.siftUp_(e);
        }
        isEmpty() {
          return this.elements_.length === 0;
        }
        isKeyQueued(e) {
          return e in this.queuedElements_;
        }
        isQueued(e) {
          return this.isKeyQueued(this.keyFunction_(e));
        }
        siftUp_(e) {
          const t = this.elements_,
            n = this.priorities_,
            r = t.length,
            s = t[e],
            o = n[e],
            a = e;
          for (; e < r >> 1; ) {
            const l = this.getLeftChildIndex_(e),
              h = this.getRightChildIndex_(e),
              c = h < r && n[h] < n[l] ? h : l;
            (t[e] = t[c]), (n[e] = n[c]), (e = c);
          }
          (t[e] = s), (n[e] = o), this.siftDown_(a, e);
        }
        siftDown_(e, t) {
          const n = this.elements_,
            r = this.priorities_,
            s = n[t],
            o = r[t];
          for (; t > e; ) {
            const a = this.getParentIndex_(t);
            if (r[a] > o) (n[t] = n[a]), (r[t] = r[a]), (t = a);
            else break;
          }
          (n[t] = s), (r[t] = o);
        }
        reprioritize() {
          const e = this.priorityFunction_,
            t = this.elements_,
            n = this.priorities_;
          let r = 0;
          const s = t.length;
          let o, a, l;
          for (a = 0; a < s; ++a)
            (o = t[a]),
              (l = e(o)),
              l == Mn
                ? delete this.queuedElements_[this.keyFunction_(o)]
                : ((n[r] = l), (t[r++] = o));
          (t.length = r), (n.length = r), this.heapify_();
        }
      }
      class Eh extends yh {
        constructor(e, t) {
          super(
            function (n) {
              return e.apply(null, n);
            },
            function (n) {
              return n[0].getKey();
            }
          ),
            (this.boundHandleTileChange_ = this.handleTileChange.bind(this)),
            (this.tileChangeCallback_ = t),
            (this.tilesLoading_ = 0),
            (this.tilesLoadingKeys_ = {});
        }
        enqueue(e) {
          const t = super.enqueue(e);
          return (
            t && e[0].addEventListener(b.CHANGE, this.boundHandleTileChange_), t
          );
        }
        getTilesLoading() {
          return this.tilesLoading_;
        }
        handleTileChange(e) {
          const t = e.target,
            n = t.getState();
          if (n === T.LOADED || n === T.ERROR || n === T.EMPTY) {
            n !== T.ERROR &&
              t.removeEventListener(b.CHANGE, this.boundHandleTileChange_);
            const r = t.getKey();
            r in this.tilesLoadingKeys_ &&
              (delete this.tilesLoadingKeys_[r], --this.tilesLoading_),
              this.tileChangeCallback_();
          }
        }
        loadMoreTiles(e, t) {
          let n = 0;
          for (; this.tilesLoading_ < e && n < t && this.getCount() > 0; ) {
            const r = this.dequeue()[0],
              s = r.getKey();
            r.getState() === T.IDLE &&
              !(s in this.tilesLoadingKeys_) &&
              ((this.tilesLoadingKeys_[s] = !0),
              ++this.tilesLoading_,
              ++n,
              r.load());
          }
        }
      }
      function wh(i, e, t, n, r) {
        if (!i || !(t in i.wantedTiles) || !i.wantedTiles[t][e.getKey()])
          return Mn;
        const s = i.viewState.center,
          o = n[0] - s[0],
          a = n[1] - s[1];
        return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r;
      }
      class $i extends De {
        constructor(e) {
          super();
          const t = e.element;
          t &&
            !e.target &&
            !t.style.pointerEvents &&
            (t.style.pointerEvents = "auto"),
            (this.element = t || null),
            (this.target_ = null),
            (this.map_ = null),
            (this.listenerKeys = []),
            e.render && (this.render = e.render),
            e.target && this.setTarget(e.target);
        }
        disposeInternal() {
          var e;
          (e = this.element) == null || e.remove(), super.disposeInternal();
        }
        getMap() {
          return this.map_;
        }
        setMap(e) {
          var t;
          this.map_ && ((t = this.element) == null || t.remove());
          for (let n = 0, r = this.listenerKeys.length; n < r; ++n)
            V(this.listenerKeys[n]);
          (this.listenerKeys.length = 0),
            (this.map_ = e),
            e &&
              ((this.target_ ?? e.getOverlayContainerStopEvent()).appendChild(
                this.element
              ),
              this.render !== vn &&
                this.listenerKeys.push(N(e, Ke.POSTRENDER, this.render, this)),
              e.render());
        }
        render(e) {}
        setTarget(e) {
          this.target_ = typeof e == "string" ? document.getElementById(e) : e;
        }
      }
      class vh extends $i {
        constructor(e) {
          (e = e || {}),
            super({
              element: document.createElement("div"),
              render: e.render,
              target: e.target,
            }),
            (this.ulElement_ = document.createElement("ul")),
            (this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0),
            (this.userCollapsed_ = this.collapsed_),
            (this.overrideCollapsible_ = e.collapsible !== void 0),
            (this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0),
            this.collapsible_ || (this.collapsed_ = !1),
            (this.attributions_ = e.attributions);
          const t = e.className !== void 0 ? e.className : "ol-attribution",
            n = e.tipLabel !== void 0 ? e.tipLabel : "Attributions",
            r =
              e.expandClassName !== void 0 ? e.expandClassName : t + "-expand",
            s = e.collapseLabel !== void 0 ? e.collapseLabel : "›",
            o =
              e.collapseClassName !== void 0
                ? e.collapseClassName
                : t + "-collapse";
          typeof s == "string"
            ? ((this.collapseLabel_ = document.createElement("span")),
              (this.collapseLabel_.textContent = s),
              (this.collapseLabel_.className = o))
            : (this.collapseLabel_ = s);
          const a = e.label !== void 0 ? e.label : "i";
          typeof a == "string"
            ? ((this.label_ = document.createElement("span")),
              (this.label_.textContent = a),
              (this.label_.className = r))
            : (this.label_ = a);
          const l =
            this.collapsible_ && !this.collapsed_
              ? this.collapseLabel_
              : this.label_;
          (this.toggleButton_ = document.createElement("button")),
            this.toggleButton_.setAttribute("type", "button"),
            this.toggleButton_.setAttribute(
              "aria-expanded",
              String(!this.collapsed_)
            ),
            (this.toggleButton_.title = n),
            this.toggleButton_.appendChild(l),
            this.toggleButton_.addEventListener(
              b.CLICK,
              this.handleClick_.bind(this),
              !1
            );
          const h =
              t +
              " " +
              Zn +
              " " +
              Xi +
              (this.collapsed_ && this.collapsible_ ? " " + br : "") +
              (this.collapsible_ ? "" : " ol-uncollapsible"),
            c = this.element;
          (c.className = h),
            c.appendChild(this.toggleButton_),
            c.appendChild(this.ulElement_),
            (this.renderedAttributions_ = []),
            (this.renderedVisible_ = !0);
        }
        collectSourceAttributions_(e) {
          const t = this.getMap().getAllLayers(),
            n = new Set(t.flatMap((r) => r.getAttributions(e)));
          if (
            (this.attributions_ !== void 0 &&
              (Array.isArray(this.attributions_)
                ? this.attributions_.forEach((r) => n.add(r))
                : n.add(this.attributions_)),
            !this.overrideCollapsible_)
          ) {
            const r = !t.some((s) => {
              var o;
              return (
                ((o = s.getSource()) == null
                  ? void 0
                  : o.getAttributionsCollapsible()) === !1
              );
            });
            this.setCollapsible(r);
          }
          return Array.from(n);
        }
        async updateElement_(e) {
          if (!e) {
            this.renderedVisible_ &&
              ((this.element.style.display = "none"),
              (this.renderedVisible_ = !1));
            return;
          }
          const t = await Promise.all(
              this.collectSourceAttributions_(e).map((r) => _o(() => r))
            ),
            n = t.length > 0;
          if (
            (this.renderedVisible_ != n &&
              ((this.element.style.display = n ? "" : "none"),
              (this.renderedVisible_ = n)),
            !On(t, this.renderedAttributions_))
          ) {
            ka(this.ulElement_);
            for (let r = 0, s = t.length; r < s; ++r) {
              const o = document.createElement("li");
              (o.innerHTML = t[r]), this.ulElement_.appendChild(o);
            }
            this.renderedAttributions_ = t;
          }
        }
        handleClick_(e) {
          e.preventDefault(),
            this.handleToggle_(),
            (this.userCollapsed_ = this.collapsed_);
        }
        handleToggle_() {
          this.element.classList.toggle(br),
            this.collapsed_
              ? Ar(this.collapseLabel_, this.label_)
              : Ar(this.label_, this.collapseLabel_),
            (this.collapsed_ = !this.collapsed_),
            this.toggleButton_.setAttribute(
              "aria-expanded",
              String(!this.collapsed_)
            );
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(e) {
          this.collapsible_ !== e &&
            ((this.collapsible_ = e),
            this.element.classList.toggle("ol-uncollapsible"),
            this.userCollapsed_ && this.handleToggle_());
        }
        setCollapsed(e) {
          (this.userCollapsed_ = e),
            !(!this.collapsible_ || this.collapsed_ === e) &&
              this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        render(e) {
          this.updateElement_(e.frameState);
        }
      }
      class Rh extends $i {
        constructor(e) {
          (e = e || {}),
            super({
              element: document.createElement("div"),
              render: e.render,
              target: e.target,
            });
          const t = e.className !== void 0 ? e.className : "ol-rotate",
            n = e.label !== void 0 ? e.label : "⇧",
            r =
              e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
          (this.label_ = null),
            typeof n == "string"
              ? ((this.label_ = document.createElement("span")),
                (this.label_.className = r),
                (this.label_.textContent = n))
              : ((this.label_ = n), this.label_.classList.add(r));
          const s = e.tipLabel ? e.tipLabel : "Reset rotation",
            o = document.createElement("button");
          (o.className = t + "-reset"),
            o.setAttribute("type", "button"),
            (o.title = s),
            o.appendChild(this.label_),
            o.addEventListener(b.CLICK, this.handleClick_.bind(this), !1);
          const a = t + " " + Zn + " " + Xi,
            l = this.element;
          (l.className = a),
            l.appendChild(o),
            (this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250),
            (this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0),
            (this.rotation_ = void 0),
            this.autoHide_ && this.element.classList.add(un);
        }
        handleClick_(e) {
          e.preventDefault(),
            this.callResetNorth_ !== void 0
              ? this.callResetNorth_()
              : this.resetNorth_();
        }
        resetNorth_() {
          const t = this.getMap().getView();
          if (!t) return;
          const n = t.getRotation();
          n !== void 0 &&
            (this.duration_ > 0 && n % (2 * Math.PI) !== 0
              ? t.animate({ rotation: 0, duration: this.duration_, easing: Ct })
              : t.setRotation(0));
        }
        render(e) {
          const t = e.frameState;
          if (!t) return;
          const n = t.viewState.rotation;
          if (n != this.rotation_) {
            const r = "rotate(" + n + "rad)";
            if (this.autoHide_) {
              const s = this.element.classList.contains(un);
              !s && n === 0
                ? this.element.classList.add(un)
                : s && n !== 0 && this.element.classList.remove(un);
            }
            this.label_.style.transform = r;
          }
          this.rotation_ = n;
        }
      }
      class Ch extends $i {
        constructor(e) {
          (e = e || {}),
            super({ element: document.createElement("div"), target: e.target });
          const t = e.className !== void 0 ? e.className : "ol-zoom",
            n = e.delta !== void 0 ? e.delta : 1,
            r = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in",
            s = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out",
            o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+",
            a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–",
            l = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in",
            h = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out",
            c = document.createElement("button");
          (c.className = r),
            c.setAttribute("type", "button"),
            (c.title = l),
            c.appendChild(
              typeof o == "string" ? document.createTextNode(o) : o
            ),
            c.addEventListener(b.CLICK, this.handleClick_.bind(this, n), !1);
          const u = document.createElement("button");
          (u.className = s),
            u.setAttribute("type", "button"),
            (u.title = h),
            u.appendChild(
              typeof a == "string" ? document.createTextNode(a) : a
            ),
            u.addEventListener(b.CLICK, this.handleClick_.bind(this, -n), !1);
          const d = t + " " + Zn + " " + Xi,
            g = this.element;
          (g.className = d),
            g.appendChild(c),
            g.appendChild(u),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250);
        }
        handleClick_(e, t) {
          t.preventDefault(), this.zoomByDelta_(e);
        }
        zoomByDelta_(e) {
          const n = this.getMap().getView();
          if (!n) return;
          const r = n.getZoom();
          if (r !== void 0) {
            const s = n.getConstrainedZoom(r + e);
            this.duration_ > 0
              ? (n.getAnimating() && n.cancelAnimations(),
                n.animate({ zoom: s, duration: this.duration_, easing: Ct }))
              : n.setZoom(s);
          }
        }
      }
      function Th(i) {
        i = i || {};
        const e = new Pe();
        return (
          (i.zoom !== void 0 ? i.zoom : !0) && e.push(new Ch(i.zoomOptions)),
          (i.rotate !== void 0 ? i.rotate : !0) &&
            e.push(new Rh(i.rotateOptions)),
          (i.attribution !== void 0 ? i.attribution : !0) &&
            e.push(new vh(i.attributionOptions)),
          e
        );
      }
      const Hr = { ACTIVE: "active" };
      class tn extends De {
        constructor(e) {
          super(),
            this.on,
            this.once,
            this.un,
            e && e.handleEvent && (this.handleEvent = e.handleEvent),
            (this.map_ = null),
            this.setActive(!0);
        }
        getActive() {
          return this.get(Hr.ACTIVE);
        }
        getMap() {
          return this.map_;
        }
        handleEvent(e) {
          return !0;
        }
        setActive(e) {
          this.set(Hr.ACTIVE, e);
        }
        setMap(e) {
          this.map_ = e;
        }
      }
      function xh(i, e, t) {
        const n = i.getCenterInternal();
        if (n) {
          const r = [n[0] + e[0], n[1] + e[1]];
          i.animateInternal({
            duration: t !== void 0 ? t : 250,
            easing: ol,
            center: i.getConstrainedCenter(r),
          });
        }
      }
      function Ji(i, e, t, n) {
        const r = i.getZoom();
        if (r === void 0) return;
        const s = i.getConstrainedZoom(r + e),
          o = i.getResolutionForZoom(s);
        i.getAnimating() && i.cancelAnimations(),
          i.animate({
            resolution: o,
            anchor: t,
            duration: n !== void 0 ? n : 250,
            easing: Ct,
          });
      }
      class Ih extends tn {
        constructor(e) {
          super(),
            (e = e || {}),
            (this.delta_ = e.delta ? e.delta : 1),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250);
        }
        handleEvent(e) {
          let t = !1;
          if (e.type == U.DBLCLICK) {
            const n = e.originalEvent,
              r = e.map,
              s = e.coordinate,
              o = n.shiftKey ? -this.delta_ : this.delta_,
              a = r.getView();
            Ji(a, o, s, this.duration_), n.preventDefault(), (t = !0);
          }
          return !t;
        }
      }
      class nn extends tn {
        constructor(e) {
          (e = e || {}),
            super(e),
            e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent),
            e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent),
            e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent),
            e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent),
            e.stopDown && (this.stopDown = e.stopDown),
            (this.handlingDownUpSequence = !1),
            (this.targetPointers = []);
        }
        getPointerCount() {
          return this.targetPointers.length;
        }
        handleDownEvent(e) {
          return !1;
        }
        handleDragEvent(e) {}
        handleEvent(e) {
          if (!e.originalEvent) return !0;
          let t = !1;
          if ((this.updateTrackedPointers_(e), this.handlingDownUpSequence)) {
            if (e.type == U.POINTERDRAG)
              this.handleDragEvent(e), e.originalEvent.preventDefault();
            else if (e.type == U.POINTERUP) {
              const n = this.handleUpEvent(e);
              this.handlingDownUpSequence = n && this.targetPointers.length > 0;
            }
          } else if (e.type == U.POINTERDOWN) {
            const n = this.handleDownEvent(e);
            (this.handlingDownUpSequence = n), (t = this.stopDown(n));
          } else e.type == U.POINTERMOVE && this.handleMoveEvent(e);
          return !t;
        }
        handleMoveEvent(e) {}
        handleUpEvent(e) {
          return !1;
        }
        stopDown(e) {
          return e;
        }
        updateTrackedPointers_(e) {
          e.activePointers && (this.targetPointers = e.activePointers);
        }
      }
      function Qi(i) {
        const e = i.length;
        let t = 0,
          n = 0;
        for (let r = 0; r < e; r++) (t += i[r].clientX), (n += i[r].clientY);
        return { clientX: t / e, clientY: n / e };
      }
      function vi(i) {
        const e = arguments;
        return function (t) {
          let n = !0;
          for (
            let r = 0, s = e.length;
            r < s && ((n = n && e[r](t)), !!n);
            ++r
          );
          return n;
        };
      }
      const Ah = function (i) {
          const e = i.originalEvent;
          return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
        },
        Mh = function (i) {
          const e = i.map.getTargetElement(),
            t = e.getRootNode(),
            n = i.map.getOwnerDocument().activeElement;
          return t instanceof ShadowRoot ? t.host.contains(n) : e.contains(n);
        },
        Vs = function (i) {
          const e = i.map.getTargetElement(),
            t = e.getRootNode();
          return (t instanceof ShadowRoot ? t.host : e).hasAttribute("tabindex")
            ? Mh(i)
            : !0;
        },
        Lh = wn,
        Ws = function (i) {
          const e = i.originalEvent;
          return e.button == 0 && !(Na && As && e.ctrlKey);
        },
        Us = function (i) {
          const e = i.originalEvent;
          return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
        },
        bh = function (i) {
          const e = i.originalEvent;
          return As ? e.metaKey : e.ctrlKey;
        },
        Sh = function (i) {
          const e = i.originalEvent;
          return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
        },
        js = function (i) {
          const e = i.originalEvent,
            t = e.target.tagName;
          return (
            t !== "INPUT" &&
            t !== "SELECT" &&
            t !== "TEXTAREA" &&
            !e.target.isContentEditable
          );
        },
        ai = function (i) {
          const e = i.originalEvent;
          return (
            G(
              e !== void 0,
              "mapBrowserEvent must originate from a pointer event"
            ),
            e.pointerType == "mouse"
          );
        },
        Ph = function (i) {
          const e = i.originalEvent;
          return (
            G(
              e !== void 0,
              "mapBrowserEvent must originate from a pointer event"
            ),
            e.isPrimary && e.button === 0
          );
        };
      class Bs extends nn {
        constructor(e) {
          super({ stopDown: Dn }),
            (e = e || {}),
            (this.kinetic_ = e.kinetic),
            (this.lastCentroid = null),
            this.lastPointersCount_,
            (this.panning_ = !1);
          const t = e.condition ? e.condition : vi(Us, Ph);
          (this.condition_ = e.onFocusOnly ? vi(Vs, t) : t),
            (this.noKinetic_ = !1);
        }
        handleDragEvent(e) {
          const t = e.map;
          this.panning_ ||
            ((this.panning_ = !0), t.getView().beginInteraction());
          const n = this.targetPointers,
            r = t.getEventPixel(Qi(n));
          if (n.length == this.lastPointersCount_) {
            if (
              (this.kinetic_ && this.kinetic_.update(r[0], r[1]),
              this.lastCentroid)
            ) {
              const s = [
                  this.lastCentroid[0] - r[0],
                  r[1] - this.lastCentroid[1],
                ],
                a = e.map.getView();
              Uo(s, a.getResolution()),
                Mi(s, a.getRotation()),
                a.adjustCenterInternal(s);
            }
          } else this.kinetic_ && this.kinetic_.begin();
          (this.lastCentroid = r),
            (this.lastPointersCount_ = n.length),
            e.originalEvent.preventDefault();
        }
        handleUpEvent(e) {
          const t = e.map,
            n = t.getView();
          if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
              const r = this.kinetic_.getDistance(),
                s = this.kinetic_.getAngle(),
                o = n.getCenterInternal(),
                a = t.getPixelFromCoordinateInternal(o),
                l = t.getCoordinateFromPixelInternal([
                  a[0] - r * Math.cos(s),
                  a[1] - r * Math.sin(s),
                ]);
              n.animateInternal({
                center: n.getConstrainedCenter(l),
                duration: 500,
                easing: Ct,
              });
            }
            return (
              this.panning_ && ((this.panning_ = !1), n.endInteraction()), !1
            );
          }
          return (
            this.kinetic_ && this.kinetic_.begin(),
            (this.lastCentroid = null),
            !0
          );
        }
        handleDownEvent(e) {
          if (this.targetPointers.length > 0 && this.condition_(e)) {
            const n = e.map.getView();
            return (
              (this.lastCentroid = null),
              n.getAnimating() && n.cancelAnimations(),
              this.kinetic_ && this.kinetic_.begin(),
              (this.noKinetic_ = this.targetPointers.length > 1),
              !0
            );
          }
          return !1;
        }
      }
      class Oh extends nn {
        constructor(e) {
          (e = e || {}),
            super({ stopDown: Dn }),
            (this.condition_ = e.condition ? e.condition : Ah),
            (this.lastAngle_ = void 0),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250);
        }
        handleDragEvent(e) {
          if (!ai(e)) return;
          const t = e.map,
            n = t.getView();
          if (n.getConstraints().rotation === Wi) return;
          const r = t.getSize(),
            s = e.pixel,
            o = Math.atan2(r[1] / 2 - s[1], s[0] - r[0] / 2);
          if (this.lastAngle_ !== void 0) {
            const a = o - this.lastAngle_;
            n.adjustRotationInternal(-a);
          }
          this.lastAngle_ = o;
        }
        handleUpEvent(e) {
          return ai(e)
            ? (e.map.getView().endInteraction(this.duration_), !1)
            : !0;
        }
        handleDownEvent(e) {
          return ai(e) && Ws(e) && this.condition_(e)
            ? (e.map.getView().beginInteraction(),
              (this.lastAngle_ = void 0),
              !0)
            : !1;
        }
      }
      class Dh extends Sn {
        constructor(e) {
          super(),
            (this.geometry_ = null),
            (this.element_ = document.createElement("div")),
            (this.element_.style.position = "absolute"),
            (this.element_.style.pointerEvents = "auto"),
            (this.element_.className = "ol-box " + e),
            (this.map_ = null),
            (this.startPixel_ = null),
            (this.endPixel_ = null);
        }
        disposeInternal() {
          this.setMap(null);
        }
        render_() {
          const e = this.startPixel_,
            t = this.endPixel_,
            n = "px",
            r = this.element_.style;
          (r.left = Math.min(e[0], t[0]) + n),
            (r.top = Math.min(e[1], t[1]) + n),
            (r.width = Math.abs(t[0] - e[0]) + n),
            (r.height = Math.abs(t[1] - e[1]) + n);
        }
        setMap(e) {
          if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const t = this.element_.style;
            (t.left = "inherit"),
              (t.top = "inherit"),
              (t.width = "inherit"),
              (t.height = "inherit");
          }
          (this.map_ = e),
            this.map_ &&
              this.map_.getOverlayContainer().appendChild(this.element_);
        }
        setPixels(e, t) {
          (this.startPixel_ = e),
            (this.endPixel_ = t),
            this.createOrUpdateGeometry(),
            this.render_();
        }
        createOrUpdateGeometry() {
          if (!this.map_) return;
          const e = this.startPixel_,
            t = this.endPixel_,
            r = [e, [e[0], t[1]], t, [t[0], e[1]]].map(
              this.map_.getCoordinateFromPixelInternal,
              this.map_
            );
          (r[4] = r[0].slice()),
            this.geometry_
              ? this.geometry_.setCoordinates([r])
              : (this.geometry_ = new Yt([r]));
        }
        getGeometry() {
          return this.geometry_;
        }
      }
      const ht = {
        BOXSTART: "boxstart",
        BOXDRAG: "boxdrag",
        BOXEND: "boxend",
        BOXCANCEL: "boxcancel",
      };
      class Lt extends je {
        constructor(e, t, n) {
          super(e), (this.coordinate = t), (this.mapBrowserEvent = n);
        }
      }
      class Fh extends nn {
        constructor(e) {
          super(),
            this.on,
            this.once,
            this.un,
            (e = e ?? {}),
            (this.box_ = new Dh(e.className || "ol-dragbox")),
            (this.minArea_ = e.minArea ?? 64),
            e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd),
            (this.startPixel_ = null),
            (this.condition_ = e.condition ?? Ws),
            (this.boxEndCondition_ =
              e.boxEndCondition ?? this.defaultBoxEndCondition);
        }
        defaultBoxEndCondition(e, t, n) {
          const r = n[0] - t[0],
            s = n[1] - t[1];
          return r * r + s * s >= this.minArea_;
        }
        getGeometry() {
          return this.box_.getGeometry();
        }
        handleDragEvent(e) {
          this.startPixel_ &&
            (this.box_.setPixels(this.startPixel_, e.pixel),
            this.dispatchEvent(new Lt(ht.BOXDRAG, e.coordinate, e)));
        }
        handleUpEvent(e) {
          if (!this.startPixel_) return !1;
          const t = this.boxEndCondition_(e, this.startPixel_, e.pixel);
          return (
            t && this.onBoxEnd(e),
            this.dispatchEvent(
              new Lt(t ? ht.BOXEND : ht.BOXCANCEL, e.coordinate, e)
            ),
            this.box_.setMap(null),
            (this.startPixel_ = null),
            !1
          );
        }
        handleDownEvent(e) {
          return this.condition_(e)
            ? ((this.startPixel_ = e.pixel),
              this.box_.setMap(e.map),
              this.box_.setPixels(this.startPixel_, this.startPixel_),
              this.dispatchEvent(new Lt(ht.BOXSTART, e.coordinate, e)),
              !0)
            : !1;
        }
        onBoxEnd(e) {}
        setActive(e) {
          e ||
            (this.box_.setMap(null),
            this.startPixel_ &&
              (this.dispatchEvent(new Lt(ht.BOXCANCEL, this.startPixel_, null)),
              (this.startPixel_ = null))),
            super.setActive(e);
        }
        setMap(e) {
          this.getMap() &&
            (this.box_.setMap(null),
            this.startPixel_ &&
              (this.dispatchEvent(new Lt(ht.BOXCANCEL, this.startPixel_, null)),
              (this.startPixel_ = null))),
            super.setMap(e);
        }
      }
      class Nh extends Fh {
        constructor(e) {
          e = e || {};
          const t = e.condition ? e.condition : Sh;
          super({
            condition: t,
            className: e.className || "ol-dragzoom",
            minArea: e.minArea,
          }),
            (this.duration_ = e.duration !== void 0 ? e.duration : 200),
            (this.out_ = e.out !== void 0 ? e.out : !1);
        }
        onBoxEnd(e) {
          const n = this.getMap().getView();
          let r = this.getGeometry();
          if (this.out_) {
            const s = n.rotatedExtentForGeometry(r),
              o = n.getResolutionForExtentInternal(s),
              a = n.getResolution() / o;
            (r = r.clone()), r.scale(a * a);
          }
          n.fitInternal(r, { duration: this.duration_, easing: Ct });
        }
      }
      const $e = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        DOWN: "ArrowDown",
      };
      class zh extends tn {
        constructor(e) {
          super(),
            (e = e || {}),
            (this.defaultCondition_ = function (t) {
              return Us(t) && js(t);
            }),
            (this.condition_ =
              e.condition !== void 0 ? e.condition : this.defaultCondition_),
            (this.duration_ = e.duration !== void 0 ? e.duration : 100),
            (this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128);
        }
        handleEvent(e) {
          let t = !1;
          if (e.type == b.KEYDOWN) {
            const n = e.originalEvent,
              r = n.key;
            if (
              this.condition_(e) &&
              (r == $e.DOWN || r == $e.LEFT || r == $e.RIGHT || r == $e.UP)
            ) {
              const o = e.map.getView(),
                a = o.getResolution() * this.pixelDelta_;
              let l = 0,
                h = 0;
              r == $e.DOWN
                ? (h = -a)
                : r == $e.LEFT
                ? (l = -a)
                : r == $e.RIGHT
                ? (l = a)
                : (h = a);
              const c = [l, h];
              Mi(c, o.getRotation()),
                xh(o, c, this.duration_),
                n.preventDefault(),
                (t = !0);
            }
          }
          return !t;
        }
      }
      class kh extends tn {
        constructor(e) {
          super(),
            (e = e || {}),
            (this.condition_ = e.condition
              ? e.condition
              : function (t) {
                  return !bh(t) && js(t);
                }),
            (this.delta_ = e.delta ? e.delta : 1),
            (this.duration_ = e.duration !== void 0 ? e.duration : 100);
        }
        handleEvent(e) {
          let t = !1;
          if (e.type == b.KEYDOWN || e.type == b.KEYPRESS) {
            const n = e.originalEvent,
              r = n.key;
            if (this.condition_(e) && (r === "+" || r === "-")) {
              const s = e.map,
                o = r === "+" ? this.delta_ : -this.delta_,
                a = s.getView();
              Ji(a, o, void 0, this.duration_), n.preventDefault(), (t = !0);
            }
          }
          return !t;
        }
      }
      class Hs extends tn {
        constructor(e) {
          (e = e || {}),
            super(e),
            (this.totalDelta_ = 0),
            (this.lastDelta_ = 0),
            (this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250),
            (this.timeout_ = e.timeout !== void 0 ? e.timeout : 80),
            (this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0),
            (this.constrainResolution_ =
              e.constrainResolution !== void 0 ? e.constrainResolution : !1);
          const t = e.condition ? e.condition : Lh;
          (this.condition_ = e.onFocusOnly ? vi(Vs, t) : t),
            (this.lastAnchor_ = null),
            (this.startTime_ = void 0),
            this.timeoutId_,
            (this.mode_ = void 0),
            (this.trackpadEventGap_ = 400),
            this.trackpadTimeoutId_,
            (this.deltaPerZoom_ = 300);
        }
        endInteraction_() {
          this.trackpadTimeoutId_ = void 0;
          const e = this.getMap();
          if (!e) return;
          e.getView().endInteraction(
            void 0,
            this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,
            this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null
          );
        }
        handleEvent(e) {
          if (!this.condition_(e) || e.type !== b.WHEEL) return !0;
          const n = e.map,
            r = e.originalEvent;
          r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.pixel);
          let s;
          if (
            (e.type == b.WHEEL &&
              ((s = r.deltaY),
              Da && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (s /= Ms),
              r.deltaMode === WheelEvent.DOM_DELTA_LINE && (s *= 40)),
            s === 0)
          )
            return !1;
          this.lastDelta_ = s;
          const o = Date.now();
          this.startTime_ === void 0 && (this.startTime_ = o),
            (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) &&
              (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
          const a = n.getView();
          if (
            this.mode_ === "trackpad" &&
            !(a.getConstrainResolution() || this.constrainResolution_)
          )
            return (
              this.trackpadTimeoutId_
                ? clearTimeout(this.trackpadTimeoutId_)
                : (a.getAnimating() && a.cancelAnimations(),
                  a.beginInteraction()),
              (this.trackpadTimeoutId_ = setTimeout(
                this.endInteraction_.bind(this),
                this.timeout_
              )),
              a.adjustZoom(
                -s / this.deltaPerZoom_,
                this.lastAnchor_
                  ? n.getCoordinateFromPixel(this.lastAnchor_)
                  : null
              ),
              (this.startTime_ = o),
              !1
            );
          this.totalDelta_ += s;
          const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
          return (
            clearTimeout(this.timeoutId_),
            (this.timeoutId_ = setTimeout(
              this.handleWheelZoom_.bind(this, n),
              l
            )),
            !1
          );
        }
        handleWheelZoom_(e) {
          const t = e.getView();
          t.getAnimating() && t.cancelAnimations();
          let n =
            -q(
              this.totalDelta_,
              -this.maxDelta_ * this.deltaPerZoom_,
              this.maxDelta_ * this.deltaPerZoom_
            ) / this.deltaPerZoom_;
          (t.getConstrainResolution() || this.constrainResolution_) &&
            (n = n ? (n > 0 ? 1 : -1) : 0),
            Ji(
              t,
              n,
              this.lastAnchor_
                ? e.getCoordinateFromPixel(this.lastAnchor_)
                : null,
              this.duration_
            ),
            (this.mode_ = void 0),
            (this.totalDelta_ = 0),
            (this.lastAnchor_ = null),
            (this.startTime_ = void 0),
            (this.timeoutId_ = void 0);
        }
        setMouseAnchor(e) {
          (this.useAnchor_ = e), e || (this.lastAnchor_ = null);
        }
      }
      class Gh extends nn {
        constructor(e) {
          e = e || {};
          const t = e;
          t.stopDown || (t.stopDown = Dn),
            super(t),
            (this.anchor_ = null),
            (this.lastAngle_ = void 0),
            (this.rotating_ = !1),
            (this.rotationDelta_ = 0),
            (this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3),
            (this.duration_ = e.duration !== void 0 ? e.duration : 250);
        }
        handleDragEvent(e) {
          let t = 0;
          const n = this.targetPointers[0],
            r = this.targetPointers[1],
            s = Math.atan2(r.clientY - n.clientY, r.clientX - n.clientX);
          if (this.lastAngle_ !== void 0) {
            const l = s - this.lastAngle_;
            (this.rotationDelta_ += l),
              !this.rotating_ &&
                Math.abs(this.rotationDelta_) > this.threshold_ &&
                (this.rotating_ = !0),
              (t = l);
          }
          this.lastAngle_ = s;
          const o = e.map,
            a = o.getView();
          a.getConstraints().rotation !== Wi &&
            ((this.anchor_ = o.getCoordinateFromPixelInternal(
              o.getEventPixel(Qi(this.targetPointers))
            )),
            this.rotating_ &&
              (o.render(), a.adjustRotationInternal(t, this.anchor_)));
        }
        handleUpEvent(e) {
          return this.targetPointers.length < 2
            ? (e.map.getView().endInteraction(this.duration_), !1)
            : !0;
        }
        handleDownEvent(e) {
          if (this.targetPointers.length >= 2) {
            const t = e.map;
            return (
              (this.anchor_ = null),
              (this.lastAngle_ = void 0),
              (this.rotating_ = !1),
              (this.rotationDelta_ = 0),
              this.handlingDownUpSequence || t.getView().beginInteraction(),
              !0
            );
          }
          return !1;
        }
      }
      class Xh extends nn {
        constructor(e) {
          e = e || {};
          const t = e;
          t.stopDown || (t.stopDown = Dn),
            super(t),
            (this.anchor_ = null),
            (this.duration_ = e.duration !== void 0 ? e.duration : 400),
            (this.lastDistance_ = void 0),
            (this.lastScaleDelta_ = 1);
        }
        handleDragEvent(e) {
          let t = 1;
          const n = this.targetPointers[0],
            r = this.targetPointers[1],
            s = n.clientX - r.clientX,
            o = n.clientY - r.clientY,
            a = Math.sqrt(s * s + o * o);
          this.lastDistance_ !== void 0 && (t = this.lastDistance_ / a),
            (this.lastDistance_ = a);
          const l = e.map,
            h = l.getView();
          t != 1 && (this.lastScaleDelta_ = t),
            (this.anchor_ = l.getCoordinateFromPixelInternal(
              l.getEventPixel(Qi(this.targetPointers))
            )),
            l.render(),
            h.adjustResolutionInternal(t, this.anchor_);
        }
        handleUpEvent(e) {
          if (this.targetPointers.length < 2) {
            const n = e.map.getView(),
              r = this.lastScaleDelta_ > 1 ? 1 : -1;
            return n.endInteraction(this.duration_, r), !1;
          }
          return !0;
        }
        handleDownEvent(e) {
          if (this.targetPointers.length >= 2) {
            const t = e.map;
            return (
              (this.anchor_ = null),
              (this.lastDistance_ = void 0),
              (this.lastScaleDelta_ = 1),
              this.handlingDownUpSequence || t.getView().beginInteraction(),
              !0
            );
          }
          return !1;
        }
      }
      function qs(i) {
        i = i || {};
        const e = new Pe(),
          t = new fh(-0.005, 0.05, 100);
        return (
          (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) &&
            e.push(new Oh()),
          (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) &&
            e.push(new Ih({ delta: i.zoomDelta, duration: i.zoomDuration })),
          (i.dragPan !== void 0 ? i.dragPan : !0) &&
            e.push(new Bs({ onFocusOnly: i.onFocusOnly, kinetic: t })),
          (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && e.push(new Gh()),
          (i.pinchZoom !== void 0 ? i.pinchZoom : !0) &&
            e.push(new Xh({ duration: i.zoomDuration })),
          (i.keyboard !== void 0 ? i.keyboard : !0) &&
            (e.push(new zh()),
            e.push(new kh({ delta: i.zoomDelta, duration: i.zoomDuration }))),
          (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) &&
            e.push(
              new Hs({ onFocusOnly: i.onFocusOnly, duration: i.zoomDuration })
            ),
          (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) &&
            e.push(new Nh({ duration: i.zoomDuration })),
          e
        );
      }
      function $s(i) {
        if (i instanceof Un) {
          i.setMapInternal(null);
          return;
        }
        i instanceof Tt && i.getLayers().forEach($s);
      }
      function Js(i, e) {
        if (i instanceof Un) {
          i.setMapInternal(e);
          return;
        }
        if (i instanceof Tt) {
          const t = i.getLayers().getArray();
          for (let n = 0, r = t.length; n < r; ++n) Js(t[n], e);
        }
      }
      class Yh extends De {
        constructor(e) {
          super(), (e = e || {}), this.on, this.once, this.un;
          const t = Zh(e);
          (this.renderComplete_ = !1),
            (this.loaded_ = !0),
            (this.boundHandleBrowserEvent_ =
              this.handleBrowserEvent.bind(this)),
            (this.maxTilesLoading_ =
              e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16),
            (this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : Ms),
            this.postRenderTimeoutHandle_,
            this.animationDelayKey_,
            (this.animationDelay_ = this.animationDelay_.bind(this)),
            (this.coordinateToPixelTransform_ = pt()),
            (this.pixelToCoordinateTransform_ = pt()),
            (this.frameIndex_ = 0),
            (this.frameState_ = null),
            (this.previousExtent_ = null),
            (this.viewPropertyListenerKey_ = null),
            (this.viewChangeListenerKey_ = null),
            (this.layerGroupPropertyListenerKeys_ = null),
            (this.viewport_ = document.createElement("div")),
            (this.viewport_.className =
              "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "")),
            (this.viewport_.style.position = "relative"),
            (this.viewport_.style.overflow = "hidden"),
            (this.viewport_.style.width = "100%"),
            (this.viewport_.style.height = "100%"),
            (this.overlayContainer_ = document.createElement("div")),
            (this.overlayContainer_.style.position = "absolute"),
            (this.overlayContainer_.style.zIndex = "0"),
            (this.overlayContainer_.style.width = "100%"),
            (this.overlayContainer_.style.height = "100%"),
            (this.overlayContainer_.style.pointerEvents = "none"),
            (this.overlayContainer_.className = "ol-overlaycontainer"),
            this.viewport_.appendChild(this.overlayContainer_),
            (this.overlayContainerStopEvent_ = document.createElement("div")),
            (this.overlayContainerStopEvent_.style.position = "absolute"),
            (this.overlayContainerStopEvent_.style.zIndex = "0"),
            (this.overlayContainerStopEvent_.style.width = "100%"),
            (this.overlayContainerStopEvent_.style.height = "100%"),
            (this.overlayContainerStopEvent_.style.pointerEvents = "none"),
            (this.overlayContainerStopEvent_.className =
              "ol-overlaycontainer-stopevent"),
            this.viewport_.appendChild(this.overlayContainerStopEvent_),
            (this.mapBrowserEventHandler_ = null),
            (this.moveTolerance_ = e.moveTolerance),
            (this.keyboardEventTarget_ = t.keyboardEventTarget),
            (this.targetChangeHandlerKeys_ = null),
            (this.targetElement_ = null),
            (this.resizeObserver_ = new ResizeObserver(() =>
              this.updateSize()
            )),
            (this.controls = t.controls || Th()),
            (this.interactions = t.interactions || qs({ onFocusOnly: !0 })),
            (this.overlays_ = t.overlays),
            (this.overlayIdIndex_ = {}),
            (this.renderer_ = null),
            (this.postRenderFunctions_ = []),
            (this.tileQueue_ = new Eh(
              this.getTilePriority.bind(this),
              this.handleTileChange_.bind(this)
            )),
            this.addChangeListener(
              ne.LAYERGROUP,
              this.handleLayerGroupChanged_
            ),
            this.addChangeListener(ne.VIEW, this.handleViewChanged_),
            this.addChangeListener(ne.SIZE, this.handleSizeChanged_),
            this.addChangeListener(ne.TARGET, this.handleTargetChanged_),
            this.setProperties(t.values);
          const n = this;
          e.view &&
            !(e.view instanceof xe) &&
            e.view.then(function (r) {
              n.setView(new xe(r));
            }),
            this.controls.addEventListener(me.ADD, (r) => {
              r.element.setMap(this);
            }),
            this.controls.addEventListener(me.REMOVE, (r) => {
              r.element.setMap(null);
            }),
            this.interactions.addEventListener(me.ADD, (r) => {
              r.element.setMap(this);
            }),
            this.interactions.addEventListener(me.REMOVE, (r) => {
              r.element.setMap(null);
            }),
            this.overlays_.addEventListener(me.ADD, (r) => {
              this.addOverlayInternal_(r.element);
            }),
            this.overlays_.addEventListener(me.REMOVE, (r) => {
              const s = r.element.getId();
              s !== void 0 && delete this.overlayIdIndex_[s.toString()],
                r.element.setMap(null);
            }),
            this.controls.forEach((r) => {
              r.setMap(this);
            }),
            this.interactions.forEach((r) => {
              r.setMap(this);
            }),
            this.overlays_.forEach(this.addOverlayInternal_.bind(this));
        }
        addControl(e) {
          this.getControls().push(e);
        }
        addInteraction(e) {
          this.getInteractions().push(e);
        }
        addLayer(e) {
          this.getLayerGroup().getLayers().push(e);
        }
        handleLayerAdd_(e) {
          Js(e.layer, this);
        }
        addOverlay(e) {
          this.getOverlays().push(e);
        }
        addOverlayInternal_(e) {
          const t = e.getId();
          t !== void 0 && (this.overlayIdIndex_[t.toString()] = e),
            e.setMap(this);
        }
        disposeInternal() {
          this.controls.clear(),
            this.interactions.clear(),
            this.overlays_.clear(),
            this.resizeObserver_.disconnect(),
            this.setTarget(null),
            super.disposeInternal();
        }
        forEachFeatureAtPixel(e, t, n) {
          if (!this.frameState_ || !this.renderer_) return;
          const r = this.getCoordinateFromPixelInternal(e);
          n = n !== void 0 ? n : {};
          const s = n.hitTolerance !== void 0 ? n.hitTolerance : 0,
            o = n.layerFilter !== void 0 ? n.layerFilter : wn,
            a = n.checkWrapped !== !1;
          return this.renderer_.forEachFeatureAtCoordinate(
            r,
            this.frameState_,
            s,
            a,
            t,
            null,
            o,
            null
          );
        }
        getFeaturesAtPixel(e, t) {
          const n = [];
          return (
            this.forEachFeatureAtPixel(
              e,
              function (r) {
                n.push(r);
              },
              t
            ),
            n
          );
        }
        getAllLayers() {
          const e = [];
          function t(n) {
            n.forEach(function (r) {
              r instanceof Tt ? t(r.getLayers()) : e.push(r);
            });
          }
          return t(this.getLayers()), e;
        }
        hasFeatureAtPixel(e, t) {
          if (!this.frameState_ || !this.renderer_) return !1;
          const n = this.getCoordinateFromPixelInternal(e);
          t = t !== void 0 ? t : {};
          const r = t.layerFilter !== void 0 ? t.layerFilter : wn,
            s = t.hitTolerance !== void 0 ? t.hitTolerance : 0,
            o = t.checkWrapped !== !1;
          return this.renderer_.hasFeatureAtCoordinate(
            n,
            this.frameState_,
            s,
            o,
            r,
            null
          );
        }
        getEventCoordinate(e) {
          return this.getCoordinateFromPixel(this.getEventPixel(e));
        }
        getEventCoordinateInternal(e) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
        }
        getEventPixel(e) {
          const n = this.viewport_.getBoundingClientRect(),
            r = this.getSize(),
            s = n.width / r[0],
            o = n.height / r[1],
            a = "changedTouches" in e ? e.changedTouches[0] : e;
          return [(a.clientX - n.left) / s, (a.clientY - n.top) / o];
        }
        getTarget() {
          return this.get(ne.TARGET);
        }
        getTargetElement() {
          return this.targetElement_;
        }
        getCoordinateFromPixel(e) {
          return pi(
            this.getCoordinateFromPixelInternal(e),
            this.getView().getProjection()
          );
        }
        getCoordinateFromPixelInternal(e) {
          const t = this.frameState_;
          return t ? ge(t.pixelToCoordinateTransform, e.slice()) : null;
        }
        getControls() {
          return this.controls;
        }
        getOverlays() {
          return this.overlays_;
        }
        getOverlayById(e) {
          const t = this.overlayIdIndex_[e.toString()];
          return t !== void 0 ? t : null;
        }
        getInteractions() {
          return this.interactions;
        }
        getLayerGroup() {
          return this.get(ne.LAYERGROUP);
        }
        setLayers(e) {
          const t = this.getLayerGroup();
          if (e instanceof Pe) {
            t.setLayers(e);
            return;
          }
          const n = t.getLayers();
          n.clear(), n.extend(e);
        }
        getLayers() {
          return this.getLayerGroup().getLayers();
        }
        getLoadingOrNotReady() {
          const e = this.getLayerGroup().getLayerStatesArray();
          for (let t = 0, n = e.length; t < n; ++t) {
            const r = e[t];
            if (!r.visible) continue;
            const s = r.layer.getRenderer();
            if (s && !s.ready) return !0;
            const o = r.layer.getSource();
            if (o && o.loading) return !0;
          }
          return !1;
        }
        getPixelFromCoordinate(e) {
          const t = be(e, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(t);
        }
        getPixelFromCoordinateInternal(e) {
          const t = this.frameState_;
          return t ? ge(t.coordinateToPixelTransform, e.slice(0, 2)) : null;
        }
        getRenderer() {
          return this.renderer_;
        }
        getSize() {
          return this.get(ne.SIZE);
        }
        getView() {
          return this.get(ne.VIEW);
        }
        getViewport() {
          return this.viewport_;
        }
        getOverlayContainer() {
          return this.overlayContainer_;
        }
        getOverlayContainerStopEvent() {
          return this.overlayContainerStopEvent_;
        }
        getOwnerDocument() {
          const e = this.getTargetElement();
          return e ? e.ownerDocument : document;
        }
        getTilePriority(e, t, n, r) {
          return wh(this.frameState_, e, t, n, r);
        }
        handleBrowserEvent(e, t) {
          t = t || e.type;
          const n = new Ze(t, this, e);
          this.handleMapBrowserEvent(n);
        }
        handleMapBrowserEvent(e) {
          if (!this.frameState_) return;
          const t = e.originalEvent,
            n = t.type;
          if (n === wi.POINTERDOWN || n === b.WHEEL || n === b.KEYDOWN) {
            const r = this.getOwnerDocument(),
              s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r,
              o = t.target,
              a =
                s instanceof ShadowRoot
                  ? s.host === o
                    ? s.host.ownerDocument
                    : s
                  : s === r
                  ? r.documentElement
                  : s;
            if (this.overlayContainerStopEvent_.contains(o) || !a.contains(o))
              return;
          }
          if (
            ((e.frameState = this.frameState_), this.dispatchEvent(e) !== !1)
          ) {
            const r = this.getInteractions().getArray().slice();
            for (let s = r.length - 1; s >= 0; s--) {
              const o = r[s];
              if (
                o.getMap() !== this ||
                !o.getActive() ||
                !this.getTargetElement()
              )
                continue;
              if (!o.handleEvent(e) || e.propagationStopped) break;
            }
          }
        }
        handlePostRender() {
          const e = this.frameState_,
            t = this.tileQueue_;
          if (!t.isEmpty()) {
            let r = this.maxTilesLoading_,
              s = r;
            if (e) {
              const o = e.viewHints;
              if (o[_e.ANIMATING] || o[_e.INTERACTING]) {
                const a = Date.now() - e.time > 8;
                (r = a ? 0 : 8), (s = a ? 0 : 2);
              }
            }
            t.getTilesLoading() < r &&
              (t.reprioritize(), t.loadMoreTiles(r, s));
          }
          e &&
            this.renderer_ &&
            !e.animate &&
            (this.renderComplete_
              ? (this.hasListener(Ie.RENDERCOMPLETE) &&
                  this.renderer_.dispatchRenderEvent(Ie.RENDERCOMPLETE, e),
                this.loaded_ === !1 &&
                  ((this.loaded_ = !0),
                  this.dispatchEvent(new _t(Ke.LOADEND, this, e))))
              : this.loaded_ === !0 &&
                ((this.loaded_ = !1),
                this.dispatchEvent(new _t(Ke.LOADSTART, this, e))));
          const n = this.postRenderFunctions_;
          for (let r = 0, s = n.length; r < s; ++r) n[r](this, e);
          n.length = 0;
        }
        handleSizeChanged_() {
          this.getView() &&
            !this.getView().getAnimating() &&
            this.getView().resolveConstraints(0),
            this.render();
        }
        handleTargetChanged_() {
          if (this.mapBrowserEventHandler_) {
            for (
              let n = 0, r = this.targetChangeHandlerKeys_.length;
              n < r;
              ++n
            )
              V(this.targetChangeHandlerKeys_[n]);
            (this.targetChangeHandlerKeys_ = null),
              this.viewport_.removeEventListener(
                b.CONTEXTMENU,
                this.boundHandleBrowserEvent_
              ),
              this.viewport_.removeEventListener(
                b.WHEEL,
                this.boundHandleBrowserEvent_
              ),
              this.mapBrowserEventHandler_.dispose(),
              (this.mapBrowserEventHandler_ = null),
              this.viewport_.remove();
          }
          if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const n = this.targetElement_.getRootNode();
            n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host),
              this.setSize(void 0);
          }
          const e = this.getTarget(),
            t = typeof e == "string" ? document.getElementById(e) : e;
          if (((this.targetElement_ = t), !t))
            this.renderer_ &&
              (clearTimeout(this.postRenderTimeoutHandle_),
              (this.postRenderTimeoutHandle_ = void 0),
              (this.postRenderFunctions_.length = 0),
              this.renderer_.dispose(),
              (this.renderer_ = null)),
              this.animationDelayKey_ &&
                (cancelAnimationFrame(this.animationDelayKey_),
                (this.animationDelayKey_ = void 0));
          else {
            t.appendChild(this.viewport_),
              this.renderer_ || (this.renderer_ = new mh(this)),
              (this.mapBrowserEventHandler_ = new ph(
                this,
                this.moveTolerance_
              ));
            for (const s in U)
              this.mapBrowserEventHandler_.addEventListener(
                U[s],
                this.handleMapBrowserEvent.bind(this)
              );
            this.viewport_.addEventListener(
              b.CONTEXTMENU,
              this.boundHandleBrowserEvent_,
              !1
            ),
              this.viewport_.addEventListener(
                b.WHEEL,
                this.boundHandleBrowserEvent_,
                bs ? { passive: !1 } : !1
              );
            let n;
            if (this.keyboardEventTarget_) n = this.keyboardEventTarget_;
            else {
              const s = t.getRootNode();
              n = s instanceof ShadowRoot ? s.host : t;
            }
            this.targetChangeHandlerKeys_ = [
              N(n, b.KEYDOWN, this.handleBrowserEvent, this),
              N(n, b.KEYPRESS, this.handleBrowserEvent, this),
            ];
            const r = t.getRootNode();
            r instanceof ShadowRoot && this.resizeObserver_.observe(r.host),
              this.resizeObserver_.observe(t);
          }
          this.updateSize();
        }
        handleTileChange_() {
          this.render();
        }
        handleViewPropertyChanged_() {
          this.render();
        }
        handleViewChanged_() {
          this.viewPropertyListenerKey_ &&
            (V(this.viewPropertyListenerKey_),
            (this.viewPropertyListenerKey_ = null)),
            this.viewChangeListenerKey_ &&
              (V(this.viewChangeListenerKey_),
              (this.viewChangeListenerKey_ = null));
          const e = this.getView();
          e &&
            (this.updateViewportSize_(this.getSize()),
            (this.viewPropertyListenerKey_ = N(
              e,
              Nt.PROPERTYCHANGE,
              this.handleViewPropertyChanged_,
              this
            )),
            (this.viewChangeListenerKey_ = N(
              e,
              b.CHANGE,
              this.handleViewPropertyChanged_,
              this
            )),
            e.resolveConstraints(0)),
            this.render();
        }
        handleLayerGroupChanged_() {
          this.layerGroupPropertyListenerKeys_ &&
            (this.layerGroupPropertyListenerKeys_.forEach(V),
            (this.layerGroupPropertyListenerKeys_ = null));
          const e = this.getLayerGroup();
          e &&
            (this.handleLayerAdd_(new Ve("addlayer", e)),
            (this.layerGroupPropertyListenerKeys_ = [
              N(e, Nt.PROPERTYCHANGE, this.render, this),
              N(e, b.CHANGE, this.render, this),
              N(e, "addlayer", this.handleLayerAdd_, this),
              N(e, "removelayer", this.handleLayerRemove_, this),
            ])),
            this.render();
        }
        isRendered() {
          return !!this.frameState_;
        }
        animationDelay_() {
          (this.animationDelayKey_ = void 0), this.renderFrame_(Date.now());
        }
        renderSync() {
          this.animationDelayKey_ &&
            cancelAnimationFrame(this.animationDelayKey_),
            this.animationDelay_();
        }
        redrawText() {
          const e = this.getLayerGroup().getLayerStatesArray();
          for (let t = 0, n = e.length; t < n; ++t) {
            const r = e[t].layer;
            r.hasRenderer() && r.getRenderer().handleFontsChanged();
          }
        }
        render() {
          this.renderer_ &&
            this.animationDelayKey_ === void 0 &&
            (this.animationDelayKey_ = requestAnimationFrame(
              this.animationDelay_
            ));
        }
        removeControl(e) {
          return this.getControls().remove(e);
        }
        removeInteraction(e) {
          return this.getInteractions().remove(e);
        }
        removeLayer(e) {
          return this.getLayerGroup().getLayers().remove(e);
        }
        handleLayerRemove_(e) {
          $s(e.layer);
        }
        removeOverlay(e) {
          return this.getOverlays().remove(e);
        }
        renderFrame_(e) {
          const t = this.getSize(),
            n = this.getView(),
            r = this.frameState_;
          let s = null;
          if (t !== void 0 && Mr(t) && n && n.isDef()) {
            const o = n.getHints(
                this.frameState_ ? this.frameState_.viewHints : void 0
              ),
              a = n.getState();
            if (
              ((s = {
                animate: !1,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutter: null,
                extent: gi(a.center, a.resolution, a.rotation, t),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: t,
                tileQueue: this.tileQueue_,
                time: e,
                usedTiles: {},
                viewState: a,
                viewHints: o,
                wantedTiles: {},
                mapId: re(this),
                renderTargets: {},
              }),
              a.nextCenter && a.nextResolution)
            ) {
              const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
              s.nextExtent = gi(a.nextCenter, a.nextResolution, l, t);
            }
          }
          (this.frameState_ = s),
            this.renderer_.renderFrame(s),
            s &&
              (s.animate && this.render(),
              Array.prototype.push.apply(
                this.postRenderFunctions_,
                s.postRenderFunctions
              ),
              r &&
                (!this.previousExtent_ ||
                  (!$t(this.previousExtent_) &&
                    !fi(s.extent, this.previousExtent_))) &&
                (this.dispatchEvent(new _t(Ke.MOVESTART, this, r)),
                (this.previousExtent_ = Ht(this.previousExtent_))),
              this.previousExtent_ &&
                !s.viewHints[_e.ANIMATING] &&
                !s.viewHints[_e.INTERACTING] &&
                !fi(s.extent, this.previousExtent_) &&
                (this.dispatchEvent(new _t(Ke.MOVEEND, this, s)),
                vo(s.extent, this.previousExtent_))),
            this.dispatchEvent(new _t(Ke.POSTRENDER, this, s)),
            (this.renderComplete_ =
              (this.hasListener(Ke.LOADSTART) ||
                this.hasListener(Ke.LOADEND) ||
                this.hasListener(Ie.RENDERCOMPLETE)) &&
              !this.tileQueue_.getTilesLoading() &&
              !this.tileQueue_.getCount() &&
              !this.getLoadingOrNotReady()),
            this.postRenderTimeoutHandle_ ||
              (this.postRenderTimeoutHandle_ = setTimeout(() => {
                (this.postRenderTimeoutHandle_ = void 0),
                  this.handlePostRender();
              }, 0));
        }
        setLayerGroup(e) {
          const t = this.getLayerGroup();
          t && this.handleLayerRemove_(new Ve("removelayer", t)),
            this.set(ne.LAYERGROUP, e);
        }
        setSize(e) {
          this.set(ne.SIZE, e);
        }
        setTarget(e) {
          this.set(ne.TARGET, e);
        }
        setView(e) {
          if (!e || e instanceof xe) {
            this.set(ne.VIEW, e);
            return;
          }
          this.set(ne.VIEW, new xe());
          const t = this;
          e.then(function (n) {
            t.setView(new xe(n));
          });
        }
        updateSize() {
          const e = this.getTargetElement();
          let t;
          if (e) {
            const r = getComputedStyle(e),
              s =
                e.offsetWidth -
                parseFloat(r.borderLeftWidth) -
                parseFloat(r.paddingLeft) -
                parseFloat(r.paddingRight) -
                parseFloat(r.borderRightWidth),
              o =
                e.offsetHeight -
                parseFloat(r.borderTopWidth) -
                parseFloat(r.paddingTop) -
                parseFloat(r.paddingBottom) -
                parseFloat(r.borderBottomWidth);
            !isNaN(s) &&
              !isNaN(o) &&
              ((t = [Math.max(0, s), Math.max(0, o)]),
              !Mr(t) &&
                (e.offsetWidth ||
                  e.offsetHeight ||
                  e.getClientRects().length) &&
                fs(
                  "No map visible because the map container's width or height are 0."
                ));
          }
          const n = this.getSize();
          t &&
            (!n || !On(t, n)) &&
            (this.setSize(t), this.updateViewportSize_(t));
        }
        updateViewportSize_(e) {
          const t = this.getView();
          t && t.setViewportSize(e);
        }
      }
      function Zh(i) {
        let e = null;
        i.keyboardEventTarget !== void 0 &&
          (e =
            typeof i.keyboardEventTarget == "string"
              ? document.getElementById(i.keyboardEventTarget)
              : i.keyboardEventTarget);
        const t = {},
          n =
            i.layers && typeof i.layers.getLayers == "function"
              ? i.layers
              : new Tt({ layers: i.layers });
        (t[ne.LAYERGROUP] = n),
          (t[ne.TARGET] = i.target),
          (t[ne.VIEW] = i.view instanceof xe ? i.view : new xe());
        let r;
        i.controls !== void 0 &&
          (Array.isArray(i.controls)
            ? (r = new Pe(i.controls.slice()))
            : (G(
                typeof i.controls.getArray == "function",
                "Expected `controls` to be an array or an `ol/Collection.js`"
              ),
              (r = i.controls)));
        let s;
        i.interactions !== void 0 &&
          (Array.isArray(i.interactions)
            ? (s = new Pe(i.interactions.slice()))
            : (G(
                typeof i.interactions.getArray == "function",
                "Expected `interactions` to be an array or an `ol/Collection.js`"
              ),
              (s = i.interactions)));
        let o;
        return (
          i.overlays !== void 0
            ? Array.isArray(i.overlays)
              ? (o = new Pe(i.overlays.slice()))
              : (G(
                  typeof i.overlays.getArray == "function",
                  "Expected `overlays` to be an array or an `ol/Collection.js`"
                ),
                (o = i.overlays))
            : (o = new Pe()),
          {
            controls: r,
            interactions: s,
            keyboardEventTarget: e,
            overlays: o,
            values: t,
          }
        );
      }
      class Kh {
        constructor(e) {
          (this.highWaterMark = e !== void 0 ? e : 2048),
            (this.count_ = 0),
            (this.entries_ = {}),
            (this.oldest_ = null),
            (this.newest_ = null);
        }
        canExpireCache() {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        }
        expireCache(e) {
          for (; this.canExpireCache(); ) {
            const t = this.pop();
            t instanceof Sn && t.dispose();
          }
        }
        clear() {
          (this.count_ = 0),
            (this.entries_ = {}),
            (this.oldest_ = null),
            (this.newest_ = null);
        }
        containsKey(e) {
          return this.entries_.hasOwnProperty(e);
        }
        forEach(e) {
          let t = this.oldest_;
          for (; t; ) e(t.value_, t.key_, this), (t = t.newer);
        }
        get(e, t) {
          const n = this.entries_[e];
          return (
            G(
              n !== void 0,
              "Tried to get a value for a key that does not exist in the cache"
            ),
            n === this.newest_ ||
              (n === this.oldest_
                ? ((this.oldest_ = this.oldest_.newer),
                  (this.oldest_.older = null))
                : ((n.newer.older = n.older), (n.older.newer = n.newer)),
              (n.newer = null),
              (n.older = this.newest_),
              (this.newest_.newer = n),
              (this.newest_ = n)),
            n.value_
          );
        }
        remove(e) {
          const t = this.entries_[e];
          return (
            G(
              t !== void 0,
              "Tried to get a value for a key that does not exist in the cache"
            ),
            t === this.newest_
              ? ((this.newest_ = t.older),
                this.newest_ && (this.newest_.newer = null))
              : t === this.oldest_
              ? ((this.oldest_ = t.newer),
                this.oldest_ && (this.oldest_.older = null))
              : ((t.newer.older = t.older), (t.older.newer = t.newer)),
            delete this.entries_[e],
            --this.count_,
            t.value_
          );
        }
        getCount() {
          return this.count_;
        }
        getKeys() {
          const e = new Array(this.count_);
          let t = 0,
            n;
          for (n = this.newest_; n; n = n.older) e[t++] = n.key_;
          return e;
        }
        getValues() {
          const e = new Array(this.count_);
          let t = 0,
            n;
          for (n = this.newest_; n; n = n.older) e[t++] = n.value_;
          return e;
        }
        peekLast() {
          return this.oldest_.value_;
        }
        peekLastKey() {
          return this.oldest_.key_;
        }
        peekFirstKey() {
          return this.newest_.key_;
        }
        peek(e) {
          var t;
          return (t = this.entries_[e]) == null ? void 0 : t.value_;
        }
        pop() {
          const e = this.oldest_;
          return (
            delete this.entries_[e.key_],
            e.newer && (e.newer.older = null),
            (this.oldest_ = e.newer),
            this.oldest_ || (this.newest_ = null),
            --this.count_,
            e.value_
          );
        }
        replace(e, t) {
          this.get(e), (this.entries_[e].value_ = t);
        }
        set(e, t) {
          G(
            !(e in this.entries_),
            "Tried to set a value for a key that is used already"
          );
          const n = { key_: e, newer: null, older: this.newest_, value_: t };
          this.newest_ ? (this.newest_.newer = n) : (this.oldest_ = n),
            (this.newest_ = n),
            (this.entries_[e] = n),
            ++this.count_;
        }
        setSize(e) {
          this.highWaterMark = e;
        }
      }
      function Ln(i, e, t, n) {
        return n !== void 0
          ? ((n[0] = i), (n[1] = e), (n[2] = t), n)
          : [i, e, t];
      }
      function Vh(i, e, t) {
        return i + "/" + e + "/" + t;
      }
      function Wh(i) {
        return Uh(i[0], i[1], i[2]);
      }
      function Uh(i, e, t) {
        return (e << i) + t;
      }
      function jh(i, e) {
        const t = i[0],
          n = i[1],
          r = i[2];
        if (e.getMinZoom() > t || t > e.getMaxZoom()) return !1;
        const s = e.getFullTileRange(t);
        return s ? s.containsXY(n, r) : !0;
      }
      class er {
        constructor(e, t, n, r) {
          (this.minX = e), (this.maxX = t), (this.minY = n), (this.maxY = r);
        }
        contains(e) {
          return this.containsXY(e[1], e[2]);
        }
        containsTileRange(e) {
          return (
            this.minX <= e.minX &&
            e.maxX <= this.maxX &&
            this.minY <= e.minY &&
            e.maxY <= this.maxY
          );
        }
        containsXY(e, t) {
          return (
            this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY
          );
        }
        equals(e) {
          return (
            this.minX == e.minX &&
            this.minY == e.minY &&
            this.maxX == e.maxX &&
            this.maxY == e.maxY
          );
        }
        extend(e) {
          e.minX < this.minX && (this.minX = e.minX),
            e.maxX > this.maxX && (this.maxX = e.maxX),
            e.minY < this.minY && (this.minY = e.minY),
            e.maxY > this.maxY && (this.maxY = e.maxY);
        }
        getHeight() {
          return this.maxY - this.minY + 1;
        }
        getSize() {
          return [this.getWidth(), this.getHeight()];
        }
        getWidth() {
          return this.maxX - this.minX + 1;
        }
        intersects(e) {
          return (
            this.minX <= e.maxX &&
            this.maxX >= e.minX &&
            this.minY <= e.maxY &&
            this.maxY >= e.minY
          );
        }
      }
      function ct(i, e, t, n, r) {
        return r !== void 0
          ? ((r.minX = i), (r.maxX = e), (r.minY = t), (r.maxY = n), r)
          : new er(i, e, t, n);
      }
      const mn = {
        PRELOAD: "preload",
        USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError",
      };
      class Bh extends Un {
        constructor(e) {
          e = e || {};
          const t = Object.assign({}, e),
            n = e.cacheSize;
          delete e.cacheSize,
            delete t.preload,
            delete t.useInterimTilesOnError,
            super(t),
            this.on,
            this.once,
            this.un,
            (this.cacheSize_ = n),
            this.setPreload(e.preload !== void 0 ? e.preload : 0),
            this.setUseInterimTilesOnError(
              e.useInterimTilesOnError !== void 0
                ? e.useInterimTilesOnError
                : !0
            );
        }
        getCacheSize() {
          return this.cacheSize_;
        }
        getPreload() {
          return this.get(mn.PRELOAD);
        }
        setPreload(e) {
          this.set(mn.PRELOAD, e);
        }
        getUseInterimTilesOnError() {
          return this.get(mn.USE_INTERIM_TILES_ON_ERROR);
        }
        setUseInterimTilesOnError(e) {
          this.set(mn.USE_INTERIM_TILES_ON_ERROR, e);
        }
        getData(e) {
          return super.getData(e);
        }
      }
      function bn(i) {
        return i instanceof Image ||
          i instanceof HTMLCanvasElement ||
          i instanceof HTMLVideoElement ||
          i instanceof ImageBitmap
          ? i
          : null;
      }
      function Hh(i) {
        return i instanceof Uint8Array ||
          i instanceof Uint8ClampedArray ||
          i instanceof Float32Array ||
          i instanceof DataView
          ? i
          : null;
      }
      const qh = new Error("disposed");
      let ut = null;
      function $h(i) {
        ut || (ut = ie(i.width, i.height, void 0, { willReadFrequently: !0 }));
        const e = ut.canvas,
          t = i.width;
        e.width !== t && (e.width = t);
        const n = i.height;
        return (
          e.height !== n && (e.height = n),
          ut.clearRect(0, 0, t, n),
          ut.drawImage(i, 0, 0),
          ut.getImageData(0, 0, t, n).data
        );
      }
      const Jh = [256, 256];
      class Ri extends qi {
        constructor(e) {
          const t = T.IDLE;
          super(e.tileCoord, t, {
            transition: e.transition,
            interpolate: e.interpolate,
          }),
            (this.loader_ = e.loader),
            (this.data_ = null),
            (this.error_ = null),
            (this.size_ = e.size || null),
            (this.controller_ = e.controller || null);
        }
        getSize() {
          if (this.size_) return this.size_;
          const e = bn(this.data_);
          return e ? [e.width, e.height] : Jh;
        }
        getData() {
          return this.data_;
        }
        getError() {
          return this.error_;
        }
        load() {
          if (this.state !== T.IDLE && this.state !== T.ERROR) return;
          (this.state = T.LOADING), this.changed();
          const e = this;
          this.loader_()
            .then(function (t) {
              (e.data_ = t), (e.state = T.LOADED), e.changed();
            })
            .catch(function (t) {
              (e.error_ = t), (e.state = T.ERROR), e.changed();
            });
        }
        disposeInternal() {
          this.controller_ &&
            (this.controller_.abort(qh), (this.controller_ = null)),
            super.disposeInternal();
        }
      }
      const Qs = 0.5,
        Qh = 10,
        qr = 0.25;
      class eo {
        constructor(e, t, n, r, s, o) {
          (this.sourceProj_ = e), (this.targetProj_ = t);
          let a = {};
          const l = Gt(this.targetProj_, this.sourceProj_);
          (this.transformInv_ = function (y) {
            const R = y[0] + "/" + y[1];
            return a[R] || (a[R] = l(y)), a[R];
          }),
            (this.maxSourceExtent_ = r),
            (this.errorThresholdSquared_ = s * s),
            (this.triangles_ = []),
            (this.wrapsXInSource_ = !1),
            (this.canWrapXInSource_ =
              this.sourceProj_.canWrapX() &&
              !!r &&
              !!this.sourceProj_.getExtent() &&
              X(r) >= X(this.sourceProj_.getExtent())),
            (this.sourceWorldWidth_ = this.sourceProj_.getExtent()
              ? X(this.sourceProj_.getExtent())
              : null),
            (this.targetWorldWidth_ = this.targetProj_.getExtent()
              ? X(this.targetProj_.getExtent())
              : null);
          const h = it(n),
            c = Gn(n),
            u = kn(n),
            d = zn(n),
            g = this.transformInv_(h),
            f = this.transformInv_(c),
            _ = this.transformInv_(u),
            p = this.transformInv_(d),
            E =
              Qh +
              (o
                ? Math.max(0, Math.ceil(Math.log2(kt(n) / (o * o * 256 * 256))))
                : 0);
          if (
            (this.addQuad_(h, c, u, d, g, f, _, p, E), this.wrapsXInSource_)
          ) {
            let y = 1 / 0;
            this.triangles_.forEach(function (R, v, w) {
              y = Math.min(y, R.source[0][0], R.source[1][0], R.source[2][0]);
            }),
              this.triangles_.forEach((R) => {
                if (
                  Math.max(R.source[0][0], R.source[1][0], R.source[2][0]) - y >
                  this.sourceWorldWidth_ / 2
                ) {
                  const v = [
                    [R.source[0][0], R.source[0][1]],
                    [R.source[1][0], R.source[1][1]],
                    [R.source[2][0], R.source[2][1]],
                  ];
                  v[0][0] - y > this.sourceWorldWidth_ / 2 &&
                    (v[0][0] -= this.sourceWorldWidth_),
                    v[1][0] - y > this.sourceWorldWidth_ / 2 &&
                      (v[1][0] -= this.sourceWorldWidth_),
                    v[2][0] - y > this.sourceWorldWidth_ / 2 &&
                      (v[2][0] -= this.sourceWorldWidth_);
                  const w = Math.min(v[0][0], v[1][0], v[2][0]);
                  Math.max(v[0][0], v[1][0], v[2][0]) - w <
                    this.sourceWorldWidth_ / 2 && (R.source = v);
                }
              });
          }
          a = {};
        }
        addTriangle_(e, t, n, r, s, o) {
          this.triangles_.push({ source: [r, s, o], target: [e, t, n] });
        }
        addQuad_(e, t, n, r, s, o, a, l, h) {
          const c = ur([s, o, a, l]),
            u = this.sourceWorldWidth_ ? X(c) / this.sourceWorldWidth_ : null,
            d = this.sourceWorldWidth_,
            g = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
          let f = !1;
          if (h > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
              const p = ur([e, t, n, r]);
              f = X(p) / this.targetWorldWidth_ > qr || f;
            }
            !g && this.sourceProj_.isGlobal() && u && (f = u > qr || f);
          }
          if (
            !f &&
            this.maxSourceExtent_ &&
            isFinite(c[0]) &&
            isFinite(c[1]) &&
            isFinite(c[2]) &&
            isFinite(c[3]) &&
            !qt(c, this.maxSourceExtent_)
          )
            return;
          let _ = 0;
          if (
            !f &&
            (!isFinite(s[0]) ||
              !isFinite(s[1]) ||
              !isFinite(o[0]) ||
              !isFinite(o[1]) ||
              !isFinite(a[0]) ||
              !isFinite(a[1]) ||
              !isFinite(l[0]) ||
              !isFinite(l[1]))
          ) {
            if (h > 0) f = !0;
            else if (
              ((_ =
                (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) +
                (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) +
                (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) +
                (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0)),
              _ != 1 && _ != 2 && _ != 4 && _ != 8)
            )
              return;
          }
          if (h > 0) {
            if (!f) {
              const p = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2],
                E = this.transformInv_(p);
              let y;
              g
                ? (y = (wt(s[0], d) + wt(a[0], d)) / 2 - wt(E[0], d))
                : (y = (s[0] + a[0]) / 2 - E[0]);
              const R = (s[1] + a[1]) / 2 - E[1];
              f = y * y + R * R > this.errorThresholdSquared_;
            }
            if (f) {
              if (Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1])) {
                const p = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2],
                  E = this.transformInv_(p),
                  y = [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2],
                  R = this.transformInv_(y);
                this.addQuad_(e, t, p, y, s, o, E, R, h - 1),
                  this.addQuad_(y, p, n, r, R, E, a, l, h - 1);
              } else {
                const p = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2],
                  E = this.transformInv_(p),
                  y = [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2],
                  R = this.transformInv_(y);
                this.addQuad_(e, p, y, r, s, E, R, l, h - 1),
                  this.addQuad_(p, t, n, y, E, o, a, R, h - 1);
              }
              return;
            }
          }
          if (g) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = !0;
          }
          _ & 11 || this.addTriangle_(e, n, r, s, a, l),
            _ & 14 || this.addTriangle_(e, n, t, s, a, o),
            _ &&
              (_ & 13 || this.addTriangle_(t, r, e, o, l, s),
              _ & 7 || this.addTriangle_(t, r, n, o, l, a));
        }
        calculateSourceExtent() {
          const e = nt();
          return (
            this.triangles_.forEach(function (t, n, r) {
              const s = t.source;
              pn(e, s[0]), pn(e, s[1]), pn(e, s[2]);
            }),
            e
          );
        }
        getTriangles() {
          return this.triangles_;
        }
      }
      let li;
      const Oe = [];
      function $r(i, e, t, n, r) {
        i.beginPath(),
          i.moveTo(0, 0),
          i.lineTo(e, t),
          i.lineTo(n, r),
          i.closePath(),
          i.save(),
          i.clip(),
          i.fillRect(0, 0, Math.max(e, n) + 1, Math.max(t, r)),
          i.restore();
      }
      function hi(i, e) {
        return (
          Math.abs(i[e * 4] - 210) > 2 ||
          Math.abs(i[e * 4 + 3] - 0.75 * 255) > 2
        );
      }
      function ec() {
        if (li === void 0) {
          const i = ie(6, 6, Oe);
          (i.globalCompositeOperation = "lighter"),
            (i.fillStyle = "rgba(210, 0, 0, 0.75)"),
            $r(i, 4, 5, 4, 0),
            $r(i, 4, 5, 0, 5);
          const e = i.getImageData(0, 0, 3, 3).data;
          (li = hi(e, 0) || hi(e, 4) || hi(e, 8)), Vt(i), Oe.push(i.canvas);
        }
        return li;
      }
      function Jr(i, e, t, n) {
        const r = Pi(t, e, i);
        let s = pr(e, n, t);
        const o = e.getMetersPerUnit();
        o !== void 0 && (s *= o);
        const a = i.getMetersPerUnit();
        a !== void 0 && (s /= a);
        const l = i.getExtent();
        if (!l || Ii(l, r)) {
          const h = pr(i, s, r) / s;
          isFinite(h) && h > 0 && (s /= h);
        }
        return s;
      }
      function to(i, e, t, n) {
        const r = vt(t);
        let s = Jr(i, e, r, n);
        return (
          (!isFinite(s) || s <= 0) &&
            hs(t, function (o) {
              return (s = Jr(i, e, o, n)), isFinite(s) && s > 0;
            }),
          s
        );
      }
      function no(i, e, t, n, r, s, o, a, l, h, c, u, d, g) {
        const f = ie(Math.round(t * i), Math.round(t * e), Oe);
        if ((u || (f.imageSmoothingEnabled = !1), l.length === 0))
          return f.canvas;
        f.scale(t, t);
        function _(w) {
          return Math.round(w * t) / t;
        }
        f.globalCompositeOperation = "lighter";
        const p = nt();
        l.forEach(function (w, A, x) {
          xo(p, w.extent);
        });
        let E;
        const y = t / n,
          R = (u ? 1 : 1 + Math.pow(2, -24)) / y;
        if (!d || l.length !== 1 || h !== 0) {
          if (
            ((E = ie(Math.round(X(p) * y), Math.round(de(p) * y), Oe)),
            u || (E.imageSmoothingEnabled = !1),
            r && g)
          ) {
            const w = (r[0] - p[0]) * y,
              A = -(r[3] - p[3]) * y,
              x = X(r) * y,
              C = de(r) * y;
            E.rect(w, A, x, C), E.clip();
          }
          l.forEach(function (w, A, x) {
            if (w.image.width > 0 && w.image.height > 0) {
              if (w.clipExtent) {
                E.save();
                const K = (w.clipExtent[0] - p[0]) * y,
                  Y = -(w.clipExtent[3] - p[3]) * y,
                  S = X(w.clipExtent) * y,
                  j = de(w.clipExtent) * y;
                E.rect(
                  u ? K : Math.round(K),
                  u ? Y : Math.round(Y),
                  u ? S : Math.round(K + S) - Math.round(K),
                  u ? j : Math.round(Y + j) - Math.round(Y)
                ),
                  E.clip();
              }
              const C = (w.extent[0] - p[0]) * y,
                I = -(w.extent[3] - p[3]) * y,
                Z = X(w.extent) * y,
                W = de(w.extent) * y;
              E.drawImage(
                w.image,
                h,
                h,
                w.image.width - 2 * h,
                w.image.height - 2 * h,
                u ? C : Math.round(C),
                u ? I : Math.round(I),
                u ? Z : Math.round(C + Z) - Math.round(C),
                u ? W : Math.round(I + W) - Math.round(I)
              ),
                w.clipExtent && E.restore();
            }
          });
        }
        const v = it(o);
        return (
          a.getTriangles().forEach(function (w, A, x) {
            const C = w.source,
              I = w.target;
            let Z = C[0][0],
              W = C[0][1],
              K = C[1][0],
              Y = C[1][1],
              S = C[2][0],
              j = C[2][1];
            const k = _((I[0][0] - v[0]) / s),
              oe = _(-(I[0][1] - v[1]) / s),
              ye = _((I[1][0] - v[0]) / s),
              Ee = _(-(I[1][1] - v[1]) / s),
              B = _((I[2][0] - v[0]) / s),
              H = _(-(I[2][1] - v[1]) / s),
              te = Z,
              Ne = W;
            (Z = 0), (W = 0), (K -= te), (Y -= Ne), (S -= te), (j -= Ne);
            const Be = [
                [K, Y, 0, 0, ye - k],
                [S, j, 0, 0, B - k],
                [0, 0, K, Y, Ee - oe],
                [0, 0, S, j, H - oe],
              ],
              Te = Ko(Be);
            if (!Te) return;
            if ((f.save(), f.beginPath(), ec() || !u)) {
              f.moveTo(ye, Ee);
              const ae = 4,
                ze = k - ye,
                He = oe - Ee;
              for (let Le = 0; Le < ae; Le++)
                f.lineTo(
                  ye + _(((Le + 1) * ze) / ae),
                  Ee + _((Le * He) / (ae - 1))
                ),
                  Le != ae - 1 &&
                    f.lineTo(
                      ye + _(((Le + 1) * ze) / ae),
                      Ee + _(((Le + 1) * He) / (ae - 1))
                    );
              f.lineTo(B, H);
            } else f.moveTo(ye, Ee), f.lineTo(k, oe), f.lineTo(B, H);
            f.clip(),
              f.transform(Te[0], Te[2], Te[1], Te[3], k, oe),
              f.translate(p[0] - te, p[3] - Ne);
            let ue;
            if (E) (ue = E.canvas), f.scale(R, -R);
            else {
              const ae = l[0],
                ze = ae.extent;
              (ue = ae.image), f.scale(X(ze) / ue.width, -de(ze) / ue.height);
            }
            f.drawImage(ue, 0, 0), f.restore();
          }),
          E && (Vt(E), Oe.push(E.canvas)),
          c &&
            (f.save(),
            (f.globalCompositeOperation = "source-over"),
            (f.strokeStyle = "black"),
            (f.lineWidth = 1),
            a.getTriangles().forEach(function (w, A, x) {
              const C = w.target,
                I = (C[0][0] - v[0]) / s,
                Z = -(C[0][1] - v[1]) / s,
                W = (C[1][0] - v[0]) / s,
                K = -(C[1][1] - v[1]) / s,
                Y = (C[2][0] - v[0]) / s,
                S = -(C[2][1] - v[1]) / s;
              f.beginPath(),
                f.moveTo(W, K),
                f.lineTo(I, Z),
                f.lineTo(Y, S),
                f.closePath(),
                f.stroke();
            }),
            f.restore()),
          f.canvas
        );
      }
      class tc extends Ri {
        constructor(e) {
          super({
            tileCoord: e.tileCoord,
            loader: () => Promise.resolve(new Uint8ClampedArray(4)),
            interpolate: e.interpolate,
            transition: e.transition,
          }),
            (this.pixelRatio_ = e.pixelRatio),
            (this.gutter_ = e.gutter),
            (this.reprojData_ = null),
            (this.reprojError_ = null),
            (this.reprojSize_ = void 0),
            (this.sourceTileGrid_ = e.sourceTileGrid),
            (this.targetTileGrid_ = e.targetTileGrid),
            (this.wrappedTileCoord_ = e.wrappedTileCoord || e.tileCoord),
            (this.sourceTiles_ = []),
            (this.sourcesListenerKeys_ = null),
            (this.sourceZ_ = 0);
          const t = e.sourceProj,
            n = t.getExtent(),
            r = e.sourceTileGrid.getExtent();
          this.clipExtent_ = t.canWrapX() ? (r ? Re(n, r) : n) : r;
          const s = this.targetTileGrid_.getTileCoordExtent(
              this.wrappedTileCoord_
            ),
            o = this.targetTileGrid_.getExtent();
          let a = this.sourceTileGrid_.getExtent();
          const l = o ? Re(s, o) : s;
          if (kt(l) === 0) {
            this.state = T.EMPTY;
            return;
          }
          n && (a ? (a = Re(a, n)) : (a = n));
          const h = this.targetTileGrid_.getResolution(
              this.wrappedTileCoord_[0]
            ),
            c = e.targetProj,
            u = to(t, c, l, h);
          if (!isFinite(u) || u <= 0) {
            this.state = T.EMPTY;
            return;
          }
          const d = e.errorThreshold !== void 0 ? e.errorThreshold : Qs;
          if (
            ((this.triangulation_ = new eo(t, c, l, a, u * d, h)),
            this.triangulation_.getTriangles().length === 0)
          ) {
            this.state = T.EMPTY;
            return;
          }
          this.sourceZ_ = this.sourceTileGrid_.getZForResolution(u);
          let g = this.triangulation_.calculateSourceExtent();
          if (
            (a &&
              (t.canWrapX()
                ? ((g[1] = q(g[1], a[1], a[3])), (g[3] = q(g[3], a[1], a[3])))
                : (g = Re(g, a))),
            !kt(g))
          )
            this.state = T.EMPTY;
          else {
            let f = 0,
              _ = 0;
            t.canWrapX() && ((f = X(n)), (_ = Math.floor((g[0] - n[0]) / f))),
              cs(g.slice(), t, !0).forEach((E) => {
                const y = this.sourceTileGrid_.getTileRangeForExtentAndZ(
                    E,
                    this.sourceZ_
                  ),
                  R = e.getTileFunction;
                for (let v = y.minX; v <= y.maxX; v++)
                  for (let w = y.minY; w <= y.maxY; w++) {
                    const A = R(this.sourceZ_, v, w, this.pixelRatio_);
                    if (A) {
                      const x = _ * f;
                      this.sourceTiles_.push({ tile: A, offset: x });
                    }
                  }
                ++_;
              }),
              this.sourceTiles_.length === 0 && (this.state = T.EMPTY);
          }
        }
        getSize() {
          return this.reprojSize_;
        }
        getData() {
          return this.reprojData_;
        }
        getError() {
          return this.reprojError_;
        }
        reproject_() {
          const e = [];
          let t = !1;
          if (
            (this.sourceTiles_.forEach((f) => {
              var oe;
              const _ = f.tile;
              if (!_ || _.getState() !== T.LOADED) return;
              const p = _.getSize(),
                E = this.gutter_;
              let y;
              const R = Hh(_.getData());
              R ? (y = R) : ((t = !0), (y = $h(bn(_.getData()))));
              const v = [p[0] + 2 * E, p[1] + 2 * E],
                w = y instanceof Float32Array,
                A = v[0] * v[1],
                x = w ? Float32Array : Uint8ClampedArray,
                C = new x(y.buffer),
                I = x.BYTES_PER_ELEMENT,
                Z = (I * C.length) / A,
                W = C.byteLength / v[1],
                K = Math.floor(W / I / v[0]),
                Y = A * K;
              let S = C;
              if (C.length !== Y) {
                S = new x(Y);
                let ye = 0,
                  Ee = 0;
                const B = v[0] * K;
                for (let H = 0; H < v[1]; ++H) {
                  for (let te = 0; te < B; ++te) S[ye++] = C[Ee + te];
                  Ee += W / I;
                }
              }
              const j = this.sourceTileGrid_.getTileCoordExtent(_.tileCoord);
              (j[0] += f.offset), (j[2] += f.offset);
              const k = (oe = this.clipExtent_) == null ? void 0 : oe.slice();
              k && ((k[0] += f.offset), (k[2] += f.offset)),
                e.push({
                  extent: j,
                  clipExtent: k,
                  data: new Uint8ClampedArray(S.buffer),
                  dataType: x,
                  bytesPerPixel: Z,
                  pixelSize: v,
                });
            }),
            (this.sourceTiles_.length = 0),
            e.length === 0)
          ) {
            (this.state = T.ERROR), this.changed();
            return;
          }
          const n = this.wrappedTileCoord_[0],
            r = this.targetTileGrid_.getTileSize(n),
            s = typeof r == "number" ? r : r[0],
            o = typeof r == "number" ? r : r[1],
            a = this.targetTileGrid_.getResolution(n),
            l = this.sourceTileGrid_.getResolution(this.sourceZ_),
            h = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
          let c, u;
          const d = e[0].bytesPerPixel,
            g = Math.ceil(d / 3);
          for (let f = g - 1; f >= 0; --f) {
            const _ = [];
            for (let w = 0, A = e.length; w < A; ++w) {
              const x = e[w],
                C = x.data,
                I = x.pixelSize,
                Z = I[0],
                W = I[1],
                K = ie(Z, W, Oe),
                Y = K.createImageData(Z, W),
                S = Y.data;
              let j = f * 3;
              for (let k = 0, oe = S.length; k < oe; k += 4)
                (S[k] = C[j]),
                  (S[k + 1] = C[j + 1]),
                  (S[k + 2] = C[j + 2]),
                  (S[k + 3] = 255),
                  (j += d);
              K.putImageData(Y, 0, 0),
                _.push({
                  extent: x.extent,
                  clipExtent: x.clipExtent,
                  image: K.canvas,
                });
            }
            const p = no(
              s,
              o,
              this.pixelRatio_,
              l,
              this.sourceTileGrid_.getExtent(),
              a,
              h,
              this.triangulation_,
              _,
              this.gutter_,
              !1,
              !1,
              !1
            );
            for (let w = 0, A = _.length; w < A; ++w) {
              const C = _[w].image.getContext("2d");
              Vt(C), Oe.push(C.canvas);
            }
            const E = p.getContext("2d"),
              y = E.getImageData(0, 0, p.width, p.height);
            Vt(E),
              Oe.push(p),
              c ||
                ((u = new Uint8ClampedArray(d * y.width * y.height)),
                (c = new e[0].dataType(u.buffer)));
            const R = y.data;
            let v = f * 3;
            for (let w = 0, A = R.length; w < A; w += 4)
              R[w + 3] === 255
                ? ((u[v] = R[w]), (u[v + 1] = R[w + 1]), (u[v + 2] = R[w + 2]))
                : ((u[v] = 0), (u[v + 1] = 0), (u[v + 2] = 0)),
                (v += d);
          }
          if (t) {
            const f = ie(s, o),
              _ = new ImageData(c, s);
            f.putImageData(_, 0, 0), (this.reprojData_ = f.canvas);
          } else this.reprojData_ = c;
          (this.reprojSize_ = [
            Math.round(s * this.pixelRatio_),
            Math.round(o * this.pixelRatio_),
          ]),
            (this.state = T.LOADED),
            this.changed();
        }
        load() {
          if (this.state !== T.IDLE && this.state !== T.ERROR) return;
          (this.state = T.LOADING), this.changed();
          let e = 0;
          (this.sourcesListenerKeys_ = []),
            this.sourceTiles_.forEach(({ tile: t }) => {
              const n = t.getState();
              if (n !== T.IDLE && n !== T.LOADING) return;
              e++;
              const r = N(t, b.CHANGE, () => {
                const s = t.getState();
                (s == T.LOADED || s == T.ERROR || s == T.EMPTY) &&
                  (V(r),
                  e--,
                  e === 0 && (this.unlistenSources_(), this.reproject_()));
              });
              this.sourcesListenerKeys_.push(r);
            }),
            e === 0
              ? setTimeout(this.reproject_.bind(this), 0)
              : this.sourceTiles_.forEach(function ({ tile: t }) {
                  t.getState() == T.IDLE && t.load();
                });
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(V),
            (this.sourcesListenerKeys_ = null);
        }
      }
      class Ci extends qi {
        constructor(e, t, n, r, s, o, a, l, h, c, u, d) {
          super(s, T.IDLE, d),
            (this.renderEdges_ = u !== void 0 ? u : !1),
            (this.pixelRatio_ = a),
            (this.gutter_ = l),
            (this.canvas_ = null),
            (this.sourceTileGrid_ = t),
            (this.targetTileGrid_ = r),
            (this.wrappedTileCoord_ = o || s),
            (this.sourceTiles_ = []),
            (this.sourcesListenerKeys_ = null),
            (this.sourceZ_ = 0),
            (this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0);
          const g = r.getTileCoordExtent(this.wrappedTileCoord_),
            f = this.targetTileGrid_.getExtent();
          let _ = this.sourceTileGrid_.getExtent();
          const p = f ? Re(g, f) : g;
          if (kt(p) === 0) {
            this.state = T.EMPTY;
            return;
          }
          const E = e.getExtent();
          E && (_ ? (_ = Re(_, E)) : (_ = E));
          const y = r.getResolution(this.wrappedTileCoord_[0]),
            R = to(e, n, p, y);
          if (!isFinite(R) || R <= 0) {
            this.state = T.EMPTY;
            return;
          }
          const v = c !== void 0 ? c : Qs;
          if (
            ((this.triangulation_ = new eo(e, n, p, _, R * v, y)),
            this.triangulation_.getTriangles().length === 0)
          ) {
            this.state = T.EMPTY;
            return;
          }
          this.sourceZ_ = t.getZForResolution(R);
          let w = this.triangulation_.calculateSourceExtent();
          if (
            (_ &&
              (e.canWrapX()
                ? ((w[1] = q(w[1], _[1], _[3])), (w[3] = q(w[3], _[1], _[3])))
                : (w = Re(w, _))),
            !kt(w))
          )
            this.state = T.EMPTY;
          else {
            let A = 0,
              x = 0;
            e.canWrapX() && ((A = X(E)), (x = Math.floor((w[0] - E[0]) / A))),
              cs(w.slice(), e, !0).forEach((I) => {
                const Z = t.getTileRangeForExtentAndZ(I, this.sourceZ_);
                for (let W = Z.minX; W <= Z.maxX; W++)
                  for (let K = Z.minY; K <= Z.maxY; K++) {
                    const Y = h(this.sourceZ_, W, K, a);
                    if (Y) {
                      const S = x * A;
                      this.sourceTiles_.push({ tile: Y, offset: S });
                    }
                  }
                ++x;
              }),
              this.sourceTiles_.length === 0 && (this.state = T.EMPTY);
          }
        }
        getImage() {
          return this.canvas_;
        }
        reproject_() {
          const e = [];
          if (
            (this.sourceTiles_.forEach((t) => {
              var r;
              const n = t.tile;
              if (n && n.getState() == T.LOADED) {
                const s = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
                (s[0] += t.offset), (s[2] += t.offset);
                const o = (r = this.clipExtent_) == null ? void 0 : r.slice();
                o && ((o[0] += t.offset), (o[2] += t.offset)),
                  e.push({ extent: s, clipExtent: o, image: n.getImage() });
              }
            }),
            (this.sourceTiles_.length = 0),
            e.length === 0)
          )
            this.state = T.ERROR;
          else {
            const t = this.wrappedTileCoord_[0],
              n = this.targetTileGrid_.getTileSize(t),
              r = typeof n == "number" ? n : n[0],
              s = typeof n == "number" ? n : n[1],
              o = this.targetTileGrid_.getResolution(t),
              a = this.sourceTileGrid_.getResolution(this.sourceZ_),
              l = this.targetTileGrid_.getTileCoordExtent(
                this.wrappedTileCoord_
              );
            (this.canvas_ = no(
              r,
              s,
              this.pixelRatio_,
              a,
              this.sourceTileGrid_.getExtent(),
              o,
              l,
              this.triangulation_,
              e,
              this.gutter_,
              this.renderEdges_,
              this.interpolate
            )),
              (this.state = T.LOADED);
          }
          this.changed();
        }
        load() {
          if (this.state == T.IDLE) {
            (this.state = T.LOADING), this.changed();
            let e = 0;
            (this.sourcesListenerKeys_ = []),
              this.sourceTiles_.forEach(({ tile: t }) => {
                const n = t.getState();
                if (n == T.IDLE || n == T.LOADING) {
                  e++;
                  const r = N(t, b.CHANGE, (s) => {
                    const o = t.getState();
                    (o == T.LOADED || o == T.ERROR || o == T.EMPTY) &&
                      (V(r),
                      e--,
                      e === 0 && (this.unlistenSources_(), this.reproject_()));
                  });
                  this.sourcesListenerKeys_.push(r);
                }
              }),
              e === 0
                ? setTimeout(this.reproject_.bind(this), 0)
                : this.sourceTiles_.forEach(function ({ tile: t }, n, r) {
                    t.getState() == T.IDLE && t.load();
                  });
          }
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(V),
            (this.sourcesListenerKeys_ = null);
        }
        release() {
          this.canvas_ &&
            (Vt(this.canvas_.getContext("2d")),
            Oe.push(this.canvas_),
            (this.canvas_ = null)),
            super.release();
        }
      }
      function ci(i, e, t, n) {
        return `${i},${Vh(e, t, n)}`;
      }
      function ui(i, e, t) {
        if (!(t in i)) return (i[t] = new Set([e])), !0;
        const n = i[t],
          r = n.has(e);
        return r || n.add(e), !r;
      }
      function nc(i, e, t) {
        const n = i[t];
        return n ? n.delete(e) : !1;
      }
      function Qr(i, e) {
        const t = i.layerStatesArray[i.layerIndex];
        t.extent && (e = Re(e, Je(t.extent, i.viewState.projection)));
        const n = t.layer.getRenderSource();
        if (!n.getWrapX()) {
          const r = n
            .getTileGridForProjection(i.viewState.projection)
            .getExtent();
          r && (e = Re(e, r));
        }
        return e;
      }
      class ic extends ch {
        constructor(e, t) {
          super(e),
            (t = t || {}),
            (this.extentChanged = !0),
            (this.renderComplete = !1),
            (this.renderedExtent_ = null),
            this.renderedPixelRatio,
            (this.renderedProjection = null),
            this.renderedRevision,
            (this.renderedTiles = []),
            this.renderedSourceKey_,
            this.renderedSourceRevision_,
            (this.tempExtent = nt()),
            (this.tempTileRange_ = new er(0, 0, 0, 0)),
            (this.tempTileCoord_ = Ln(0, 0, 0));
          const n = t.cacheSize !== void 0 ? t.cacheSize : 512;
          (this.tileCache_ = new Kh(n)),
            (this.renderedProjection_ = void 0),
            (this.maxStaleKeys = n * 0.5);
        }
        getTileCache() {
          return this.tileCache_;
        }
        getOrCreateTile(e, t, n, r) {
          const s = this.tileCache_,
            a = this.getLayer().getSource(),
            l = ci(a.getKey(), e, t, n);
          let h;
          if (s.containsKey(l)) h = s.get(l);
          else {
            if (
              ((h = a.getTile(e, t, n, r.pixelRatio, r.viewState.projection)),
              !h)
            )
              return null;
            s.set(l, h);
          }
          return h;
        }
        getTile(e, t, n, r) {
          const s = this.getOrCreateTile(e, t, n, r);
          return s || null;
        }
        getData(e) {
          const t = this.frameState;
          if (!t) return null;
          const n = this.getLayer(),
            r = ge(t.pixelToCoordinateTransform, e.slice()),
            s = n.getExtent();
          if (s && !Ii(s, r)) return null;
          const o = t.viewState,
            a = n.getRenderSource(),
            l = a.getTileGridForProjection(o.projection),
            h = a.getTilePixelRatio(t.pixelRatio);
          for (
            let c = l.getZForResolution(o.resolution);
            c >= l.getMinZoom();
            --c
          ) {
            const u = l.getTileCoordForCoordAndZ(r, c),
              d = this.getTile(c, u[1], u[2], t);
            if (!d || d.getState() !== T.LOADED) continue;
            const g = l.getOrigin(c),
              f = ce(l.getTileSize(c)),
              _ = l.getResolution(c);
            let p;
            if (d instanceof Ks || d instanceof Ci) p = d.getImage();
            else if (d instanceof Ri) {
              if (((p = bn(d.getData())), !p)) continue;
            } else continue;
            const E = Math.floor(h * ((r[0] - g[0]) / _ - u[1] * f[0])),
              y = Math.floor(h * ((g[1] - r[1]) / _ - u[2] * f[1])),
              R = Math.round(h * a.getGutterForProjection(o.projection));
            return this.getImageData(p, E + R, y + R);
          }
          return null;
        }
        prepareFrame(e) {
          this.renderedProjection_
            ? e.viewState.projection !== this.renderedProjection_ &&
              (this.tileCache_.clear(),
              (this.renderedProjection_ = e.viewState.projection))
            : (this.renderedProjection_ = e.viewState.projection);
          const t = this.getLayer().getSource();
          if (!t) return !1;
          const n = t.getRevision();
          return (
            this.renderedRevision_
              ? this.renderedRevision_ !== n &&
                ((this.renderedRevision_ = n),
                this.renderedSourceKey_ === t.getKey() &&
                  this.tileCache_.clear())
              : (this.renderedRevision_ = n),
            !0
          );
        }
        enqueueTiles(e, t, n, r, s) {
          const o = e.viewState,
            a = this.getLayer(),
            l = a.getRenderSource(),
            h = l.getTileGridForProjection(o.projection),
            c = re(l);
          c in e.wantedTiles || (e.wantedTiles[c] = {});
          const u = e.wantedTiles[c],
            d = a.getMapInternal(),
            g = Math.max(
              n - s,
              h.getMinZoom(),
              h.getZForResolution(
                Math.min(
                  a.getMaxResolution(),
                  d
                    ? d
                        .getView()
                        .getResolutionForZoom(Math.max(a.getMinZoom(), 0))
                    : h.getResolution(0)
                ),
                l.zDirection
              )
            );
          for (let f = n; f >= g; --f) {
            const _ = h.getTileRangeForExtentAndZ(t, f, this.tempTileRange_),
              p = h.getResolution(f);
            for (let E = _.minX; E <= _.maxX; ++E)
              for (let y = _.minY; y <= _.maxY; ++y) {
                const R = this.getTile(f, E, y, e);
                if (!R || !ui(r, R, f)) continue;
                const w = R.getKey();
                if (
                  ((u[w] = !0),
                  R.getState() === T.IDLE && !e.tileQueue.isKeyQueued(w))
                ) {
                  const A = Ln(f, E, y, this.tempTileCoord_);
                  e.tileQueue.enqueue([R, c, h.getTileCoordCenter(A), p]);
                }
              }
          }
        }
        findStaleTile_(e, t) {
          const n = this.tileCache_,
            r = e[0],
            s = e[1],
            o = e[2],
            a = this.getStaleKeys();
          for (let l = 0; l < a.length; ++l) {
            const h = ci(a[l], r, s, o);
            if (n.containsKey(h)) {
              const c = n.get(h);
              if (c.getState() === T.LOADED)
                return c.endTransition(re(this)), ui(t, c, r), !0;
            }
          }
          return !1;
        }
        findAltTiles_(e, t, n, r) {
          const s = e.getTileRangeForTileCoordAndZ(t, n, this.tempTileRange_);
          if (!s) return !1;
          let o = !0;
          const a = this.tileCache_,
            h = this.getLayer().getRenderSource().getKey();
          for (let c = s.minX; c <= s.maxX; ++c)
            for (let u = s.minY; u <= s.maxY; ++u) {
              const d = ci(h, n, c, u);
              let g = !1;
              if (a.containsKey(d)) {
                const f = a.get(d);
                f.getState() === T.LOADED && (ui(r, f, n), (g = !0));
              }
              g || (o = !1);
            }
          return o;
        }
        renderFrame(e, t) {
          this.renderComplete = !0;
          const n = e.layerStatesArray[e.layerIndex],
            r = e.viewState,
            s = r.projection,
            o = r.resolution,
            a = r.center,
            l = e.pixelRatio,
            h = this.getLayer(),
            c = h.getSource(),
            u = c.getRevision(),
            d = c.getTileGridForProjection(s),
            g = d.getZForResolution(o, c.zDirection),
            f = d.getResolution(g),
            _ = c.getKey();
          this.renderedSourceKey_
            ? this.renderedSourceKey_ !== _ &&
              (this.prependStaleKey(this.renderedSourceKey_),
              (this.renderedSourceKey_ = _))
            : (this.renderedSourceKey_ = _);
          let p = e.extent;
          const E = c.getTilePixelRatio(l);
          this.prepareContainer(e, t);
          const y = this.context.canvas.width,
            R = this.context.canvas.height,
            v = n.extent && Je(n.extent, s);
          v && (p = Re(p, Je(n.extent, s)));
          const w = (f * y) / 2 / E,
            A = (f * R) / 2 / E,
            x = [a[0] - w, a[1] - A, a[0] + w, a[1] + A],
            C = {};
          this.renderedTiles.length = 0;
          const I = h.getPreload();
          if (e.nextExtent) {
            const B = d.getZForResolution(r.nextResolution, c.zDirection),
              H = Qr(e, e.nextExtent);
            this.enqueueTiles(e, H, B, C, I);
          }
          const Z = Qr(e, p);
          if (
            (this.enqueueTiles(e, Z, g, C, 0),
            I > 0 &&
              setTimeout(() => {
                this.enqueueTiles(e, Z, g - 1, C, I - 1);
              }, 0),
            !(g in C))
          )
            return this.container;
          const W = re(this),
            K = e.time;
          for (const B of C[g]) {
            const H = B.getState();
            if ((B instanceof Ci || B instanceof tc) && H === T.EMPTY) continue;
            const te = B.tileCoord;
            if (H === T.LOADED && B.getAlpha(W, K) === 1) {
              B.endTransition(W);
              continue;
            }
            if (((this.renderComplete = !1), this.findStaleTile_(te, C))) {
              nc(C, B, g), (e.animate = !0);
              continue;
            }
            if (this.findAltTiles_(d, te, g + 1, C)) continue;
            const Te = d.getMinZoom();
            for (
              let ue = g - 1;
              ue >= Te && !this.findAltTiles_(d, te, ue, C);
              --ue
            );
          }
          const Y = ((f / o) * l) / E,
            S = this.getRenderContext(e);
          zt(this.tempTransform, y / 2, R / 2, Y, Y, 0, -y / 2, -R / 2),
            n.extent && this.clipUnrotated(S, e, v),
            c.getInterpolate() || (S.imageSmoothingEnabled = !1),
            this.preRender(S, e);
          const j = Object.keys(C).map(Number);
          j.sort(Pn);
          let k;
          const oe = [],
            ye = [];
          for (let B = j.length - 1; B >= 0; --B) {
            const H = j[B],
              te = c.getTilePixelSize(H, l, s),
              Be = d.getResolution(H) / f,
              Te = te[0] * Be * Y,
              ue = te[1] * Be * Y,
              ae = d.getTileCoordForCoordAndZ(it(x), H),
              ze = d.getTileCoordExtent(ae),
              He = ge(this.tempTransform, [
                (E * (ze[0] - x[0])) / f,
                (E * (x[3] - ze[3])) / f,
              ]),
              Le = E * c.getGutterForProjection(s);
            for (const xt of C[H]) {
              if (xt.getState() !== T.LOADED) continue;
              const ir = xt.tileCoord,
                rr = ae[1] - ir[1],
                oo = Math.round(He[0] - (rr - 1) * Te),
                sr = ae[2] - ir[2],
                ao = Math.round(He[1] - (sr - 1) * ue),
                ke = Math.round(He[0] - rr * Te),
                Ge = Math.round(He[1] - sr * ue),
                rn = oo - ke,
                sn = ao - Ge,
                or = j.length === 1;
              let Hn = !1;
              k = [ke, Ge, ke + rn, Ge, ke + rn, Ge + sn, ke, Ge + sn];
              for (let on = 0, lo = oe.length; on < lo; ++on)
                if (!or && H < ye[on]) {
                  const fe = oe[on];
                  qt(
                    [ke, Ge, ke + rn, Ge + sn],
                    [fe[0], fe[3], fe[4], fe[7]]
                  ) &&
                    (Hn || (S.save(), (Hn = !0)),
                    S.beginPath(),
                    S.moveTo(k[0], k[1]),
                    S.lineTo(k[2], k[3]),
                    S.lineTo(k[4], k[5]),
                    S.lineTo(k[6], k[7]),
                    S.moveTo(fe[6], fe[7]),
                    S.lineTo(fe[4], fe[5]),
                    S.lineTo(fe[2], fe[3]),
                    S.lineTo(fe[0], fe[1]),
                    S.clip());
                }
              oe.push(k),
                ye.push(H),
                this.drawTile(xt, e, ke, Ge, rn, sn, Le, or),
                Hn && S.restore(),
                this.renderedTiles.unshift(xt),
                this.updateUsedTiles(e.usedTiles, c, xt);
            }
          }
          (this.renderedRevision = u),
            (this.renderedResolution = f),
            (this.extentChanged =
              !this.renderedExtent_ || !fi(this.renderedExtent_, x)),
            (this.renderedExtent_ = x),
            (this.renderedPixelRatio = l),
            (this.renderedProjection = s),
            this.postRender(this.context, e),
            n.extent && S.restore(),
            (S.imageSmoothingEnabled = !0);
          const Ee = (B, H) => {
            const te = re(c),
              Ne = H.wantedTiles[te],
              Be = Ne ? Object.keys(Ne).length : 0;
            this.updateCacheSize(Be), this.tileCache_.expireCache();
          };
          return e.postRenderFunctions.push(Ee), this.container;
        }
        updateCacheSize(e) {
          this.tileCache_.highWaterMark = Math.max(
            this.tileCache_.highWaterMark,
            e * 2
          );
        }
        drawTile(e, t, n, r, s, o, a, l) {
          let h;
          if (e instanceof Ri) {
            if (((h = bn(e.getData())), !h))
              throw new Error("Rendering array data is not yet supported");
          } else h = this.getTileImage(e);
          if (!h) return;
          const c = this.getRenderContext(t),
            u = re(this),
            d = t.layerStatesArray[t.layerIndex],
            g = d.opacity * (l ? e.getAlpha(u, t.time) : 1),
            f = g !== c.globalAlpha;
          f && (c.save(), (c.globalAlpha = g)),
            c.drawImage(h, a, a, h.width - 2 * a, h.height - 2 * a, n, r, s, o),
            f && c.restore(),
            g !== d.opacity ? (t.animate = !0) : l && e.endTransition(u);
        }
        getImage() {
          const e = this.context;
          return e ? e.canvas : null;
        }
        getTileImage(e) {
          return e.getImage();
        }
        updateUsedTiles(e, t, n) {
          const r = re(t);
          r in e || (e[r] = {}), (e[r][n.getKey()] = !0);
        }
      }
      class rc extends Bh {
        constructor(e) {
          super(e);
        }
        createRenderer() {
          return new ic(this, { cacheSize: this.getCacheSize() });
        }
      }
      const di = {
          TILELOADSTART: "tileloadstart",
          TILELOADEND: "tileloadend",
          TILELOADERROR: "tileloaderror",
        },
        dt = [0, 0, 0],
        Ye = 5;
      class io {
        constructor(e) {
          (this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0),
            (this.resolutions_ = e.resolutions),
            G(
              fo(this.resolutions_, (r, s) => s - r),
              "`resolutions` must be sorted in descending order"
            );
          let t;
          if (!e.origins) {
            for (let r = 0, s = this.resolutions_.length - 1; r < s; ++r)
              if (!t) t = this.resolutions_[r] / this.resolutions_[r + 1];
              else if (this.resolutions_[r] / this.resolutions_[r + 1] !== t) {
                t = void 0;
                break;
              }
          }
          (this.zoomFactor_ = t),
            (this.maxZoom = this.resolutions_.length - 1),
            (this.origin_ = e.origin !== void 0 ? e.origin : null),
            (this.origins_ = null),
            e.origins !== void 0 &&
              ((this.origins_ = e.origins),
              G(
                this.origins_.length == this.resolutions_.length,
                "Number of `origins` and `resolutions` must be equal"
              ));
          const n = e.extent;
          n !== void 0 &&
            !this.origin_ &&
            !this.origins_ &&
            (this.origin_ = it(n)),
            G(
              (!this.origin_ && this.origins_) ||
                (this.origin_ && !this.origins_),
              "Either `origin` or `origins` must be configured, never both"
            ),
            (this.tileSizes_ = null),
            e.tileSizes !== void 0 &&
              ((this.tileSizes_ = e.tileSizes),
              G(
                this.tileSizes_.length == this.resolutions_.length,
                "Number of `tileSizes` and `resolutions` must be equal"
              )),
            (this.tileSize_ =
              e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Zi),
            G(
              (!this.tileSize_ && this.tileSizes_) ||
                (this.tileSize_ && !this.tileSizes_),
              "Either `tileSize` or `tileSizes` must be configured, never both"
            ),
            (this.extent_ = n !== void 0 ? n : null),
            (this.fullTileRanges_ = null),
            (this.tmpSize_ = [0, 0]),
            (this.tmpExtent_ = [0, 0, 0, 0]),
            e.sizes !== void 0
              ? (this.fullTileRanges_ = e.sizes.map((r, s) => {
                  const o = new er(
                    Math.min(0, r[0]),
                    Math.max(r[0] - 1, -1),
                    Math.min(0, r[1]),
                    Math.max(r[1] - 1, -1)
                  );
                  if (n) {
                    const a = this.getTileRangeForExtentAndZ(n, s);
                    (o.minX = Math.max(a.minX, o.minX)),
                      (o.maxX = Math.min(a.maxX, o.maxX)),
                      (o.minY = Math.max(a.minY, o.minY)),
                      (o.maxY = Math.min(a.maxY, o.maxY));
                  }
                  return o;
                }))
              : n && this.calculateTileRanges_(n);
        }
        forEachTileCoord(e, t, n) {
          const r = this.getTileRangeForExtentAndZ(e, t);
          for (let s = r.minX, o = r.maxX; s <= o; ++s)
            for (let a = r.minY, l = r.maxY; a <= l; ++a) n([t, s, a]);
        }
        forEachTileCoordParentTileRange(e, t, n, r) {
          let s,
            o,
            a,
            l = null,
            h = e[0] - 1;
          for (
            this.zoomFactor_ === 2
              ? ((o = e[1]), (a = e[2]))
              : (l = this.getTileCoordExtent(e, r));
            h >= this.minZoom;

          ) {
            if (
              (o !== void 0 && a !== void 0
                ? ((o = Math.floor(o / 2)),
                  (a = Math.floor(a / 2)),
                  (s = ct(o, o, a, a, n)))
                : (s = this.getTileRangeForExtentAndZ(l, h, n)),
              t(h, s))
            )
              return !0;
            --h;
          }
          return !1;
        }
        getExtent() {
          return this.extent_;
        }
        getMaxZoom() {
          return this.maxZoom;
        }
        getMinZoom() {
          return this.minZoom;
        }
        getOrigin(e) {
          return this.origin_ ? this.origin_ : this.origins_[e];
        }
        getResolution(e) {
          return this.resolutions_[e];
        }
        getResolutions() {
          return this.resolutions_;
        }
        getTileCoordChildTileRange(e, t, n) {
          if (e[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
              const s = e[1] * 2,
                o = e[2] * 2;
              return ct(s, s + 1, o, o + 1, t);
            }
            const r = this.getTileCoordExtent(e, n || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(r, e[0] + 1, t);
          }
          return null;
        }
        getTileRangeForTileCoordAndZ(e, t, n) {
          if (t > this.maxZoom || t < this.minZoom) return null;
          const r = e[0],
            s = e[1],
            o = e[2];
          if (t === r) return ct(s, o, s, o, n);
          if (this.zoomFactor_) {
            const l = Math.pow(this.zoomFactor_, t - r),
              h = Math.floor(s * l),
              c = Math.floor(o * l);
            if (t < r) return ct(h, h, c, c, n);
            const u = Math.floor(l * (s + 1)) - 1,
              d = Math.floor(l * (o + 1)) - 1;
            return ct(h, u, c, d, n);
          }
          const a = this.getTileCoordExtent(e, this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(a, t, n);
        }
        getTileRangeForExtentAndZ(e, t, n) {
          this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, dt);
          const r = dt[1],
            s = dt[2];
          this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, dt);
          const o = dt[1],
            a = dt[2];
          return ct(r, o, s, a, n);
        }
        getTileCoordCenter(e) {
          const t = this.getOrigin(e[0]),
            n = this.getResolution(e[0]),
            r = ce(this.getTileSize(e[0]), this.tmpSize_);
          return [
            t[0] + (e[1] + 0.5) * r[0] * n,
            t[1] - (e[2] + 0.5) * r[1] * n,
          ];
        }
        getTileCoordExtent(e, t) {
          const n = this.getOrigin(e[0]),
            r = this.getResolution(e[0]),
            s = ce(this.getTileSize(e[0]), this.tmpSize_),
            o = n[0] + e[1] * s[0] * r,
            a = n[1] - (e[2] + 1) * s[1] * r,
            l = o + s[0] * r,
            h = a + s[1] * r;
          return Rt(o, a, l, h, t);
        }
        getTileCoordForCoordAndResolution(e, t, n) {
          return this.getTileCoordForXYAndResolution_(e[0], e[1], t, !1, n);
        }
        getTileCoordForXYAndResolution_(e, t, n, r, s) {
          const o = this.getZForResolution(n),
            a = n / this.getResolution(o),
            l = this.getOrigin(o),
            h = ce(this.getTileSize(o), this.tmpSize_);
          let c = (a * (e - l[0])) / n / h[0],
            u = (a * (l[1] - t)) / n / h[1];
          return (
            r
              ? ((c = cn(c, Ye) - 1), (u = cn(u, Ye) - 1))
              : ((c = hn(c, Ye)), (u = hn(u, Ye))),
            Ln(o, c, u, s)
          );
        }
        getTileCoordForXYAndZ_(e, t, n, r, s) {
          const o = this.getOrigin(n),
            a = this.getResolution(n),
            l = ce(this.getTileSize(n), this.tmpSize_);
          let h = (e - o[0]) / a / l[0],
            c = (o[1] - t) / a / l[1];
          return (
            r
              ? ((h = cn(h, Ye) - 1), (c = cn(c, Ye) - 1))
              : ((h = hn(h, Ye)), (c = hn(c, Ye))),
            Ln(n, h, c, s)
          );
        }
        getTileCoordForCoordAndZ(e, t, n) {
          return this.getTileCoordForXYAndZ_(e[0], e[1], t, !1, n);
        }
        getTileCoordResolution(e) {
          return this.resolutions_[e[0]];
        }
        getTileSize(e) {
          return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
        }
        getFullTileRange(e) {
          return this.fullTileRanges_
            ? this.fullTileRanges_[e]
            : this.extent_
            ? this.getTileRangeForExtentAndZ(this.extent_, e)
            : null;
        }
        getZForResolution(e, t) {
          const n = xi(this.resolutions_, e, t || 0);
          return q(n, this.minZoom, this.maxZoom);
        }
        tileCoordIntersectsViewport(e, t) {
          return Cs(t, 0, t.length, 2, this.getTileCoordExtent(e));
        }
        calculateTileRanges_(e) {
          const t = this.resolutions_.length,
            n = new Array(t);
          for (let r = this.minZoom; r < t; ++r)
            n[r] = this.getTileRangeForExtentAndZ(e, r);
          this.fullTileRanges_ = n;
        }
      }
      function ro(i) {
        let e = i.getDefaultTileGrid();
        return e || ((e = lc(i)), i.setDefaultTileGrid(e)), e;
      }
      function sc(i, e, t) {
        const n = e[0],
          r = i.getTileCoordCenter(e),
          s = tr(t);
        if (!Ii(s, r)) {
          const o = X(s),
            a = Math.ceil((s[0] - r[0]) / o);
          return (r[0] += o * a), i.getTileCoordForCoordAndZ(r, n);
        }
        return e;
      }
      function oc(i, e, t, n) {
        n = n !== void 0 ? n : "top-left";
        const r = so(i, e, t);
        return new io({
          extent: i,
          origin: Ao(i, n),
          resolutions: r,
          tileSize: t,
        });
      }
      function ac(i) {
        const e = i || {},
          t = e.extent || pe("EPSG:3857").getExtent(),
          n = {
            extent: t,
            minZoom: e.minZoom,
            tileSize: e.tileSize,
            resolutions: so(t, e.maxZoom, e.tileSize, e.maxResolution),
          };
        return new io(n);
      }
      function so(i, e, t, n) {
        (e = e !== void 0 ? e : Qa), (t = ce(t !== void 0 ? t : Zi));
        const r = de(i),
          s = X(i);
        n = n > 0 ? n : Math.max(s / t[0], r / t[1]);
        const o = e + 1,
          a = new Array(o);
        for (let l = 0; l < o; ++l) a[l] = n / Math.pow(2, l);
        return a;
      }
      function lc(i, e, t, n) {
        const r = tr(i);
        return oc(r, e, t, n);
      }
      function tr(i) {
        i = pe(i);
        let e = i.getExtent();
        if (!e) {
          const t = (180 * Ai.degrees) / i.getMetersPerUnit();
          e = Rt(-t, -t, t, t);
        }
        return e;
      }
      class hc extends uh {
        constructor(e) {
          super({
            attributions: e.attributions,
            attributionsCollapsible: e.attributionsCollapsible,
            projection: e.projection,
            state: e.state,
            wrapX: e.wrapX,
            interpolate: e.interpolate,
          }),
            this.on,
            this.once,
            this.un,
            (this.tilePixelRatio_ =
              e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1),
            (this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null);
          const t = [256, 256];
          this.tileGrid &&
            ce(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t),
            (this.tmpSize = [0, 0]),
            (this.key_ = e.key || re(this)),
            (this.tileOptions = {
              transition: e.transition,
              interpolate: e.interpolate,
            }),
            (this.zDirection = e.zDirection ? e.zDirection : 0);
        }
        getGutterForProjection(e) {
          return 0;
        }
        getKey() {
          return this.key_;
        }
        setKey(e) {
          this.key_ !== e && ((this.key_ = e), this.changed());
        }
        getResolutions(e) {
          const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
          return t ? t.getResolutions() : null;
        }
        getTile(e, t, n, r, s) {
          return D();
        }
        getTileGrid() {
          return this.tileGrid;
        }
        getTileGridForProjection(e) {
          return this.tileGrid ? this.tileGrid : ro(e);
        }
        getTilePixelRatio(e) {
          return this.tilePixelRatio_;
        }
        getTilePixelSize(e, t, n) {
          const r = this.getTileGridForProjection(n),
            s = this.getTilePixelRatio(t),
            o = ce(r.getTileSize(e), this.tmpSize);
          return s == 1 ? o : Wa(o, s, this.tmpSize);
        }
        getTileCoordForTileUrlFunction(e, t) {
          t = t !== void 0 ? t : this.getProjection();
          const n = this.getTileGridForProjection(t);
          return (
            this.getWrapX() && t.isGlobal() && (e = sc(n, e, t)),
            jh(e, n) ? e : null
          );
        }
        clear() {}
        refresh() {
          this.clear(), super.refresh();
        }
      }
      class cc extends je {
        constructor(e, t) {
          super(e), (this.tile = t);
        }
      }
      const uc = /\{z\}/g,
        dc = /\{x\}/g,
        fc = /\{y\}/g,
        gc = /\{-y\}/g;
      function _c(i, e, t, n, r) {
        return i
          .replace(uc, e.toString())
          .replace(dc, t.toString())
          .replace(fc, n.toString())
          .replace(gc, function () {
            if (r === void 0)
              throw new Error(
                "If the URL template has a {-y} placeholder, the grid extent must be known"
              );
            return (r - n).toString();
          });
      }
      function mc(i) {
        const e = [];
        let t = /\{([a-z])-([a-z])\}/.exec(i);
        if (t) {
          const n = t[1].charCodeAt(0),
            r = t[2].charCodeAt(0);
          let s;
          for (s = n; s <= r; ++s)
            e.push(i.replace(t[0], String.fromCharCode(s)));
          return e;
        }
        if (((t = /\{(\d+)-(\d+)\}/.exec(i)), t)) {
          const n = parseInt(t[2], 10);
          for (let r = parseInt(t[1], 10); r <= n; r++)
            e.push(i.replace(t[0], r.toString()));
          return e;
        }
        return e.push(i), e;
      }
      function pc(i, e) {
        return function (t, n, r) {
          if (!t) return;
          let s;
          const o = t[0];
          if (e) {
            const a = e.getFullTileRange(o);
            a && (s = a.getHeight() - 1);
          }
          return _c(i, o, t[1], t[2], s);
        };
      }
      function yc(i, e) {
        const t = i.length,
          n = new Array(t);
        for (let r = 0; r < t; ++r) n[r] = pc(i[r], e);
        return Ec(n);
      }
      function Ec(i) {
        return i.length === 1
          ? i[0]
          : function (e, t, n) {
              if (!e) return;
              const r = Wh(e),
                s = wt(r, i.length);
              return i[s](e, t, n);
            };
      }
      class nr extends hc {
        constructor(e) {
          super({
            attributions: e.attributions,
            cacheSize: e.cacheSize,
            projection: e.projection,
            state: e.state,
            tileGrid: e.tileGrid,
            tilePixelRatio: e.tilePixelRatio,
            wrapX: e.wrapX,
            transition: e.transition,
            interpolate: e.interpolate,
            key: e.key,
            attributionsCollapsible: e.attributionsCollapsible,
            zDirection: e.zDirection,
          }),
            (this.generateTileUrlFunction_ =
              this.tileUrlFunction === nr.prototype.tileUrlFunction),
            (this.tileLoadFunction = e.tileLoadFunction),
            e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction),
            (this.urls = null),
            e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url),
            (this.tileLoadingKeys_ = {});
        }
        getTileLoadFunction() {
          return this.tileLoadFunction;
        }
        getTileUrlFunction() {
          return Object.getPrototypeOf(this).tileUrlFunction ===
            this.tileUrlFunction
            ? this.tileUrlFunction.bind(this)
            : this.tileUrlFunction;
        }
        getUrls() {
          return this.urls;
        }
        handleTileChange(e) {
          const t = e.target,
            n = re(t),
            r = t.getState();
          let s;
          r == T.LOADING
            ? ((this.tileLoadingKeys_[n] = !0), (s = di.TILELOADSTART))
            : n in this.tileLoadingKeys_ &&
              (delete this.tileLoadingKeys_[n],
              (s =
                r == T.ERROR
                  ? di.TILELOADERROR
                  : r == T.LOADED
                  ? di.TILELOADEND
                  : void 0)),
            s != null && this.dispatchEvent(new cc(s, t));
        }
        setTileLoadFunction(e) {
          (this.tileLoadFunction = e), this.changed();
        }
        setTileUrlFunction(e, t) {
          (this.tileUrlFunction = e),
            typeof t < "u" ? this.setKey(t) : this.changed();
        }
        setUrl(e) {
          const t = mc(e);
          (this.urls = t), this.setUrls(t);
        }
        setUrls(e) {
          this.urls = e;
          const t = e.join(`
`);
          this.generateTileUrlFunction_
            ? this.setTileUrlFunction(yc(e, this.tileGrid), t)
            : this.setKey(t);
        }
        tileUrlFunction(e, t, n) {}
      }
      class wc extends nr {
        constructor(e) {
          super({
            attributions: e.attributions,
            cacheSize: e.cacheSize,
            projection: e.projection,
            state: e.state,
            tileGrid: e.tileGrid,
            tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : vc,
            tilePixelRatio: e.tilePixelRatio,
            tileUrlFunction: e.tileUrlFunction,
            url: e.url,
            urls: e.urls,
            wrapX: e.wrapX,
            transition: e.transition,
            interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
            key: e.key,
            attributionsCollapsible: e.attributionsCollapsible,
            zDirection: e.zDirection,
          }),
            (this.crossOrigin =
              e.crossOrigin !== void 0 ? e.crossOrigin : null),
            (this.tileClass = e.tileClass !== void 0 ? e.tileClass : Ks),
            (this.tileGridForProjection = {}),
            (this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold),
            (this.renderReprojectionEdges_ = !1);
        }
        getGutterForProjection(e) {
          return this.getProjection() && e && !qn(this.getProjection(), e)
            ? 0
            : this.getGutter();
        }
        getGutter() {
          return 0;
        }
        getKey() {
          let e = super.getKey();
          return this.getInterpolate() || (e += ":disable-interpolation"), e;
        }
        getTileGridForProjection(e) {
          const t = this.getProjection();
          if (this.tileGrid && (!t || qn(t, e))) return this.tileGrid;
          const n = re(e);
          return (
            n in this.tileGridForProjection ||
              (this.tileGridForProjection[n] = ro(e)),
            this.tileGridForProjection[n]
          );
        }
        createTile_(e, t, n, r, s, o) {
          const a = [e, t, n],
            l = this.getTileCoordForTileUrlFunction(a, s),
            h = l ? this.tileUrlFunction(l, r, s) : void 0,
            c = new this.tileClass(
              a,
              h !== void 0 ? T.IDLE : T.EMPTY,
              h !== void 0 ? h : "",
              this.crossOrigin,
              this.tileLoadFunction,
              this.tileOptions
            );
          return (
            (c.key = o),
            c.addEventListener(b.CHANGE, this.handleTileChange.bind(this)),
            c
          );
        }
        getTile(e, t, n, r, s) {
          const o = this.getProjection();
          if (!o || !s || qn(o, s))
            return this.getTileInternal(e, t, n, r, o || s);
          const a = [e, t, n],
            l = this.getKey(),
            h = this.getTileGridForProjection(o),
            c = this.getTileGridForProjection(s),
            u = this.getTileCoordForTileUrlFunction(a, s),
            d = new Ci(
              o,
              h,
              s,
              c,
              a,
              u,
              this.getTilePixelRatio(r),
              this.getGutter(),
              (g, f, _, p) => this.getTileInternal(g, f, _, p, o),
              this.reprojectionErrorThreshold_,
              this.renderReprojectionEdges_,
              this.tileOptions
            );
          return (d.key = l), d;
        }
        getTileInternal(e, t, n, r, s) {
          const o = this.getKey();
          return this.createTile_(e, t, n, r, s, o);
        }
        setRenderReprojectionEdges(e) {
          this.renderReprojectionEdges_ != e &&
            ((this.renderReprojectionEdges_ = e), this.changed());
        }
        setTileGridForProjection(e, t) {
          const n = pe(e);
          if (n) {
            const r = re(n);
            r in this.tileGridForProjection ||
              (this.tileGridForProjection[r] = t);
          }
        }
      }
      function vc(i, e) {
        i.getImage().src = e;
      }
      class Rc extends wc {
        constructor(e) {
          e = e || {};
          const t = e.projection !== void 0 ? e.projection : "EPSG:3857",
            n =
              e.tileGrid !== void 0
                ? e.tileGrid
                : ac({
                    extent: tr(t),
                    maxResolution: e.maxResolution,
                    maxZoom: e.maxZoom,
                    minZoom: e.minZoom,
                    tileSize: e.tileSize,
                  });
          super({
            attributions: e.attributions,
            cacheSize: e.cacheSize,
            crossOrigin: e.crossOrigin,
            interpolate: e.interpolate,
            projection: t,
            reprojectionErrorThreshold: e.reprojectionErrorThreshold,
            tileGrid: n,
            tileLoadFunction: e.tileLoadFunction,
            tilePixelRatio: e.tilePixelRatio,
            tileUrlFunction: e.tileUrlFunction,
            url: e.url,
            urls: e.urls,
            wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
            transition: e.transition,
            attributionsCollapsible: e.attributionsCollapsible,
            zDirection: e.zDirection,
          }),
            (this.gutter_ = e.gutter !== void 0 ? e.gutter : 0);
        }
        getGutter() {
          return this.gutter_;
        }
      }
      const Cc =
        '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
      class Tc extends Rc {
        constructor(e) {
          e = e || {};
          let t;
          e.attributions !== void 0 ? (t = e.attributions) : (t = [Cc]);
          const n = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous",
            r =
              e.url !== void 0
                ? e.url
                : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
          super({
            attributions: t,
            attributionsCollapsible: !1,
            cacheSize: e.cacheSize,
            crossOrigin: n,
            interpolate: e.interpolate,
            maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
            reprojectionErrorThreshold: e.reprojectionErrorThreshold,
            tileLoadFunction: e.tileLoadFunction,
            transition: e.transition,
            url: r,
            wrapX: e.wrapX,
            zDirection: e.zDirection,
          });
        }
      }
      na();
      var ts, ns;
      (ns = (ts = document.documentElement) == null ? void 0 : ts.classList) !=
        null && ns.contains("dark");
      const Ti = document.getElementById("crossElement");
      let We = {
          center: [0, 0],
          zoom: 10,
          color: "red",
          theme: "dark",
          bgColor: "black",
        },
        et = null;
      const xc = () => {
        (et = new Yh({
          target: "map",
          layers: [new rc({ source: new Tc(), className: "ol_bw" })],
          interactions: qs({ dragPan: !1, mouseWheelZoom: !1 }).extend([
            new Bs({ kinetic: !1 }),
            new Hs({ duration: 0 }),
          ]),
          view: new xe({
            center: We.center,
            zoom: We.zoom,
            constrainRotation: !1,
            constrainResolution: !0,
            smoothExtentConstraint: !1,
          }),
          controls: [],
        })),
          et.on("loadend", () => {
            (Ti.style.left = `${
              document.documentElement.clientWidth / 2 - 25
            }px`),
              (Ti.style.top = `${
                document.documentElement.clientHeight / 2 - 50
              }px`);
          }),
          et.on("moveend", (i) => {
            var s;
            const e = et.getView().getCenter(),
              [t, n] = e,
              r = { event: "center", data: { lat: n, lon: t } };
            (s = window.ReactNativeWebView) == null ||
              s.postMessage(JSON.stringify(r));
          });
      };
      var Ic = function (i) {
        const e = JSON.parse(i.data);
        if (e)
          try {
            switch (e.msg) {
              case "theme":
                (We = { ...We, ...e }), es(), et.render();
                break;
              case "center":
                setCenter(e.center);
                break;
              case "zoom":
                et.getView().animate({ zoom: e.zoom, duration: 200 });
                break;
              case "init":
                (We = { ...We, ...e }), es(), xc();
                break;
              default:
                break;
            }
          } catch (t) {
            alert(`message:err: ${JSON.stringify(t.toString() || t.message)}`);
          }
      };
      const es = () => {
        var i, e;
        Ti.querySelectorAll("path").forEach((t) => {
          t.style.fill = We.color;
        }),
          We.theme == "dark"
            ? (i = document.documentElement) == null || i.classList.add("dark")
            : (e = document.documentElement) == null ||
              e.classList.remove("dark");
      };
      document && document.addEventListener("message", Ic);
      var is;
      (is = window.ReactNativeWebView) == null ||
        is.postMessage(JSON.stringify({ event: "ready" }));
      window.setCenter = (i) => {
        et.getView().animate({ center: [i.lon, i.lat] });
      };
      //# sourceMappingURL=index-DDOFpm8H.js.map
    </script>
    <style rel="stylesheet" crossorigin>
      :root,
      :host {
        --ol-background-color: white;
        --ol-accent-background-color: #f5f5f5;
        --ol-subtle-background-color: rgba(128, 128, 128, 0.25);
        --ol-partial-background-color: rgba(255, 255, 255, 0.75);
        --ol-foreground-color: #333333;
        --ol-subtle-foreground-color: #666666;
        --ol-brand-color: #00aaff;
      }
      .ol-box {
        box-sizing: border-box;
        border-radius: 2px;
        border: 1.5px solid var(--ol-background-color);
        background-color: var(--ol-partial-background-color);
      }
      .ol-mouse-position {
        top: 8px;
        right: 8px;
        position: absolute;
      }
      .ol-scale-line {
        background: var(--ol-partial-background-color);
        border-radius: 4px;
        bottom: 8px;
        left: 8px;
        padding: 2px;
        position: absolute;
      }
      .ol-scale-line-inner {
        border: 1px solid var(--ol-subtle-foreground-color);
        border-top: none;
        color: var(--ol-foreground-color);
        font-size: 10px;
        text-align: center;
        margin: 1px;
        will-change: contents, width;
        transition: all 0.25s;
      }
      .ol-scale-bar {
        position: absolute;
        bottom: 8px;
        left: 8px;
      }
      .ol-scale-bar-inner {
        display: flex;
      }
      .ol-scale-step-marker {
        width: 1px;
        height: 15px;
        background-color: var(--ol-foreground-color);
        float: right;
        z-index: 10;
      }
      .ol-scale-step-text {
        position: absolute;
        bottom: -5px;
        font-size: 10px;
        z-index: 11;
        color: var(--ol-foreground-color);
        text-shadow: -1.5px 0 var(--ol-partial-background-color),
          0 1.5px var(--ol-partial-background-color),
          1.5px 0 var(--ol-partial-background-color),
          0 -1.5px var(--ol-partial-background-color);
      }
      .ol-scale-text {
        position: absolute;
        font-size: 12px;
        text-align: center;
        bottom: 25px;
        color: var(--ol-foreground-color);
        text-shadow: -1.5px 0 var(--ol-partial-background-color),
          0 1.5px var(--ol-partial-background-color),
          1.5px 0 var(--ol-partial-background-color),
          0 -1.5px var(--ol-partial-background-color);
      }
      .ol-scale-singlebar {
        position: relative;
        height: 10px;
        z-index: 9;
        box-sizing: border-box;
        border: 1px solid var(--ol-foreground-color);
      }
      .ol-scale-singlebar-even {
        background-color: var(--ol-subtle-foreground-color);
      }
      .ol-scale-singlebar-odd {
        background-color: var(--ol-background-color);
      }
      .ol-unsupported {
        display: none;
      }
      .ol-viewport,
      .ol-unselectable {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      .ol-viewport canvas {
        all: unset;
        overflow: hidden;
      }
      .ol-viewport {
        touch-action: pan-x pan-y;
      }
      .ol-selectable {
        -webkit-touch-callout: default;
        -webkit-user-select: text;
        -moz-user-select: text;
        user-select: text;
      }
      .ol-grabbing {
        cursor: -webkit-grabbing;
        cursor: -moz-grabbing;
        cursor: grabbing;
      }
      .ol-grab {
        cursor: move;
        cursor: -webkit-grab;
        cursor: -moz-grab;
        cursor: grab;
      }
      .ol-control {
        position: absolute;
        background-color: var(--ol-subtle-background-color);
        border-radius: 4px;
      }
      .ol-zoom {
        top: 0.5em;
        left: 0.5em;
      }
      .ol-rotate {
        top: 0.5em;
        right: 0.5em;
        transition: opacity 0.25s linear, visibility 0s linear;
      }
      .ol-rotate.ol-hidden {
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.25s linear, visibility 0s linear 0.25s;
      }
      .ol-zoom-extent {
        top: 4.643em;
        left: 0.5em;
      }
      .ol-full-screen {
        right: 0.5em;
        top: 0.5em;
      }
      .ol-control button {
        display: block;
        margin: 1px;
        padding: 0;
        color: var(--ol-subtle-foreground-color);
        font-weight: 700;
        text-decoration: none;
        font-size: inherit;
        text-align: center;
        height: 1.375em;
        width: 1.375em;
        line-height: 0.4em;
        background-color: var(--ol-background-color);
        border: none;
        border-radius: 2px;
      }
      .ol-control button::-moz-focus-inner {
        border: none;
        padding: 0;
      }
      .ol-zoom-extent button {
        line-height: 1.4em;
      }
      .ol-compass {
        display: block;
        font-weight: 400;
        will-change: transform;
      }
      .ol-touch .ol-control button {
        font-size: 1.5em;
      }
      .ol-touch .ol-zoom-extent {
        top: 5.5em;
      }
      .ol-control button:hover,
      .ol-control button:focus {
        text-decoration: none;
        outline: 1px solid var(--ol-subtle-foreground-color);
        color: var(--ol-foreground-color);
      }
      .ol-zoom .ol-zoom-in {
        border-radius: 2px 2px 0 0;
      }
      .ol-zoom .ol-zoom-out {
        border-radius: 0 0 2px 2px;
      }
      .ol-attribution {
        text-align: right;
        bottom: 0.5em;
        right: 0.5em;
        max-width: calc(100% - 1.3em);
        display: flex;
        flex-flow: row-reverse;
        align-items: center;
      }
      .ol-attribution a {
        color: var(--ol-subtle-foreground-color);
        text-decoration: none;
      }
      .ol-attribution ul {
        margin: 0;
        padding: 1px 0.5em;
        color: var(--ol-foreground-color);
        text-shadow: 0 0 2px var(--ol-background-color);
        font-size: 12px;
      }
      .ol-attribution li {
        display: inline;
        list-style: none;
      }
      .ol-attribution li:not(:last-child):after {
        content: " ";
      }
      .ol-attribution img {
        max-height: 2em;
        max-width: inherit;
        vertical-align: middle;
      }
      .ol-attribution button {
        flex-shrink: 0;
      }
      .ol-attribution.ol-collapsed ul {
        display: none;
      }
      .ol-attribution:not(.ol-collapsed) {
        background: var(--ol-partial-background-color);
      }
      .ol-attribution.ol-uncollapsible {
        bottom: 0;
        right: 0;
        border-radius: 4px 0 0;
      }
      .ol-attribution.ol-uncollapsible img {
        margin-top: -0.2em;
        max-height: 1.6em;
      }
      .ol-attribution.ol-uncollapsible button {
        display: none;
      }
      .ol-zoomslider {
        top: 4.5em;
        left: 0.5em;
        height: 200px;
      }
      .ol-zoomslider button {
        position: relative;
        height: 10px;
      }
      .ol-touch .ol-zoomslider {
        top: 5.5em;
      }
      .ol-overviewmap {
        left: 0.5em;
        bottom: 0.5em;
      }
      .ol-overviewmap.ol-uncollapsible {
        bottom: 0;
        left: 0;
        border-radius: 0 4px 0 0;
      }
      .ol-overviewmap .ol-overviewmap-map,
      .ol-overviewmap button {
        display: block;
      }
      .ol-overviewmap .ol-overviewmap-map {
        border: 1px solid var(--ol-subtle-foreground-color);
        height: 150px;
        width: 150px;
      }
      .ol-overviewmap:not(.ol-collapsed) button {
        bottom: 0;
        left: 0;
        position: absolute;
      }
      .ol-overviewmap.ol-collapsed .ol-overviewmap-map,
      .ol-overviewmap.ol-uncollapsible button {
        display: none;
      }
      .ol-overviewmap:not(.ol-collapsed) {
        background: var(--ol-subtle-background-color);
      }
      .ol-overviewmap-box {
        border: 1.5px dotted var(--ol-subtle-foreground-color);
      }
      .ol-overviewmap .ol-overviewmap-box:hover {
        cursor: move;
      }
      .ol-overviewmap .ol-viewport:hover {
        cursor: pointer;
      }
      html,
      body {
        margin: 0;
        height: 100%;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
      #crossElement {
        position: absolute;
        z-index: 999999;
        display: block;
        font-size: 50px;
        display: none;
      }
      #crossElement {
        pointer-events: none;
      }
      :root.dark,
      :host.dark {
        --ol-background-color: #252527;
        --ol-accent-background-color: #f5f5f5;
        --ol-subtle-background-color: rgba(128, 128, 128, 0.25);
        --ol-partial-background-color: rgba(255, 255, 255, 0.75);
        --ol-foreground-color: #666666;
        --ol-subtle-foreground-color: #666666;
        --ol-brand-color: #00aaff;
      }
      .dark .ol_bw,
      .dark #map .leaflet-layer,
      .dark #map .leaflet-control-zoom-in,
      .dark #map .leaflet-control-zoom-out,
      .dark #map .leaflet-control-attribution,
      .dark .streets .leaflet-layer,
      .dark .streets .leaflet-control-zoom-in,
      .dark .streets .leaflet-control-zoom-out,
      .dark .streets .leaflet-control-attribution,
      .dark .terrain .leaflet-layer,
      .dark .terrain .leaflet-control-zoom-in,
      .dark .terrain .leaflet-control-zoom-out,
      .dark .terrain .leaflet-control-attribution {
        filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg)
          saturate(0.3) brightness(0.7);
      }
    </style>
  </head>
  <body
    style="display: flex; height: 100vh; margin: 0; background: transparent"
  >
    <div id="map" class="openstreetmap" style="flex: 1"></div>
    <div id="crossElement">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        width="1em"
        height="1em"
        fill="currentColor"
        viewBox="0 0 16 16"
        version="1.1"
      >
        <g id="surface1">
          <path
            style="
              stroke: none;
              fill-rule: nonzero;
              fill: rgb(0%, 0%, 0%);
              fill-opacity: 1;
            "
            d="M 8 16.5 Q 7.5 16.5 7.5 16 Q 7.5 14 5 12 Q 2 10 2 6 L 4 6 A 1 1 0 0 0 12 6 A 1 1 0 0 0 4 6 H 2 A 1 1 0 0 1 14 6 Q 14 10 11 12 Q 8.5 14 8.5 16 Q 8.5 16.5 8 16.5 Z Z"
          />
          <!-- <path
            style="
              stroke: none;
              fill-rule: nonzero;
              fill: rgb(100%, 100%, 100%);
              fill-opacity: 1;
              scale: 0.5;
              translate: 4px 2px;
            "
            d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16 M5.255 5.7a.2.2 0 0 0 .2.2h.8c.1 0 .2-.1.2-.2.09-.6.5-1.1 1.3-1.14.6 0 1.3.3 1.3 1.168 0 .6-.3.9-.9 1.3-.6.4-1.2 1.06-1.1 1.9l.0.2a.25.25 0 0 0 .2.2h.8a.25.25 0 0 0 .25-.25v-.105c0-.7.2-.9 1.01-1.4.6-.4 1.2-.9 1.2-2.0 0-1.5-1.2-2.2-2.6-2.2-1.2 0-2.6.6-2.7 2.2m1.5 5.7c0 .5.4.927 1.01.9.6 0 1.028-.394 1.0-.9 0-.552-.42-.94-1.029-.94-.5 0-1.009.38-1.0.94"
          /> -->
        </g>
      </svg>
    </div>
  </body>
</html>
